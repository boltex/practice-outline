{
  "leoHeader": {
    "fileFormat": 2
  },
  "vnodes": [
    {
      "gnx": "felix.20250907225515.1",
      "vh": "test script"
    },
    {
      "gnx": "felix.20250910212852.1",
      "vh": "Minimal HTML with VNode"
    },
    {
      "gnx": "felix.20250908213416.1",
      "vh": "Minimal HTML with Position"
    },
    {
      "gnx": "felix.20250914133503.1",
      "vh": "vnode JSON Compact script"
    },
    {
      "gnx": "felix.20250920001725.1",
      "vh": "@button export-html",
      "children": [
        {
          "gnx": "felix.20250920001725.2",
          "vh": "htmlPrefix"
        },
        {
          "gnx": "felix.20250920001725.3",
          "vh": "htmlSuffix"
        }
      ]
    },
    {
      "gnx": "felix.20250921150949.1",
      "vh": "@clean outline-viewer.html",
      "children": [
        {
          "gnx": "felix.20250921151054.1",
          "vh": "head",
          "children": [
            {
              "gnx": "felix.20250921151305.1",
              "vh": "meta"
            },
            {
              "gnx": "felix.20250921151315.1",
              "vh": "title"
            },
            {
              "gnx": "felix.20250921151320.1",
              "vh": "style"
            }
          ]
        },
        {
          "gnx": "felix.20250921151110.1",
          "vh": "body",
          "children": [
            {
              "gnx": "felix.20250921152808.1",
              "vh": "DOM Elements"
            },
            {
              "gnx": "felix.20250921152833.1",
              "vh": "script",
              "children": [
                {
                  "gnx": "felix.20250921155000.1",
                  "vh": "Default Outline Data"
                },
                {
                  "gnx": "felix.20250921155018.1",
                  "vh": "Init Outline Data"
                },
                {
                  "gnx": "felix.20250921155109.1",
                  "vh": "Global Variables"
                },
                {
                  "gnx": "felix.20250921155114.1",
                  "vh": "Global Elements"
                },
                {
                  "gnx": "felix.20250921155143.1",
                  "vh": "Navigation helpers"
                },
                {
                  "gnx": "felix.20250921155219.1",
                  "vh": "Navigation actions"
                },
                {
                  "gnx": "felix.20250921155503.1",
                  "vh": "Button states"
                },
                {
                  "gnx": "felix.20250921155509.1",
                  "vh": "History"
                },
                {
                  "gnx": "felix.20250921155516.1",
                  "vh": "Rendering helpers"
                },
                {
                  "gnx": "felix.20250921163309.1",
                  "vh": "Utilities"
                },
                {
                  "gnx": "felix.20250921155710.1",
                  "vh": "UI"
                },
                {
                  "gnx": "felix.20250921170854.1",
                  "vh": "Setup Event Handlers"
                },
                {
                  "gnx": "felix.20250921172409.1",
                  "vh": "Event Handlers"
                },
                {
                  "gnx": "felix.20250921164204.1",
                  "vh": "States Persistance"
                },
                {
                  "gnx": "felix.20250921172713.1",
                  "vh": "Find Text"
                },
                {
                  "gnx": "felix.20250921173505.1",
                  "vh": "Startup"
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "tnodes": {
    "felix.20250907225515.1": "@language typescript\n\n\n// Convert to an HTML structure like this one:\n/*\n    <!-- \n    'li' elements represent nodes. They each have a caret, text span and a single 'ul' for children.\n    data-id distinguishes node positions, the data-gnx identifies body content.\n    1 body can be used in multiple positions (nodes) that's why data-id and data-gnx differ.\n    (TODO: data-id MAY be omitted if not needed.)\n    data-expanded controls whether children are shown or hidden.\n    Clicking the caret expands/collapses and selects the node. Clickng the text selects only.\n    -->\n    <div id=\"outline-pane\" tabindex=\"0\">\n        <ul>\n            <li data-id=\"1\" data-gnx=\"1\" data-expanded=\"false\">\n                <span class=\"caret\"></span><span class=\"node-text\">Section 1</span>\n                <ul>\n                    <li data-id=\"2\" data-gnx=\"2\" data-expanded=\"false\">\n                        <span class=\"caret\"></span><span class=\"node-text\">Page A</span>\n                        <ul>\n                            <li data-id=\"3\" data-gnx=\"3\" data-expanded=\"false\">\n                                <span class=\"caret\"></span><span class=\"node-text\">Subpage A.1</span>\n                                <ul></ul>\n                            </li>\n                            <li data-id=\"4\" data-gnx=\"4\" data-expanded=\"false\">\n                                <span class=\"caret\"></span><span class=\"node-text\">Subpage A.2</span>\n                                <ul></ul>\n                            </li>\n                        </ul>\n                    </li>\n                    <li data-id=\"5\" data-gnx=\"5\" data-expanded=\"false\">\n                        <span class=\"caret\"></span><span class=\"node-text\">Page B</span>\n                        <ul></ul>\n                    </li>\n                </ul>\n            </li>\n            <li data-id=\"6\" data-gnx=\"6\" data-expanded=\"false\">\n                <span class=\"caret\"></span><span class=\"node-text\">Section 2</span>\n                <ul>\n                    <li data-id=\"7\" data-gnx=\"7\" data-expanded=\"false\">\n                        <span class=\"caret\"></span><span class=\"node-text\">Page C (Repeated)</span>\n                        <ul></ul>\n                    </li>\n                    <li data-id=\"8\" data-gnx=\"8\" data-expanded=\"false\">\n                        <span class=\"caret\"></span><span class=\"node-text\">Page D</span>\n                        <ul></ul>\n                    </li>\n                    <li data-id=\"9\" data-gnx=\"7\" data-expanded=\"false\">\n                        <span class=\"caret\"></span><span class=\"node-text\">Page C (Repeated)</span>\n                        <ul></ul>\n                    </li>\n                </ul>\n            </li>\n        </ul>\n    </div>\n\n\n*/\n\nlet currentLevel = -1; // Start \"before\" the root level.\n// Start the output with the opening <div> and <ul>\nlet output = `<div id=\"outline-pane\" tabindex=\"0\">\n    <ul>`;\nconst indentation = '        ';\nlet nodeTotal = 0; // To generate unique data-id values.\n\n// Recursive function to generate the HTML structure\nconst doChildren = (children) => {\n    \n    nodeTotal += 1;\n\n    for(const child of children){\n\n        output += `\\n${indentation.repeat(child.level()+1)}<li data-id=\"${nodeTotal}\" data-gnx=\"${child.gnx}\" data-expanded=\"false\">\n${indentation.repeat(child.level()+1)}    <span class=\"caret\"></span><span class=\"node-text\">${child.h}</span>\n${indentation.repeat(child.level()+1)}    <ul>`;\n        doChildren(child.children());    \n        output += `\\n${indentation.repeat(child.level()+1)}    </ul>\n${indentation.repeat(child.level()+1)}</li>`;\n\n    }\n        \n   \n};\n\ndoChildren(c.all_Root_Children());\n\n// ******************************************* \n// ** Iterative version, kept for reference **\n// *******************************************\n\n// // c is already defined as the current commander.\n// for( const p of c.all_positions()){\n//     nodeTotal += 1;\n//     // g.es(`Processing node number:${nodeTotal} ${p.h} at level ${p.level()}`);\n//     if(p.level() > currentLevel){\n//         // We are going deeper in the tree, the first child of the previous node.\n//         // Increase current level\n//         currentLevel = p.level();\n//         // Open a new <li>\n//         output += `\\n${indentation.repeat(currentLevel+1)}<li data-id=\"${nodeTotal}\" data-gnx=\"${p.gnx}\" data-expanded=\"false\">\n// ${indentation.repeat(currentLevel+1)}    <span class=\"caret\"></span><span class=\"node-text\">${p.h}</span>\n// ${indentation.repeat(currentLevel+1)}    <ul>`;\n//         // Leaving current level as is, we are now inside the new <ul>, ready for any children.\n//     }else if(p.level() < currentLevel){\n//         // Close one or more <ul> and <li>\n//         while(currentLevel > p.level()){\n//             output += `\\n${indentation.repeat(currentLevel+1)}</ul>\n// ${indentation.repeat(currentLevel+1)}</li>`;\n//             currentLevel -= 1;\n//         }\n//         // Now at the correct level, close previous <li> and open a new one\n//         output += `\\n${indentation.repeat(currentLevel+1)}</ul>\n// ${indentation.repeat(currentLevel+1)}</li>`;\n//         output += `\\n${indentation.repeat(currentLevel+1)}<li data-id=\"${nodeTotal}\" data-gnx=\"${p.gnx}\" data-expanded=\"false\">\n// ${indentation.repeat(currentLevel+1)}    <span class=\"caret\"></span><span class=\"node-text\">${p.h}</span>\n// ${indentation.repeat(currentLevel+1)}    <ul>`;\n//         // Leaving current level as is, we are now inside the new <ul>, ready for any children.\n//     }else{\n//         // Same level, close previous <li> and open a new one\n//         output += `\\n${indentation.repeat(currentLevel+1)}    </ul>\n// ${indentation.repeat(currentLevel+1)}</li>`;\n//         output += `\\n${indentation.repeat(currentLevel+1)}<li data-id=\"${nodeTotal}\" data-gnx=\"${p.gnx}\" data-expanded=\"false\">\n// ${indentation.repeat(currentLevel+1)}    <span class=\"caret\"></span><span class=\"node-text\">${p.h}</span>\n// ${indentation.repeat(currentLevel+1)}    <ul>`;\n//     }\n// }\n// // Set level to 0 and close remaining open tags\n// while(currentLevel > -1){\n//     output += `\\n${indentation.repeat(currentLevel+1)}    </ul>\n// ${indentation.repeat(currentLevel+1)}</li>`;\n//     currentLevel -= 1;\n// }\n\n// Close the opening <ul> and <div>\noutput += `\\n    </ul>\n</div>`;\n\ng.es( output);\n\noutput = \"\";\n// Now output the json dict of the bodies like so where the key is the gnx:\n/*\n        const bodies = {\n            \"1\": \"Section 1 content here\\nMultiple lines supported.\",\n            \"2\": \"Page A content here\\nMore text.\",\n            \"3\": \"Subpage A.1 content here\",\n            \"4\": \"Subpage A.2 content here\",\n            \"5\": \"Page B content here\",\n            \"6\": \"Section 2 content here\",\n            \"7\": \"Page C (Repeated) content here\\nSame (body content) GNX used twice, with different (position) IDs.\",\n            \"8\": \"Page D content here\"\n        };\n*/\n\noutput += `\\nconst bodies = {`;\nlet first = true;\nfor( const p of c.all_unique_positions()){\n    if(first){\n        first = false;\n    }else{\n        output += `,`;\n    }\n    // Escape backslashes and double quotes in body text\n    const bodyText = p.b ? JSON.stringify(p.b) : ''; // in python use json.dumps(p_b) üòÅ\n    output += `\\n    \"${p.gnx}\": ${bodyText}`; // Will already be quoted appropriately by JSON.stringify\n}\noutput += `\\n};`;\n// g.es('Done! Bodies output is:\\n' + output);",
    "felix.20250910212852.1": "@language python\n\noutput = ''\nindentation = '        '\nlevel = -1\n\n# Recursive function to generate the HTML structure\ndef doChildren(children):\n    global output, level\n    level += 1\n    for child in children:\n        indent = indentation * level\n        output += f\"\\n{indent}    <li>\"\n        output += f\"\\n{indent}        <b>{child.headString()}</b>\"\n        # output += f\"\\n{indent}        <pre>\\n{child.bodyString()}\\n{indent}        </pre>\"\n        output += f\"\\n{indent}        <ul>\"\n        doChildren(child.children)\n        output += f\"\\n{indent}        </ul>\"\n        output += f\"\\n{indent}    </li>\"\n\n# Start\noutput += \"<ul>\"\ndoChildren(c.hiddenRootNode.children)\noutput += \"\\n</ul>\"\ng.es(output)\n",
    "felix.20250908213416.1": "@language python\n\noutput = ''\nindentation = '        '\n\ndef AllRootChildren():\n    p = c.rootPosition()\n    while p:\n        yield p\n        p.moveToNext()\n\n# Recursive function to generate the HTML structure\ndef doChildren(children):\n    global output\n    for child in children:\n        indent = indentation * child.level()\n        output += f\"\\n{indent}    <li>\"\n        output += f\"\\n{indent}        <b>{child.h}</b>\"\n        output += f\"\\n{indent}        <pre>\\n{child.b}\\n{indent}        </pre>\"\n        output += f\"\\n{indent}        <ul>\"\n        doChildren(child.children())\n        output += f\"\\n{indent}        </ul>\"\n        output += f\"\\n{indent}    </li>\"\n\n# Start\noutput += \"<ul>\"\ndoChildren(AllRootChildren())\noutput += \"\\n</ul>\"\ng.es(output)\n",
    "felix.20250914133503.1": "@language python\nimport json\n\nvnode_dict = {}\ngnx_map = {}       # gnx -> compact id\ngnx_counter = 0    # counter for compact ids\n\ndef map_gnx(gnx):\n    \"\"\"Return the compact integer id for a gnx, creating it if missing.\"\"\"\n    global gnx_counter\n    if gnx not in gnx_map:\n        gnx_map[gnx] = gnx_counter\n        gnx_counter += 1\n    return gnx_map[gnx]\n\ndef buildTree(children):\n    \"\"\"Builds the outline structure recursively\"\"\"\n    result = []\n    for child in children:\n        is_clone = child.gnx in gnx_map\n        gnx_id = map_gnx(child.gnx)\n        node = {\n            \"gnx\": gnx_id,\n        }\n        if gnx_id not in vnode_dict:\n            vnode_dict[gnx_id] = {\n                \"headString\": child.headString(),\n                \"bodyString\":child.bodyString()\n            }\n        # recurse children only if gnx not already seen\n        # IMPORTANT: the script using this output will have to handle that!\n        if child.children and not is_clone:\n            node[\"children\"] = buildTree(child.children)\n        result.append(node)\n    return result\n\n# Start from Leo's hidden root\ntree = {\n    \"gnx\": map_gnx(c.hiddenRootNode.gnx),\n    \"children\": buildTree(c.hiddenRootNode.children)\n}\n\n# Pretty-print as JSON (Remove indent for compactness)\ng.es(\"const nodes = \" + json.dumps(tree, indent=2) + \";\\n\")\ng.es(\"const data = \" + json.dumps(vnode_dict, indent=2) + \";\\n\")\n",
    "felix.20250920001725.1": "@language python\nimport os\nimport json\nimport time\nimport webbrowser\nfrom tempfile import NamedTemporaryFile\n\nTEMPDIR = os.path.expanduser(r'~/.leo')\n\n@others\n\nunix_timestamp_string = str(int(time.time()))\nmyFilePath = c.fileName()\nfilename = os.path.splitext(os.path.basename(myFilePath))[0]\n\nvnode_dict = {}     # This is 'data'\ngnx_map = {}       # gnx -> compact id\ngnx_counter = 0    # counter for compact ids\n\ndef map_gnx(gnx):\n    \"\"\"Return the compact integer id for a gnx, creating it if missing.\"\"\"\n    global gnx_counter\n    if gnx not in gnx_map:\n        gnx_map[gnx] = gnx_counter\n        gnx_counter += 1\n    return gnx_map[gnx]\n\ndef buildTree(children):\n    \"\"\"Builds the outline structure recursively\"\"\"\n    result = []\n    for child in children:\n        is_clone = child.gnx in gnx_map\n        gnx_id = map_gnx(child.gnx)\n        node = {\n            \"gnx\": gnx_id,\n        }\n        if gnx_id not in vnode_dict:\n            vnode_dict[gnx_id] = {\n                \"headString\": child.headString(),\n                \"bodyString\":child.bodyString()\n            }\n        # recurse children only if gnx not already seen (dont re-write clones)\n        # IMPORTANT: the script using this output will have to handle that!\n        if child.children and not is_clone:\n            node[\"children\"] = buildTree(child.children)\n        result.append(node)\n    return result\n\n# Start from Leo's hidden root\ntree = {\n    \"gnx\": map_gnx(c.hiddenRootNode.gnx),\n    \"children\": buildTree(c.hiddenRootNode.children)\n}\n\nprefixTitle = f'\\n        const title = \"{filename}\";' \nprefixgenTimestamp = f'\\n        const genTimestamp = \"{unix_timestamp_string}\";'\nprefixTree = f'\\n        const tree = '\nprefixData = f';\\n        const data = '  # includes ';' for ending tree.\nsuffixData = ';\\n'\n\n# Define a simple wrapper that replaces </script> on-the-fly\nclass SafeWriter:\n    def __init__(self, f):\n        self.f = f\n    def write(self, s):\n        # Replace the dangerous substring\n        s = s.replace(\"</script>\", \"<\\\\/script>\")\n        self.f.write(s)\n\nwith NamedTemporaryFile(mode='w', encoding='utf-8', suffix='.html',\n                        prefix=filename, dir=TEMPDIR, delete=False) as out:\n\n    writer = SafeWriter(out)\n\n    writer.write(htmlPrefix)\n    \n    writer.write(prefixTitle)\n    writer.write(prefixgenTimestamp)\n    writer.write(prefixTree)\n\n    json.dump(tree, writer, ensure_ascii=False, separators=(\",\", \":\")) # to 'writer'\n    writer.write(prefixData)\n    json.dump(vnode_dict, writer, ensure_ascii=False, separators=(\",\", \":\")) # to 'writer'\n    writer.write(suffixData)\n\n    out.write(htmlSuffix)\n\nwebbrowser.open(out.name)\ng.es('HTML document generated at ' + out.name)",
    "felix.20250920001725.2": "htmlPrefix = r\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Leo Document Viewer</title>\n    <style>\n        :root {\n            /* light theme (default) */\n            --background-color: #ffffec;\n            --body-pane-color: #fff6f5;\n            --find-pane-color: #f9f9f9;\n            --resizer-color: #cae1ff;\n            --selected-bg: #cae1ff;\n            --ancestor-bg: #eef5ff;\n            --hover-bg: #dfecff;\n            --focus-outline: #0000ff;\n            --text-color: #000000;\n            --caret-dim-color: #888;\n            --find-text-color: #444;\n            --find-placeholder-color: #888;\n            --find-border-color: #a0a0a0;\n            --find-selection: #0078d7;\n            /* vertical layout (default) */\n            --main-direction: row;\n            --main-resizer-width: 5px;\n            --main-resizer-height: 100%;\n            --main-resizer-cursor: ew-resize;\n            --main-resizer-extension-width: 5px;\n            --main-resizer-extension-height: 100%;\n            --main-resizer-before-top: unset;\n            --main-resizer-before-left: -5px;\n            --main-resizer-after-right: -5px;\n            --main-resizer-after-bottom: unset;\n            --secondary-direction: column;\n            --secondary-height: 100%;\n            --secondary-resizer-width: 100%;\n            --secondary-resizer-height: 5px;\n            --secondary-resizer-cursor: ns-resize;\n            --secondary-resizer-extension-width: 100%;\n            --secondary-resizer-extension-height: 5px;\n            --secondary-resizer-before-top: -5px;\n            --secondary-resizer-before-left: unset;\n            --secondary-resizer-after-right: unset;\n            --secondary-resizer-after-bottom: -5px;\n            /* transitions */\n            --body-transition: unset;\n            --body-pane-transition: unset;\n            --find-pane-transition: unset;\n            /* configuration/find pane visibility */\n            --config-display: none;\n            --find-display: flex;\n        }\n\n        [data-show-config=\"true\"] {\n            --config-display: flex;\n            --find-display: none;\n        }\n\n        [data-transition=\"true\"] {\n            --body-transition: color 0.15s ease, background-color 0.15s ease;\n            --body-pane-transition: color 0.3s ease, background-color 0.3s ease;\n            --find-pane-transition: color 0.15s ease, background-color 0.15s ease;\n        }\n\n        [data-theme=\"dark\"] {\n            --background-color: #1e1e2e;\n            --body-pane-color: #2a2536;\n            --find-pane-color: #23202e;\n            --resizer-color: #454a6e;\n            --selected-bg: #454a6e;\n            --ancestor-bg: #2d3250;\n            --hover-bg: #3a3f5e;\n            --focus-outline: #7aa2f7;\n            --text-color: #cdd6f4;\n            --caret-dim-color: #999;\n            --find-text-color: #aeb6d1;\n            --find-placeholder-color: #5a699e;\n            --find-border-color: #81889e;\n            --find-selection: #3c54ce;\n        }\n\n        [data-layout=\"horizontal\"] {\n            --main-direction: column;\n            --main-resizer-width: 100%;\n            --main-resizer-height: 5px;\n            --main-resizer-cursor: ns-resize;\n            --main-resizer-extension-width: 100%;\n            --main-resizer-extension-height: 5px;\n            --main-resizer-before-top: -5px;\n            --main-resizer-before-left: unset;\n            --main-resizer-after-right: unset;\n            --main-resizer-after-bottom: -5px;\n            --secondary-direction: row;\n            --secondary-height: 100%;\n            --secondary-resizer-width: 5px;\n            --secondary-resizer-height: 100%;\n            --secondary-resizer-cursor: ew-resize;\n            --secondary-resizer-extension-width: 5px;\n            --secondary-resizer-extension-height: 100%;\n            --secondary-resizer-before-top: unset;\n            --secondary-resizer-before-left: -5px;\n            --secondary-resizer-after-right: -5px;\n            --secondary-resizer-after-bottom: unset;\n        }\n\n        /* Custom scrollbars */\n        * {\n            /* Firefox */\n            scrollbar-width: thin;\n            scrollbar-color: var(--resizer-color) transparent;\n        }\n\n        /* Chrome, Edge, Safari */\n        ::-webkit-scrollbar {\n            width: 5px;\n            height: 5px;\n        }\n\n        ::-webkit-scrollbar-track {\n            background: transparent;\n            border-radius: 5px;\n        }\n\n        ::-webkit-scrollbar-thumb {\n            background-color: var(--resizer-color);\n            border-radius: 5px;\n        }\n\n        ::-webkit-scrollbar-thumb:hover {\n            background-color: var(--hover-bg);\n        }\n\n        .icon0 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/></svg>');\n        }\n\n        .icon1 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n        }\n\n        .icon2 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/></svg>');\n        }\n\n        .icon3 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\">   <path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n        }\n\n        .icon4 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon5 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon6 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon7 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon8 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/></svg>');\n        }\n\n        .icon9 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n        }\n\n        .icon10 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/></svg>');\n        }\n\n        .icon11 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n        }\n\n        .icon12 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon13 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon14 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        .icon15 {\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n        }\n\n        body {\n            margin: 0;\n            display: flex;\n            flex-direction: var(--main-direction);\n            height: 100vh;\n            background-color: var(--background-color);\n            color: var(--text-color);\n            transition: var(--body-transition)\n        }\n\n        body.dragging-main {\n            cursor: var(--main-resizer-cursor) !important;\n        }\n\n        body.dragging-secondary {\n            cursor: var(--secondary-resizer-cursor) !important;\n        }\n\n        #outline-pane {\n            position: relative;\n            white-space: nowrap;\n            padding-top: 6px;\n            overflow-x: hidden;\n            overflow-y: auto;\n            font-family: sans-serif;\n        }\n\n        #spacer {\n            position: relative;\n        }\n\n        #collapse-all-btn {\n            position: absolute;\n            top: 3px;\n            right: 3px;\n            z-index: 100;\n            opacity: 0;\n            transition: opacity 0.2s ease;\n            pointer-events: none;\n        }\n\n        #outline-pane:hover #collapse-all-btn {\n            opacity: 1;\n            pointer-events: auto;\n        }\n\n        .outline-icon {\n            display: inline-flex;\n            align-items: center;\n            justify-content: center;\n            cursor: pointer;\n            width: 16px;\n            height: 16px;\n        }\n\n        .outline-icon:hover svg {\n            transform: scale(1.1);\n            transition: transform 0.1s ease;\n        }\n\n        #main-resizer {\n            position: relative;\n            width: var(--main-resizer-width);\n            height: var(--main-resizer-height);\n            cursor: var(--main-resizer-cursor);\n            background-color: var(--resizer-color);\n            flex-shrink: 0;\n        }\n\n        #main-resizer::before,\n        #main-resizer::after {\n            content: \"\";\n            position: absolute;\n            height: var(--main-resizer-extension-height);\n            width: var(--main-resizer-extension-width);\n            cursor: var(--main-resizer-cursor);\n        }\n\n        #main-resizer::before {\n            top: var(--main-resizer-before-top);\n            left: var(--main-resizer-before-left)\n        }\n\n        #main-resizer::after {\n            right: var(--main-resizer-after-right);\n            bottom: var(--main-resizer-after-bottom)\n        }\n\n        #outline-find-container {\n            display: flex;\n            flex-direction: var(--secondary-direction);\n            height: var(--secondary-height);\n            overflow: hidden;\n        }\n\n        #secondary-resizer {\n            position: relative;\n            height: var(--secondary-resizer-height);\n            width: var(--secondary-resizer-width);\n            cursor: var(--secondary-resizer-cursor);\n            background-color: var(--resizer-color);\n            flex-shrink: 0;\n        }\n\n        #secondary-resizer::before,\n        #secondary-resizer::after {\n            content: \"\";\n            position: absolute;\n            width: var(--secondary-resizer-extension-width);\n            height: var(--secondary-resizer-extension-height);\n            cursor: var(--secondary-resizer-cursor);\n        }\n\n        #secondary-resizer::before {\n            top: var(--secondary-resizer-before-top);\n            left: var(--secondary-resizer-before-left);\n        }\n\n        #secondary-resizer::after {\n            bottom: var(--secondary-resizer-after-bottom);\n            right: var(--secondary-resizer-after-right);\n        }\n\n        #outline-pane,\n        #find-pane {\n            overflow-y: auto;\n            flex: 1 1 0;\n        }\n\n        #body-pane {\n            flex: 1;\n            padding: 1rem 0 0 1rem;\n            background-color: var(--body-pane-color);\n            overflow-y: auto;\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\n            white-space: pre-wrap;\n            transition: var(--body-pane-transition);\n        }\n\n        #outline-pane:focus,\n        #body-pane:focus,\n        #outline-pane:focus-visible,\n        #body-pane:focus-visible {\n            /* \n              Note: Outline will appear under the items positioned absolutely.\n              See pseudo-elements with \"z-index: -1\" that appear below this outline.\n             */\n            outline: 3px solid var(--focus-outline);\n            outline-offset: -3px;\n        }\n\n        .node-text:hover::before,\n        .selected>.node-text::before,\n        .ancestor>.node-text::before,\n        .initial-find>.node-text::before {\n            content: \"\";\n            position: absolute;\n            top: 0;\n            left: -2px;\n            right: 0;\n            bottom: 0;\n            z-index: -1;\n            border-radius: 4px;\n        }\n\n        .selected>.node-text::before,\n        .selected>.node-text:hover::before {\n            background-color: var(--selected-bg);\n        }\n\n        .ancestor>.node-text::before {\n            background-color: var(--ancestor-bg);\n        }\n\n        .node-text:hover::before {\n            background-color: var(--hover-bg);\n        }\n\n        .initial-find>.node-text::before {\n            border: 1.5px solid var(--find-selection);\n            border-style: dotted;\n        }\n\n        .node {\n            position: absolute;\n            white-space: nowrap;\n            cursor: pointer;\n            display: grid;\n            grid-template-columns: 1em 1fr;\n            align-items: start;\n        }\n\n        body.dragging-main .node {\n            cursor: var(--main-resizer-cursor);\n        }\n\n        body.dragging-secondary .node {\n            cursor: var(--secondary-resizer-cursor);\n        }\n\n        .caret {\n            grid-column: 1;\n            display: inline-block;\n            width: 32px;\n            height: 26px;\n            position: relative;\n            left: -16px;\n            user-select: none;\n        }\n\n        .node-text {\n            position: relative;\n            background-repeat: no-repeat;\n            background-position-x: 2px;\n            background-position-y: 1px;\n            background-size: 19px 19px;\n            grid-column: 2;\n            display: block;\n            padding: 2px 0 2px 26px;\n            margin-right: 1.2rem;\n            border-radius: 4px;\n        }\n\n        /* Special handling for node icons */\n        [data-show-icons=\"false\"] .node-text {\n            background-image: none !important;\n            padding-left: 4px !important;\n            /* Reduce padding when icons are hidden */\n        }\n\n        .caret::after {\n            display: inline-block;\n            position: relative;\n            left: 16px;\n            transform-origin: 50% 50%;\n            transition: transform 160ms cubic-bezier(.2, .9, .3, 1), color 120ms;\n        }\n\n        .caret[data-expanded=\"true\"]::after {\n            content: \"‚ùØ\";\n            transform: rotate(90deg);\n        }\n\n        .caret[data-expanded=\"false\"]::after {\n            content: \"‚ùØ\";\n            transform: rotate(0deg);\n            color: var(--caret-dim-color);\n        }\n\n        .caret.toggled[data-expanded=\"true\"]::after {\n            content: \"‚ùØ\";\n            transform: rotate(90deg);\n            animation: rotateOpen 120ms ease-out;\n        }\n\n        .caret.toggled[data-expanded=\"false\"]::after {\n            content: \"‚ùØ\";\n            transform: rotate(0deg);\n            color: var(--caret-dim-color);\n            animation: rotateClose 120ms ease-out;\n        }\n\n        @keyframes rotateOpen {\n            from {\n                transform: rotate(0deg);\n                color: var(--caret-dim-color);\n            }\n\n            to {\n                transform: rotate(90deg);\n                color: inherit;\n            }\n        }\n\n        @keyframes rotateClose {\n            from {\n                transform: rotate(90deg);\n                color: inherit;\n            }\n\n            to {\n                transform: rotate(0deg);\n                color: var(--caret-dim-color);\n            }\n        }\n\n        /* buttons */\n        #button-container {\n            position: fixed;\n            top: 12px;\n            right: 12px;\n            display: flex;\n            flex-direction: row-reverse;\n            gap: 8px;\n            z-index: 1000;\n        }\n\n        .action-button {\n            width: 32px;\n            height: 32px;\n            border-radius: 50%;\n            background: var(--resizer-color);\n            color: var(--text-color);\n            border: 2px solid var(--text-color);\n            cursor: pointer;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-size: 18px;\n            line-height: 1;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n            z-index: 1000;\n            overflow: hidden;\n            transition: transform 0.2s ease;\n            user-select: none;\n        }\n\n        .action-button:hover {\n            transform: scale(1.1);\n        }\n\n        .action-button:disabled {\n            opacity: 0.4;\n            cursor: default;\n            box-shadow: none;\n            border-color: var(--caret-dim-color);\n        }\n\n        .action-button:disabled:hover {\n            transform: none;\n        }\n\n        .svg-icon {\n            position: relative;\n            top: 0;\n            left: 0;\n            transition: top 0.3s ease, left 0.3s ease, transform 0.3s ease;\n        }\n\n        #dehoist-btn:active #dehoist-icon {\n            top: -10px;\n        }\n\n        #hoist-btn:active #hoist-icon {\n            top: 10px;\n        }\n\n        #prev-btn:active #prev-icon {\n            left: -10px;\n        }\n\n        #next-btn:active #next-icon {\n            left: 10px;\n        }\n\n        #toggle-icon {\n            position: relative;\n            top: 0;\n            transition: top 0.3s ease;\n        }\n\n        #theme-toggle:active #toggle-icon {\n            top: 25px;\n        }\n\n        #layout-icon {\n            position: relative;\n            top: 0;\n        }\n\n        [data-layout=\"horizontal\"] #layout-icon {\n            transform: rotate(90deg);\n        }\n\n        [data-transition=\"true\"] #layout-icon {\n            transition: transform 0.3s ease;\n        }\n\n        .svg-icon svg {\n            display: block;\n            width: 20px;\n            height: 20px;\n        }\n\n        .action-button:disabled:active #toggle-icon,\n        .action-button:disabled:active #dehoist-icon,\n        .action-button:disabled:active #hoist-icon {\n            top: 0 !important;\n        }\n\n        .action-button:disabled:active #prev-icon,\n        .action-button:disabled:active #next-icon {\n            left: 0 !important;\n        }\n\n        #toggle-mark-btn:active #toggle-mark-icon {\n            transform: scale(0.7);\n        }\n\n        #prev-marked-btn:active #prev-marked-icon {\n            left: -10px;\n        }\n\n        #next-marked-btn:active #next-marked-icon {\n            left: 10px;\n        }\n\n        .hidden-button {\n            display: none !important;\n        }\n\n        /* find pane */\n        #find-pane {\n            scrollbar-gutter: stable;\n            font-family: sans-serif;\n            padding: 0.5rem 0 0 0.5rem;\n            overflow-x: hidden;\n            background-color: var(--find-pane-color);\n            position: relative;\n            transition: var(--find-pane-transition);\n            container-type: inline-size;\n            container-name: find-pane;\n        }\n\n        #find-controls,\n        #config-controls {\n            gap: 0.5rem;\n            align-items: flex-start;\n            flex-wrap: wrap;\n        }\n\n        @container find-pane (min-width: 450px) {\n            #config-controls {\n                justify-content: center;\n            }\n        }\n\n        #config-btn {\n            position: fixed;\n            z-index: 2001;\n            cursor: pointer;\n            font-size: 20px;\n            opacity: 0.6;\n            transition: transform 0.2s ease, opacity 0.2s ease;\n            text-shadow: 0 3px 3px rgba(0, 0, 0, 0.4);\n            user-select: none;\n        }\n\n        #config-btn:hover {\n            transform: scale(1.2);\n            opacity: 1;\n        }\n\n        #find-controls {\n            padding-top: 0.5rem;\n            display: var(--find-display);\n        }\n\n        #config-controls {\n            padding-top: 0;\n            display: var(--config-display);\n        }\n\n        .config-title {\n            cursor: default;\n            user-select: none;\n            width: 100%;\n            text-align: center;\n            font-weight: bold;\n            margin: 0;\n            font-size: 1em;\n            color: var(--find-text-color);\n        }\n\n        .config-title svg {\n            vertical-align: middle;\n        }\n\n        .sub-title {\n            width: 100%;\n            text-align: center;\n            margin: 0;\n            color: var(--caret-dim-color);\n            font-style: italic;\n            font-size: 0.9em;\n            cursor: default;\n            user-select: none;\n        }\n\n        #find-pane .config-col.shortcuts {\n            list-style: none;\n            padding: 0;\n            margin: -5px 0 0 0;\n            font-size: 0.8em;\n            color: var(--find-text-color);\n            gap: 0;\n            min-width: 285px;\n            cursor: default;\n            user-select: none;\n        }\n\n        #find-pane .config-col.shortcuts li {\n            padding: 0.25rem 0.5rem;\n            display: flex;\n            align-items: center;\n        }\n\n        #find-pane .config-col.shortcuts kbd {\n            display: inline-block;\n            padding: 0.1rem 0.4rem;\n            margin: 0 0.2rem;\n            font-family: monospace;\n            font-size: 0.9em;\n            line-height: 1.4;\n            color: var(--text-color);\n            background-color: var(--resizer-color);\n            border: 1px solid var(--find-border-color);\n            border-radius: 3px;\n            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);\n        }\n\n        .kbd-spacer {\n            display: inline-block;\n            width: 100px;\n        }\n\n        #find-pane .find-col,\n        #find-pane .config-col {\n            display: flex;\n            flex-direction: column;\n            gap: 0.35rem;\n            min-width: 110px;\n        }\n\n        #find-pane .find-col label,\n        #find-pane .config-col label {\n            display: inline-flex;\n            align-items: center;\n            gap: 0.5rem;\n            cursor: pointer;\n            user-select: none;\n            font-size: 0.8em;\n            color: var(--find-text-color);\n        }\n\n        .config-col label {\n            padding-left: 0.5rem;\n        }\n\n        #find-pane input[type=\"checkbox\"],\n        #find-pane input[type=\"radio\"] {\n            flex-shrink: 0;\n            width: 16px;\n            height: 16px;\n            margin: 0;\n        }\n\n        #find-input {\n            width: 100%;\n            /* max-width: 260px; */\n            box-sizing: border-box;\n            padding: 0.4rem 0.5rem;\n            margin: 0;\n            border-radius: 3px;\n            border: 1px solid var(--find-border-color);\n            background: transparent;\n            color: var(--find-text-color);\n            font-family: sans-serif;\n            display: var(--find-display)\n        }\n\n        #find-input::placeholder {\n            color: var(--find-placeholder-color);\n        }\n\n        input[type=\"checkbox\"] {\n            appearance: none;\n            width: 20px;\n            height: 20px;\n            border: 1px solid var(--find-border-color);\n            border-radius: 3px;\n            background-color: var(--find-pane-color);\n            position: relative;\n        }\n\n        input[type=\"checkbox\"]:checked::after {\n            content: \"\";\n            position: absolute;\n            left: 4px;\n            top: -2px;\n            width: 4px;\n            height: 12px;\n            border: solid var(--find-border-color);\n            border-width: 0 2px 2px 0;\n            transform: rotate(45deg);\n        }\n\n        input[type=\"radio\"] {\n            appearance: none;\n            width: 20px;\n            height: 20px;\n            border: 1px solid var(--find-border-color);\n            border-radius: 50%;\n            background-color: var(--find-pane-color);\n            position: relative;\n        }\n\n        input[type=\"radio\"]:checked::after {\n            content: \"\";\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            width: 8px;\n            height: 8px;\n            transform: translate(-50%, -50%);\n            background-color: var(--find-text-color);\n            border-radius: 50%;\n        }\n\n        input[type=\"radio\"]:focus:checked::after,\n        input[type=\"radio\"]:focus-visible:checked::after {\n            background-color: var(--find-selection);\n        }\n\n        input[type=\"checkbox\"]:focus:checked::after,\n        input[type=\"checkbox\"]:focus-visible:checked::after {\n            border: solid var(--find-selection);\n            border-width: 0 2px 2px 0;\n        }\n\n        #find-pane input:focus,\n        #find-pane input:focus-visible {\n            border-color: var(--find-selection);\n            outline: 2px solid var(--find-selection);\n            outline-offset: -1px;\n        }\n\n        a {\n            color: var(--caret-dim-color);\n            text-decoration: underline;\n        }\n\n        a:hover {\n            color: var(--find-text-color);\n        }\n\n        .footer {\n            margin-bottom: 1rem;\n        }\n\n        /* toast */\n        #toast {\n            position: fixed;\n            top: 16px;\n            left: 50%;\n            transform: translateX(-50%) translateY(-10px);\n            background: var(--body-pane-color);\n            color: var(--find-text-color);\n            padding: 8px 12px;\n            border-radius: 6px;\n            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);\n            opacity: 0;\n            pointer-events: none;\n            transition: opacity 180ms ease, transform 180ms ease;\n            z-index: 2000;\n            font-family: sans-serif;\n            font-size: 13px;\n            white-space: pre;\n        }\n\n        #toast.show {\n            opacity: 1;\n            transform: translateX(-50%) translateY(0);\n            pointer-events: auto;\n        }\n    </style>\n</head>\n\n<body>\n    <!--\n      * Layout *\n      The body element is split in two (outline-find-container and body-pane) by the main-resizer.\n      The outline-find-container is split in two (outline-pane and find-pane) by the secondary-resizer.\n      So in total, there are three panes and two resizers. The rest are just floating buttons which are not part of the layout.\n    -->\n    <div id=\"outline-find-container\">\n        <div id=\"outline-pane\" tabindex=\"0\">\n            <div id=\"spacer\"></div>\n            <div id=\"collapse-all-btn\" class=\"outline-icon\" title=\"Collapse All\" role=\"button\"\n                aria-label=\"Collapse All\">\n                <svg width=\"16\" height=\"16\" fill=\"currentColor\">\n                    <path\n                        d=\"M 6 2 L 5 3 L 5 5 L 3 5 L 2 6 L 2 13 L 3 14 L 10 14 L 11 13 L 11 11 L 13 11 L 14 10 L 14 3 L 13 2 L 6 2 z M 6 3 L 13 3 L 13 10 L 11 10 L 11 6 L 10 5 L 6 5 L 6 3 z M 3 6 L 10 6 L 10 13 L 3 13 L 3 6 z M 4 9 L 4 10 L 9 10 L 9 9 L 4 9 z \"\n                        style=\"fill:var(--find-border-color);\" />\n                </svg>\n            </div>\n        </div>\n        <div id=\"secondary-resizer\"></div>\n        <div id=\"find-pane\">\n            <input id=\"find-input\" type=\"text\" autocomplete=\"off\" placeholder=\"&lt;find pattern here&gt;\"\n                title=\"Ctrl+F: Search | F3/F2: Next/Prev\" aria-label=\"Find pattern\">\n            <div id=\"find-controls\" role=\"region\" aria-label=\"Find options\">\n                <div class=\"find-col\" aria-label=\"Search options\">\n                    <label for=\"opt-whole\">\n                        <input id=\"opt-whole\" type=\"checkbox\" name=\"find-option\" />\n                        Whole Word\n                    </label>\n                    <label for=\"opt-ignorecase\">\n                        <input id=\"opt-ignorecase\" type=\"checkbox\" name=\"find-option\" checked />\n                        Ignore Case\n                    </label>\n                    <label for=\"opt-regexp\">\n                        <input id=\"opt-regexp\" type=\"checkbox\" name=\"find-option\" />\n                        Regexp\n                    </label>\n                    <label for=\"opt-mark\">\n                        <input id=\"opt-mark\" type=\"checkbox\" name=\"find-option\" />\n                        Mark Finds\n                    </label>\n                </div>\n                <div class=\"find-col\" role=\"radiogroup\" aria-label=\"Search scope\">\n                    <label for=\"scope-entire\">\n                        <input id=\"scope-entire\" type=\"radio\" name=\"find-scope\" value=\"entire\" checked />\n                        Entire Outline\n                    </label>\n                    <label for=\"scope-suboutline\">\n                        <input id=\"scope-suboutline\" type=\"radio\" name=\"find-scope\" value=\"suboutline\" />\n                        Suboutline Only\n                    </label>\n                    <label for=\"scope-node\">\n                        <input id=\"scope-node\" type=\"radio\" name=\"find-scope\" value=\"node\" />\n                        Node Only\n                    </label>\n                    <label for=\"opt-headline\">\n                        <input id=\"opt-headline\" type=\"checkbox\" name=\"find-target\" checked />\n                        Search Headline\n                    </label>\n                    <label for=\"opt-body\">\n                        <input id=\"opt-body\" type=\"checkbox\" name=\"find-target\" checked />\n                        Search Body\n                    </label>\n                </div>\n            </div>\n            <span id=\"config-btn\" aria-label=\"Configuration\" title=\"Configuration\">‚öôÔ∏è</span>\n            <div id=\"config-controls\" role=\"region\" aria-label=\"Configuration settings\">\n                <span class=\"config-title\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" height=\"32\" width=\"32\" viewBox=\"0 0 16 16\">\n                        <path d=\"M2.875 1.21h10.566v8.482H2.875z\" fill=\"#7c2504\" />\n                        <path\n                            d=\"M11.093 1.21c-1.14.782-1.827 2.105-1.828 3.523 0 1.747 1.023 3.246 2.482 3.89v6.021h1.694V1.21zm-8.218 0V14.88h1.713V9.009a4.073 4.225 0 003.167-4.115A4.073 4.225 0 005.673 1.21z\"\n                            fill=\"#b04620\" />\n                        <path\n                            d=\"M6.35 6.339c.12.188.21.425.174.645-.245.565-.76 1.076-1.191 1.44-.73.668-1.442.894-2.433.993V4.002C4 4.79 5.58 5.269 6.35 6.339z\"\n                            fill=\"#c96b4b\" />\n                        <path\n                            d=\"M4.332 8.389c-.158 0-.79.316-.79.316l-.65.561h-.07l-.034 3.3.333.28.562-.105c.37-.073.72-.394 1.106-.368 0 0-.368.375-.457.614-.177.595-.124 1.405.334 1.79.25.201.612.202.93.246 1.464-.037 4.222.01 5.74.035.626-.22.74-.879.841-1.422.07-.409.049-.903-.193-1.21-.215-.265-.877-.527-.877-.527s1.117.332 1.68.482c.2.054.601.15.601.15l.123-3.844-1.035-.298-1.176.07c-1.934.446-3.108.225-4.914.245l-1.053-.28s-.843-.035-1-.035z\"\n                            fill=\"#e4dcc8\" />\n                        <path\n                            d=\"M4.708 2.514c-.947.022-1.475.03-1.808 1.194-.061.43.13.923.439 1.228.415.386 1.612.462 2.264.738.249.037.546.14.755 0 .277-.202.345-.987.473-1.37.003-.511-.243-1.192-.649-1.597-.477-.294-.98-.212-1.474-.193zm7.065.1c-.2.002-.405.024-.613.036-.518-.066-.748.086-.983.526-.343.738-.604 2.514.21 2.878.915.34 1.406-.481 2.001-.824.271-.149.585-.198.878-.299.049-1.108.161-1.483-.51-2.018-.322-.249-.648-.301-.983-.298z\"\n                            fill=\"#f9f2b3\" />\n                        <path\n                            d=\"M2.49.713V10l-1.516.143a.334.334 0 10.063.666l1.453-.138v.59l-1.483.288a.334.334 0 10.127.656l1.356-.263v3.349H13.88v-4.025h1.032a.334.334 0 100-.67h-1.032v-.64l1.054-.108a.334.334 0 10-.067-.665l-.987.101V.713H2.49zm.905.905h9.579v2.411a1.607 1.607 0 00-.088-.224c-.315-.63-.738-.878-1.277-.857-.636.001-1.105.415-1.342 1.009-.152.398-.113.704-.09 1.082.016.24.4.593.692.537.453-.088 1.18-.482 1.757-.765.18-.088.289-.19.348-.303v4.869l-2.427.246a.334.334 0 10.067.665l2.36-.24v.549h-2.405a.334.334 0 100 .669h2.405v3.12H3.395v-.677c.117.087.348.15.436.11.33-.153.357-.46.749-.83.182-.171.323-.42.599-.562.246-.126.727-.052 1.452-.207 1.346-.232 2.858-.122 3.97.085.707.134.891.457 1.033.776.11.248.07.353.247.558.137.16.505.353.716.169.168-.147 0-.502.182-.682.204-.204.28-.442.007-.745-.902-.485-1.542-.586-2.66-.737-.199-.02-.316-.245-.461-.38-.345-.32-.675-.483-1.103-.532.016-.055.037-.204.068-.244.695-.897 1.659-1.467 2.392-1.634.273-.062.157-.392.093-.431-.145-.088-.331-.093-.5-.093-.319.001-.633.08-.95.098-.952.054-1.783.082-2.651.006-.287-.025-.576-.058-.864-.046-.463.02-.554.254-.43.598.045.128.579.135.84.272.423.22.632.51 1.103 1.097.058.071.126.137.167.218.023.046.023.1.03.15-.514.002-.712.127-1.025.46-.363.38-.283.403-1.243.553-.22.034-.458.033-.678.069-.413.067-1.056.097-1.375.472-.062.073-.1.14-.143.208v-.719l2.476-.48a.334.334 0 10-.128-.657l-2.348.456v-.5l2.445-.231a.334.334 0 10-.063-.666l-2.382.225v-5.62c.2.094.516.16.657.221.442.194.737.484 1.025.634.18.094.866.282 1.016.147.222-.2.262-1.117.074-1.538a2.12 2.12 0 00-.651-.854c-.09-.072-.43-.153-.68-.148-.25.004-.556.053-.711.091-.315.079-.473.259-.683.505-.012.012-.031.05-.047.076z\"\n                            fill=\"#1c0e01\" />\n                        <path\n                            d=\"M4.487 3.186c-.11.182-.05.382.062.533.094.125.222.226.36.298.222.11.36.162.484-.062.151-.264.091-.52-.112-.72-.23-.204-.581-.277-.794-.05zm7 .26c-.326.03-.478.33-.472.633a.91.91 0 00.162.385c.247-.037.604-.197.769-.36.093-.133.21-.369.149-.509-.152-.191-.403-.18-.608-.149z\"\n                            fill=\"#fff\" />\n                    </svg>\n                    Leo Outline Viewer </span>\n                <span class=\"sub-title\">Visible Controls</span>\n                <div class=\"config-col\" aria-label=\"Config options\">\n                    <label for=\"show-prev-next-mark\">\n                        <input id=\"show-prev-next-mark\" type=\"checkbox\" name=\"config-option\" />\n                        Previous/Next Marked\n                    </label>\n                    <label for=\"show-toggle-mark\">\n                        <input id=\"show-toggle-mark\" type=\"checkbox\" name=\"config-option\" />\n                        Mark/Unmark\n                    </label>\n                    <label for=\"show-prev-next-history\">\n                        <input id=\"show-prev-next-history\" type=\"checkbox\" name=\"config-option\" checked />\n                        Previous/Next History\n                    </label>\n                    <label for=\"show-hoist-dehoist\">\n                        <input id=\"show-hoist-dehoist\" type=\"checkbox\" name=\"config-option\" />\n                        Hoist/De-hoist\n                    </label>\n                </div>\n                <div class=\"config-col\" aria-label=\"Config options\">\n                    <label for=\"show-layout-orientation\">\n                        <input id=\"show-layout-orientation\" type=\"checkbox\" name=\"config-option\" checked />\n                        Layout Orientation\n                    </label>\n                    <label for=\"show-theme-toggle\">\n                        <input id=\"show-theme-toggle\" type=\"checkbox\" name=\"config-option\" checked />\n                        Dark/Light Theme\n                    </label>\n                    <label for=\"show-node-icons\">\n                        <input id=\"show-node-icons\" type=\"checkbox\" name=\"config-option\" checked />\n                        Node Icons\n                    </label>\n                    <label for=\"show-collapse-all\">\n                        <input id=\"show-collapse-all\" type=\"checkbox\" name=\"config-option\" checked />\n                        Collapse All\n                    </label>\n                    <!-- Future possible options: -->\n                    <!-- <label for=\"show-chapters\">\n                        <input id=\"show-chapters\" type=\"checkbox\" name=\"config-option\" />\n                        Chapters\n                    </label> -->\n                </div>\n                <span class=\"sub-title\">Keyboard Shortcuts</span>\n                <ul class=\"config-col shortcuts\">\n                    <li><span class=\"kbd-spacer\"><kbd>Arrows</kbd></span> ‚Äî Navigate Outline</li>\n                    <li><span class=\"kbd-spacer\"><kbd>Alt</kbd>+<kbd>Arrows</kbd></span> ‚Äî Navigate from Body Pane</li>\n                    <li><span class=\"kbd-spacer\"><kbd>Ctrl</kbd>+<kbd>F</kbd></span> ‚Äî Find‚Ä¶</li>\n                    <li><span class=\"kbd-spacer\"><kbd>F2</kbd>/<kbd>F3</kbd></span> ‚Äî Previous/Next Match</li>\n                    <li><span class=\"kbd-spacer\"><kbd>Ctrl</kbd>+<kbd>M</kbd></span> ‚Äî Mark Node</li>\n                    <li><span class=\"kbd-spacer\"><kbd>Alt</kbd>+<kbd>-</kbd></span> ‚Äî Collapse All</li>\n                </ul>\n                <span class=\"sub-title footer\">\n                    <a href=\"https://leo-editor.github.io/leo-editor/\" target=\"_blank\">Leo Editor</a>\n                    <span>Outline Viewer - 1.0.0 - Made by</span>\n                    <a href=\"https://github.com/boltex\" target=\"_blank\">F√©lix</a>\n                </span>\n            </div>\n        </div>\n    </div>\n    <div id=\"main-resizer\"></div>\n    <div id=\"body-pane\" tabindex=\"0\" contenteditable=\"plaintext-only\" spellcheck=\"false\"></div>\n    <div id=\"button-container\">\n        <button tabindex=\"-1\" id=\"theme-toggle\" class=\"action-button\" aria-label=\"Toggle dark/light mode\"><span\n                id=\"toggle-icon\">üåì</span></button>\n        <button tabindex=\"-1\" id=\"layout-toggle\" class=\"action-button\" aria-label=\"Toggle layout orientation\"><span\n                id=\"layout-icon\">üìê</span></button>\n        <button tabindex=\"-1\" id=\"dehoist-btn\" class=\"action-button\" aria-label=\"De-hoist\" title=\"De-hoist\" disabled>\n            <span class=\"svg-icon\" id=\"dehoist-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 17 17\">\n                    <path\n                        d=\"m 9.717,5.896 0.701,1.249 h 3.238 v 6.494 H 2.344 V 9.3649687 L 1.096,10.038969 V 14.896 h 13.808 v -9 z M 3.198,0.844 1.733,8.267 4.326,6.865 6.23,10.258 9.687,8.388 7.78,4.997 10.374,3.596 Z\"\n                        style=\"fill:var(--find-text-color);\" />\n                </svg>\n            </span>\n        </button>\n        <button tabindex=\"-1\" id=\"hoist-btn\" class=\"action-button\" aria-label=\"Hoist\" title=\"Hoist\">\n            <span class=\"svg-icon\" id=\"hoist-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 17 17\">\n                    <path\n                        d=\"M 7.907,10.33 3.089,4.496 h 2.947 l 0.062,-3.89 3.93,0.002 -0.065,3.89 2.948,-0.001 z M 1.096,5.896 v 9 h 13.808 v -9 h -0.596094 l -1.07,1.249 H 13.656 v 6.494 H 2.344 V 7.145 h 0.4117139 l -1.031,-1.249 z\"\n                        style=\"fill:var(--find-text-color);\" />\n                </svg>\n            </span>\n        </button>\n        <button tabindex=\"-1\" id=\"next-btn\" class=\"action-button\" aria-label=\"Goto Next\" title=\"Goto Next\" disabled>\n            <span class=\"svg-icon\" id=\"next-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                    <polygon points=\"14,10 6,3 6,17\" fill=\"#494\" />\n                </svg>\n            </span>\n        </button>\n        <button tabindex=\"-1\" id=\"prev-btn\" class=\"action-button\" aria-label=\"Goto Previous\" title=\"Goto Previous\"\n            disabled>\n            <span class=\"svg-icon\" id=\"prev-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                    <polygon points=\"6,10 14,3 14,17\" fill=\"#494\" />\n                </svg>\n            </span>\n        </button>\n        <button tabindex=\"-1\" id=\"next-marked-btn\" class=\"action-button\" aria-label=\"Go to Next Marked Node\"\n            title=\"Go to Next Marked Node\" disabled>\n            <span class=\"svg-icon\" id=\"next-marked-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                    <polygon points=\"14,10 6,3 6,17\" fill=\"#cb1919\" />\n                </svg>\n            </span>\n        </button>\n        <button tabindex=\"-1\" id=\"toggle-mark-btn\" class=\"action-button\" aria-label=\"Toggle Mark\" title=\"Toggle Mark\">\n            <span class=\"svg-icon\" id=\"toggle-mark-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"1.5 1 13 13\">\n                    <path\n                        d=\"m 5.0855,2.17 c -0.532,0 -0.73,0.196 -0.73,0.728 v 10.933 l 3.645,-2.253 3.644,2.253 V 2.898 c 0,-0.532 -0.197,-0.729 -0.463,-0.7285 z m 3.906,4.088 0.525,1.574 -0.146,0.124 -1.37,-0.976 -1.37,0.976 -0.146,-0.124 0.525,-1.574 -1.356,-0.991 0.066,-0.168 1.676,-0.022 0.51,-1.574 h 0.182 l 0.51,1.574 1.677,0.022 0.08813,0.129125 z\"\n                        style=\"fill:#cb1919;\" />\n                </svg>\n            </span>\n        </button>\n        <button tabindex=\"-1\" id=\"prev-marked-btn\" class=\"action-button\" aria-label=\"Go to Previous Marked Node\"\n            title=\"Go to Previous Marked Node\" disabled>\n            <span class=\"svg-icon\" id=\"prev-marked-icon\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                    <polygon points=\"6,10 14,3 14,17\" fill=\"#cb1919\" />\n                </svg>\n            </span>\n        </button>\n    </div>\n    <div id=\"toast\" role=\"status\" aria-live=\"polite\" hidden></div>\n    <script>\n\"\"\"",
    "felix.20250920001725.3": "htmlSuffix = r\"\"\"\n        // Note: Also use buildClones and buildParentRefs\n        // to add icon member to data entries as needed:\n        // hasBody: 1, isMarked: 2, isClone: 4, isDirty: 8\n        let allNodesInOrder = []; // Store all nodes in natural tree order (initialized after tree is built)\n\n        // Build clones when repeated in the tree\n        function buildClones(node) {\n\n            const visitedNodes = {}; // Keys are gnx, values are node references\n\n            // Helper function for recursion that has access to the visitedNodes object\n            function buildClonesWithChildren(node) {\n                const gnx = node && node.gnx;\n                // Initialize data entry safely if it exists\n                if (gnx != null && data[gnx]) {\n                    if (!('icon' in data[gnx])) data[gnx].icon = 0;\n                }\n                if (gnx != null && Object.prototype.hasOwnProperty.call(visitedNodes, gnx)) {\n                    // If we've already seen this node, fill its children with JSON stringify/parse for deep copy.\n                    node.children = JSON.parse(JSON.stringify(visitedNodes[gnx].children || []));\n                    if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 4; // set clone bit\n                    // Do not recurse into children, they are already built\n                } else {\n                    if (gnx != null && data[gnx] && data[gnx].bodyString) {\n                        data[gnx].icon = (data[gnx].icon || 0) | 1; // set hasBody bit\n                    }\n                    visitedNodes[gnx] = node;\n                    if (node.children) {\n                        for (const child of node.children) {\n                            buildClonesWithChildren(child);\n                        }\n                    }\n                }\n            }\n            buildClonesWithChildren(node); // Start the recursive process\n        }\n\n        // Add parent references to all nodes recursively\n        function buildParentRefs(node, parent = null) {\n            node.parent = parent;\n            if (node.children) {\n                for (const child of node.children) {\n                    buildParentRefs(child, node); // recurse with current node as parent\n                }\n            }\n        }\n\n        // Helper function to get all nodes in tree order\n        function getAllNodesInTreeOrder(node) {\n            const result = [];\n            function traverse(n) {\n                if (n !== tree) { // Skip the hidden root node itself\n                    result.push(n);\n                }\n                if (n.children) {\n                    for (const child of n.children) {\n                        traverse(child);\n                    }\n                }\n            }\n            traverse(node);\n            return result;\n        }\n\n        buildClones(tree);\n        buildParentRefs(tree);\n        allNodesInOrder = getAllNodesInTreeOrder(tree); // Initialize the global array once\n\n\n        let flatRows = null; // Array of nodes currently visible in the outline pane, null at init time to not trigger render\n        const expanded = new Set(); // No need to add the root because 'isExpanded' will return true for it\n        const marked = new Set(); // Set of gnx (not nodes) that are marked\n        let selectedNode = null; // Track the currently selected node\n        let initialFindNode = null; // Node where to start the find (null means from the top)\n        let currentTheme = 'light'; // Default theme\n        let currentLayout = 'vertical'; // Default layout\n        let isDragging = false;\n        let mainRatio = 0.25; // Default proportion between outline-find-container and body-pane widths (defaults to 1/4)\n        let secondaryIsDragging = false;\n        let secondaryRatio = 0.75; // Default proportion between the outline-pane and the find-pane (defaults to 3/4)\n        const navigationHistory = [];\n        let currentHistoryIndex = -1; // -1 means no history yet\n        const hoistStack = []; // Track hoisted nodes\n\n        const minWidth = 20;\n        const minHeight = 20;\n\n        // Elements\n        let selectedLabelElement = null; // Track the currently selected label element in the outline pane\n        const ROW_HEIGHT = 26;\n        const LEFT_OFFSET = 16; // Padding from left edge\n        const OUTLINE_FIND_CONTAINER = document.getElementById(\"outline-find-container\");\n        const OUTLINE_PANE = document.getElementById(\"outline-pane\");\n        const COLLAPSE_ALL_BTN = document.getElementById(\"collapse-all-btn\");\n        const SPACER = document.getElementById(\"spacer\");\n        const BODY_PANE = document.getElementById(\"body-pane\");\n        const VERTICAL_RESIZER = document.getElementById('main-resizer');\n        const FIND_PANE = document.getElementById(\"find-pane\");\n        const HORIZONTAL_RESIZER = document.getElementById('secondary-resizer');\n        const THEME_TOGGLE = document.getElementById('theme-toggle');\n        const THEME_ICON = document.getElementById('toggle-icon');\n        const LAYOUT_TOGGLE = document.getElementById('layout-toggle');\n        const LAYOUT_ICON = document.getElementById('layout-icon');\n\n        const DEHOIST_BTN = document.getElementById('dehoist-btn');\n        const HOIST_BTN = document.getElementById('hoist-btn');\n        const NEXT_BTN = document.getElementById('next-btn');\n        const PREV_BTN = document.getElementById('prev-btn');\n\n        const NEXT_MARKED_BTN = document.getElementById('next-marked-btn');\n        const TOGGLE_MARK_BTN = document.getElementById('toggle-mark-btn');\n        const PREV_MARKED_BTN = document.getElementById('prev-marked-btn');\n\n        const FIND_INPUT = document.getElementById('find-input');\n        const OPT_HEADLINE = document.getElementById('opt-headline');\n        const OPT_BODY = document.getElementById('opt-body');\n        const OPT_WHOLE = document.getElementById('opt-whole');\n        const OPT_IGNORECASE = document.getElementById('opt-ignorecase');\n        const OPT_REGEXP = document.getElementById('opt-regexp');\n        const OPT_MARK = document.getElementById('opt-mark');\n\n        const CONFIG_BTN = document.getElementById('config-btn');\n\n        const SHOW_PREV_NEXT_MARK = document.getElementById('show-prev-next-mark');\n        const SHOW_TOGGLE_MARK = document.getElementById('show-toggle-mark');\n        const SHOW_PREV_NEXT_HISTORY = document.getElementById('show-prev-next-history');\n        const SHOW_HOIST_DEHOIST = document.getElementById('show-hoist-dehoist');\n        const SHOW_LAYOUT_ORIENTATION = document.getElementById('show-layout-orientation');\n        const SHOW_THEME_TOGGLE = document.getElementById('show-theme-toggle');\n        const SHOW_NODE_ICONS = document.getElementById('show-node-icons');\n        const SHOW_COLLAPSE_ALL = document.getElementById('show-collapse-all');\n\n        const TOAST = document.getElementById('toast');\n        const HTML_ELEMENT = document.documentElement;\n\n        // * Navigation helpers\n        function children(node) {\n            // Given a node, return a shallow copy of its children array or an empty array.\n            return node && node.children ? node.children.slice() : [];\n        }\n\n        function childIndex(node) {\n            // Given a node, return its index among its siblings (0 for first, 1 for second, etc).\n            const parent = node.parent;\n            if (parent) {\n                const siblings = children(parent);\n                return siblings.indexOf(node);\n            }\n            return 0; // Should not happen for valid nodes because the top nodes are in the #outline-pane div\n        };\n\n        function parents(node) {\n            // Given a node, return an array of its ancestor nodes, closest first.\n            const ancestors = [];\n            let current = node;\n            while (current) {\n                const parent = current.parent;\n                if (parent) {\n                    ancestors.push(parent);\n                }\n                current = parent;\n            }\n            return ancestors;\n        };\n\n        function isAncestorOf(possibleAncestor, descendant) {\n            // Return true if possibleAncestor is an ancestor of descendant.\n            let current = descendant.parent;\n            while (current) {\n                if (current === possibleAncestor) {\n                    return true;\n                }\n                current = current.parent;\n            }\n            return false;\n        }\n\n        function hasChildren(node) {\n            // Given a node, return true if it has children.\n            return node.children && node.children.length > 0;\n        }\n\n        function isExpanded(node) {\n            // Given a node, return true if it is expanded.\n            if (!node.parent) return true; // The root node is always considered expanded\n            return expanded.has(node);\n        }\n\n        function isDescendantOfHoistedNode(node) {\n            if (!node || hoistStack.length === 0) return false;\n\n            const hoistedNode = hoistStack[hoistStack.length - 1];\n            return hoistedNode === node || isAncestorOf(hoistedNode, node);\n        }\n\n        function isVisible(node) {\n            // Return True if node is visible in the outline.\n            if (!node.parent) return false; // Root node is not visible\n\n            // First check if the node is descendant of the hoisted node\n            if (hoistStack.length > 0 && !isDescendantOfHoistedNode(node)) {\n                return false;\n            }\n\n            // Then check if all ancestors are expanded\n            const ancestors = parents(node);\n            for (const ancestor of ancestors) {\n                if (!isExpanded(ancestor)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function hasBack(node) {\n            // Given a node, return true if it has a previous sibling.\n            const parent = node.parent;\n            if (parent) {\n                const siblings = children(parent);\n                const index = siblings.indexOf(node);\n                return index > 0;\n            }\n            return false;\n        }\n\n        function hasNext(node) {\n            // Given a node, return true if it has a next sibling.\n            const parent = node.parent;\n            if (parent) {\n                const siblings = children(parent);\n                const index = siblings.indexOf(node);\n                return index < siblings.length - 1;\n            }\n            return false;\n        }\n\n        function hasParent(node) {\n            // Given a node, return true if it has a parent. Except if that parent is the hidden root node.\n            return !!node.parent && !!node.parent.parent;\n        }\n\n        function hasThreadBack(node) {\n            // Much cheaper than computing the actual value.\n            return hasBack(node) || hasParent(node);\n        }\n\n        function moveToBack(node) {\n            // Given a node, return its previous sibling. If first, or no parent, return null.\n            const parent = node.parent;\n            if (parent) {\n                const siblings = children(parent);\n                const index = siblings.indexOf(node);\n                return index > 0 ? siblings[index - 1] : null;\n            }\n            return null;\n        }\n\n        function moveToFirstChild(node) {\n            // Given a node, return its first child if any. Else return null.\n            return hasChildren(node) ? node.children[0] : null;\n        }\n\n        function moveToLastChild(node) {\n            // Given a node, return its last child if any. Else return null.\n            return hasChildren(node) ? node.children[node.children.length - 1] : null;\n        }\n\n        function moveToLastNode(node) {\n            // Given a node, return the last node of its tree or itself if no children.\n            while (hasChildren(node)) {\n                node = moveToLastChild(node);\n            }\n            return node;\n        }\n\n        function moveToNext(node) {\n            // Given a node, return its next sibling. If already last, return null.\n            const parent = node.parent;\n            if (parent) {\n                const siblings = children(parent);\n                const index = siblings.indexOf(node);\n                return index < siblings.length - 1 ? siblings[index + 1] : null;\n            }\n            return null;\n        }\n\n        function moveToNodeAfterTree(node) {\n            // Given a node, return the node after the position's tree.\n            while (node) {\n                if (hasNext(node)) {\n                    node = moveToNext(node);\n                    break;\n                }\n                node = moveToParent(node);\n            }\n            return node;\n        }\n\n        function moveToParent(node) {\n            // Given a node, return its parent or null if no parent.\n            const parent = node.parent;\n            if (parent) {\n                return parent;\n            }\n            return null;\n        }\n\n        function moveToThreadBack(node) {\n            // Given a node, return the previous node in the outline.\n            if (hasBack(node)) {\n                node = moveToBack(node);\n                node = moveToLastNode(node);\n            } else {\n                node = moveToParent(node);\n            }\n            return node;\n        }\n\n        function moveToThreadNext(node) {\n            // Given a node, return the next node in the outline.\n            if (hasChildren(node)) {\n                node = moveToFirstChild(node);\n            } else if (hasNext(node)) {\n                node = moveToNext(node);\n            } else {\n                node = moveToParent(node);\n                while (node) {\n                    if (node && hasNext(node)) {\n                        node = moveToNext(node);\n                        break;\n                    }\n                    node = moveToParent(node);\n                }\n            }\n            return node;\n        };\n\n        function moveToVisBack(node) {\n            // Given a node, return the previous visible node in the outline.\n            while (node) {\n                // Short-circuit if possible.\n                const back = moveToBack(node);\n                if (back && hasChildren(back) && isExpanded(back))\n                    node = moveToThreadBack(node);\n                else if (back) {\n                    node = moveToBack(node);\n                } else {\n                    node = moveToParent(node);  // Same as p.moveToThreadBack()\n                }\n                if (node && isVisible(node)) {\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        function moveToVisNext(node) {\n            // Given a node, return the next visible node in the outline.\n            while (node) {\n                if (hasChildren(node)) {\n                    if (isExpanded(node)) {\n                        node = moveToFirstChild(node);\n                    } else {\n                        node = moveToNodeAfterTree(node);\n                    }\n                } else if (hasNext(node)) {\n                    node = moveToNext(node);\n                } else {\n                    node = moveToThreadNext(node);\n                }\n                if (node && isVisible(node)) {\n                    return node;\n                }\n            }\n        };\n\n        // * Navigation actions\n        function hoistNode() {\n            if (!selectedNode) return;\n\n            // If selected node is already hoisted: no-op (Even if button should be disabled in that case)\n            if (hoistStack.length > 0 && hoistStack[hoistStack.length - 1] === selectedNode) return;\n\n            if (!selectedNode.parent) return; // root node (though it should never be selected anyway)\n\n            hoistStack.push(selectedNode);\n            if (hasChildren(selectedNode) && !isExpanded(selectedNode)) {\n                expanded.add(selectedNode);\n                selectedNode.toggled = true; // Mark as toggled\n            }\n            updateHoistButtonStates();\n            flatRows = flattenTree(getCurrentRoot(), 0, false);\n            renderTree();\n        }\n\n        function dehoistNode() {\n            if (hoistStack.length === 0) return;\n            const previousHoist = hoistStack.pop();\n            selectAndOrToggleAndRedraw(previousHoist);\n            updateHoistButtonStates();\n        }\n\n        function expandNodeAndGoToFirstChild() {\n            // If the presently selected node has children, expand it if needed and go to the first child.\n            let node = selectedNode;\n            if (hasChildren(node)) {\n                if (!isExpanded(node)) {\n                    expanded.add(node);\n                    node.toggled = true; // Mark as toggled\n                }\n                node = moveToFirstChild(node);\n                selectAndOrToggleAndRedraw(node);\n            }\n        }\n\n        function contractNodeOrGoToParent() {\n            // If the presently selected node is expanded, collapse it. Otherwise go to the parent.\n            let node = selectedNode;\n            if (hasChildren(node) && isExpanded(node)) {\n                selectAndOrToggleAndRedraw(null, node);\n            } else if (hasParent(node)) {\n                const parent = moveToParent(node);\n                if (isVisible(parent)) {\n                    // Contract all children first\n                    for (const child of children(parent)) {\n                        if (isExpanded(child)) {\n                            expanded.delete(child);\n                            child.toggled = true; // Mark as toggled\n                        }\n                    }\n                    selectAndOrToggleAndRedraw(parent);\n                }\n            }\n        }\n\n        function selectVisBack() {\n            // Select the visible node preceding the presently selected node.\n            let node = selectedNode;\n            if (moveToVisBack(node)) {\n                node = moveToVisBack(node);\n                selectAndOrToggleAndRedraw(node);\n            }\n        }\n\n        function selectVisNext() {\n            // Select the visible node following the presently selected node.\n            let node = selectedNode;\n            if (moveToVisNext(node)) {\n                node = moveToVisNext(node);\n                selectAndOrToggleAndRedraw(node);\n            }\n        }\n\n        function gotoFirstSiblingOrParent() {\n            // Select the first sibling of the presently selected node, or its parent if already first.\n            let node = selectedNode;\n            const currentRoot = getCurrentRoot();\n            if (hasBack(node)) {\n                let firstVisibleSibling = null;\n                let current = node;\n                while (hasBack(current)) {\n                    let prev = moveToBack(current);\n                    if (isVisible(prev)) {\n                        firstVisibleSibling = prev;\n                        current = prev;\n                    } else {\n                        break;\n                    }\n                }\n                if (firstVisibleSibling) {\n                    node = firstVisibleSibling;\n                }\n            } else if (hasParent(node) && node !== currentRoot) {\n                const parent = moveToParent(node);\n                if (parent === currentRoot || isDescendantOfHoistedNode(parent)) {\n                    node = parent;\n                }\n            }\n            selectAndOrToggleAndRedraw(node);\n        };\n\n        function gotoLastSiblingOrVisNext() {\n            // Select the last sibling of the presently selected node, or the next visible node if already last.\n            let node = selectedNode;\n            const currentRoot = getCurrentRoot();\n            if (hasNext(node)) {\n                let lastVisibleSibling = null;\n                let current = node;\n                while (hasNext(current)) {\n                    let next = moveToNext(current);\n                    if (isVisible(next)) {\n                        lastVisibleSibling = next;\n                        current = next;\n                    } else {\n                        break;\n                    }\n                }\n                if (lastVisibleSibling) {\n                    node = lastVisibleSibling;\n                }\n            } else if (moveToVisNext(node)) {\n                node = moveToVisNext(node);\n            }\n            if (node) selectAndOrToggleAndRedraw(node);\n        };\n\n\n        function gotoFirstVisibleNode() {\n            // Get the current root (could be hoisted node or hidden root)\n            const currentRoot = getCurrentRoot();\n\n            // If we're hoisted, the first visible node could be the hoisted node itself\n            if (hoistStack.length > 0) {\n                selectAndOrToggleAndRedraw(currentRoot);\n                return;\n            }\n\n            // Otherwise, select the first child of the root node\n            const firstNode = moveToFirstChild(currentRoot);\n            if (firstNode) {\n                selectAndOrToggleAndRedraw(firstNode);\n            }\n        };\n\n        function gotoLastVisibleNode() {\n            // Select the last visible node in the outline.\n            let node = selectedNode;\n            while (node) {\n                const next = moveToVisNext(node);\n                if (next && isVisible(next)) {\n                    node = next;\n                } else {\n                    break;\n                }\n            }\n            if (node) selectAndOrToggleAndRedraw(node);\n        };\n\n        function collapseAll() {\n            // Collapse all nodes in visible outline and select the proper top-level node\n            const currentRoot = getCurrentRoot();\n            if (currentRoot === tree) {\n                expanded.clear();\n            } else {\n                const nodesToRemove = [];\n                expanded.forEach(node => {\n                    if (node === currentRoot || isAncestorOf(currentRoot, node)) {\n                        nodesToRemove.push(node);\n                    }\n                });\n                nodesToRemove.forEach(node => expanded.delete(node));\n            }\n            if (hoistStack.length > 0) {\n                selectAndOrToggleAndRedraw(currentRoot);\n            } else {\n                let node = selectedNode;\n                // If currently selected node is a descendant of a top-level node, find that top-level node\n                while (node && hasParent(node) && node.parent !== tree) {\n                    node = moveToParent(node);\n                }\n                if (node) selectAndOrToggleAndRedraw(node);\n            }\n        };\n\n        function toggleSelected() {\n            if (selectedNode && selectedNode.children && selectedNode.children.length > 0) {\n                selectAndOrToggleAndRedraw(null, selectedNode);\n            }\n        }\n\n        function toggleMark(node) {\n            if (!node) return;\n            const gnx = node.gnx;\n            if (marked.has(gnx)) {\n                marked.delete(gnx);\n                if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) & ~2; // Clear marked bit\n            } else {\n                marked.add(gnx);\n                if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 2; // Set marked bit\n            }\n            updateMarkedButtonStates();\n            // Only need to redraw the affected node if visible, no need to re-flatten because structure didn't change\n            if (isVisible(node)) {\n                renderTree();\n            }\n        }\n\n        function toggleMarkCurrentNode() {\n            if (selectedNode) {\n                toggleMark(selectedNode);\n            }\n        }\n\n        function gotoNextMarkedNode() {\n            if (!selectedNode || marked.size === 0) return;\n\n            const currentIndex = allNodesInOrder.findIndex(node => node === selectedNode);\n            if (currentIndex === -1) return; // Should never happen\n\n            let foundMarked = false;\n            for (let i = 1; i <= allNodesInOrder.length; i++) {\n                const nextIndex = (currentIndex + i) % allNodesInOrder.length; // Wrap around\n                const node = allNodesInOrder[nextIndex];\n\n                if (node === selectedNode) continue;\n\n                if (marked.has(node.gnx)) {\n                    selectAndOrToggleAndRedraw(node);\n                    foundMarked = true;\n                    break;\n                }\n            }\n\n            if (!foundMarked) {\n                if (marked.size === 1 && marked.has(selectedNode.gnx)) {\n                    showToast(\"Only one marked node.\");\n                } else {\n                    showToast(\"No other marked nodes found.\");\n                }\n            }\n        }\n\n        function gotoPrevMarkedNode() {\n            if (!selectedNode || marked.size === 0) return;\n\n            const currentIndex = allNodesInOrder.findIndex(node => node === selectedNode);\n            if (currentIndex === -1) return; // Should never happen\n\n            let foundMarked = false;\n            for (let i = 1; i <= allNodesInOrder.length; i++) {\n                const prevIndex = (currentIndex - i + allNodesInOrder.length) % allNodesInOrder.length; // Wrap around\n                const node = allNodesInOrder[prevIndex];\n\n                if (node === selectedNode) continue;\n\n                if (marked.has(node.gnx)) {\n                    selectAndOrToggleAndRedraw(node);\n                    foundMarked = true;\n                    break;\n                }\n            }\n\n            if (!foundMarked) {\n                if (marked.size === 1 && marked.has(selectedNode.gnx)) {\n                    showToast(\"Only one marked node.\");\n                } else {\n                    showToast(\"No other marked nodes found.\");\n                }\n            }\n        }\n\n        function updateMarkedButtonStates() {\n            const hasMarkedNodes = marked.size > 0;\n            NEXT_MARKED_BTN.disabled = !hasMarkedNodes;\n            PREV_MARKED_BTN.disabled = !hasMarkedNodes;\n        }\n\n        // * Hoist button\n        function updateHoistButtonStates() {\n            // Update hoist/dehoist button states\n            const isCurrentlyHoisted = hoistStack.length > 0 && hoistStack[hoistStack.length - 1] === selectedNode;\n            DEHOIST_BTN.disabled = hoistStack.length === 0;\n            HOIST_BTN.disabled = !selectedNode || !hasChildren(selectedNode) || isCurrentlyHoisted;\n        }\n\n        // * History\n        function updateHistoryButtonStates() {\n            // Disable/enable buttons based on history position\n            PREV_BTN.disabled = currentHistoryIndex <= 0;\n            NEXT_BTN.disabled = currentHistoryIndex >= navigationHistory.length - 1 || navigationHistory.length === 0;\n        }\n\n        function addToHistory(node) {\n            if (navigationHistory.length > 0 &&\n                navigationHistory[currentHistoryIndex] === node) {\n                return; // Already the current node, do nothing\n            }\n\n            // If we're not at the end, truncate the forward history\n            if (currentHistoryIndex < navigationHistory.length - 1) {\n                navigationHistory.splice(currentHistoryIndex + 1);\n            }\n\n            navigationHistory.push(node);\n            currentHistoryIndex = navigationHistory.length - 1;\n\n            updateHistoryButtonStates();\n        }\n\n        function previousHistory() {\n            if (currentHistoryIndex > 0) {\n                currentHistoryIndex--;\n                const node = navigationHistory[currentHistoryIndex];\n\n                // Navigate to the node without adding to history\n                selectAndOrToggleAndRedraw(node);\n                updateHistoryButtonStates();\n            }\n        }\n\n        function nextHistory() {\n            if (currentHistoryIndex < navigationHistory.length - 1) {\n                currentHistoryIndex++;\n                const node = navigationHistory[currentHistoryIndex];\n\n                // Navigate to the node without adding to history\n                selectAndOrToggleAndRedraw(node);\n                updateHistoryButtonStates();\n            }\n        }\n\n        function toggleConfiguration() {\n            if (HTML_ELEMENT.getAttribute('data-show-config') === 'true') {\n                HTML_ELEMENT.setAttribute('data-show-config', 'false');\n                CONFIG_BTN.innerHTML = '‚öôÔ∏è';\n                CONFIG_BTN.setAttribute('title', 'Configuration');\n                CONFIG_BTN.setAttribute('aria-label', 'Configuration');\n            } else {\n                HTML_ELEMENT.setAttribute('data-show-config', 'true');\n                CONFIG_BTN.innerHTML = '‚úîÔ∏è';\n                CONFIG_BTN.setAttribute('title', 'Back to Find');\n                CONFIG_BTN.setAttribute('aria-label', 'Back to Find');\n            }\n        }\n\n        // * Rendering helpers\n        function getCurrentRoot() {\n            // Return the current top of the hoist stack or the main tree root\n            return hoistStack.length > 0 ? hoistStack[hoistStack.length - 1] : tree;\n        }\n\n        function flattenTree(node, depth = 0, isRoot = true) {\n            // This only flattens the tree structure into an array of rows for rendering.\n            // It check for expansion state to include children as needed because only expanded nodes' children are visible.\n            // The isRoot parameter indicates if this node is the hidden root node (not visible).\n\n            let rows = [];\n\n            // Only add non-root nodes to the rows\n            if (!isRoot) {\n                rows.push({\n                    label: data[node.gnx].headString,\n                    depth,\n                    toggled: node.toggled || false, // Will make it render with toggled class\n                    hasChildren: !!node.children && node.children.length > 0,\n                    isExpanded: isExpanded(node),\n                    node\n                });\n            }\n            if (node.toggled) {\n                node.toggled = false; // Reset because it should not persist\n            }\n\n            if (isExpanded(node) && node.children) {\n                for (const child of node.children) {\n                    // Root node's children appear at depth 0\n                    const childDepth = isRoot ? 0 : depth + 1;\n                    rows.push(...flattenTree(child, childDepth, false));\n                }\n            }\n\n            return rows;\n        }\n\n        function selectAndOrToggleAndRedraw(newSelectedNode = null, nodeToToggle = null) {\n            // Handle toggling if requested\n            if (nodeToToggle) {\n                if (isExpanded(nodeToToggle)) {\n                    expanded.delete(nodeToToggle);\n                } else {\n                    expanded.add(nodeToToggle);\n                }\n                nodeToToggle.toggled = true; // Mark as toggled\n            }\n\n            const isNew = newSelectedNode && newSelectedNode !== selectedNode;\n\n            // Handle selection if requested\n            if (isNew) {\n                let hoistTop = getCurrentRoot();\n\n                // While the top of hoist stack is not an ancestor of the new selected node, pop it\n                while (newSelectedNode !== hoistTop && hoistStack.length > 0 && !isAncestorOf(hoistTop, newSelectedNode)) {\n                    hoistStack.pop();\n                    hoistTop = getCurrentRoot();\n                }\n\n                // Ensure all parent nodes are expanded so the selected node is visible\n                let currentNode = newSelectedNode;\n                while (currentNode && currentNode.parent && currentNode !== hoistTop) {\n                    // Skip the hidden root node since it's always expanded (When hoist is implemented, stop at hoist root)\n                    if (currentNode.parent.parent) {\n                        expanded.add(currentNode.parent);\n                    }\n                    currentNode = currentNode.parent;\n                }\n\n                selectedNode = newSelectedNode;\n                addToHistory(newSelectedNode);\n                updateHoistButtonStates();\n            }\n\n            // Only rebuild and redraw once\n            const currentRoot = getCurrentRoot();\n            const isHoisted = hoistStack.length > 0;\n\n            // If hoisted, pass isRoot=false to make the hoisted node visible\n            // If not hoisted, use the hidden root with isRoot=true\n            flatRows = flattenTree(currentRoot, 0, !isHoisted);\n            renderTree();\n\n            // Update body pane if selection changed (selectedNode cannot be null here because of isNew check)\n            if (isNew) {\n                if (newSelectedNode && data[newSelectedNode.gnx]) {\n                    BODY_PANE.textContent = data[newSelectedNode.gnx].bodyString || \"\";\n                } else {\n                    BODY_PANE.textContent = \"\";\n                }\n            }\n            scrollSelectedNodeIntoView();\n        }\n\n        function scrollSelectedNodeIntoView() {\n            if (!selectedNode || !flatRows) return; // Not initialized yet\n\n            const selectedIndex = flatRows.findIndex(row => row.node === selectedNode);\n            if (selectedIndex === -1) return; // Not found (shouldn't happen)\n            const nodePosition = selectedIndex * ROW_HEIGHT;\n\n            const scrollTop = OUTLINE_PANE.scrollTop;\n            const viewportHeight = OUTLINE_PANE.clientHeight;\n\n            if (nodePosition < scrollTop) {\n                OUTLINE_PANE.scrollTop = nodePosition;\n            } else if (nodePosition + ROW_HEIGHT > scrollTop + viewportHeight) {\n                OUTLINE_PANE.scrollTop = nodePosition - viewportHeight + ROW_HEIGHT;\n            }\n        }\n\n        function throttle(func, limit) {\n            let lastCall = 0;\n            let timeout;\n\n            return function (...args) {\n                const now = Date.now();\n                if (timeout) {\n                    clearTimeout(timeout);\n                }\n                if (now - lastCall >= limit) {\n                    lastCall = now;\n                    func.apply(this, args);\n                } else {\n                    timeout = setTimeout(() => {\n                        lastCall = Date.now();\n                        func.apply(this, args);\n                    }, limit - (now - lastCall));\n                }\n            };\n        }\n\n        function renderTree() {\n            if (!flatRows) return; // Not initialized yet\n\n            // Render visible rows only\n            const scrollTop = OUTLINE_PANE.scrollTop;\n            const viewportHeight = OUTLINE_PANE.clientHeight;\n            const viewportWidth = OUTLINE_PANE.clientWidth;\n\n            const startIndex = Math.floor(scrollTop / ROW_HEIGHT);\n            const visibleCount = Math.ceil(viewportHeight / ROW_HEIGHT) + 1;\n            const endIndex = Math.min(flatRows.length, startIndex + visibleCount);\n            let leftOffset = LEFT_OFFSET;\n\n            // If all nodes have no children, remove the left offset\n            if (flatRows.every(row => !row.hasChildren)) {\n                leftOffset = 0;\n            }\n\n            SPACER.innerHTML = \"\";\n            SPACER.style.height = flatRows.length * ROW_HEIGHT + \"px\";\n\n            let selectedRadioValue = ''; // Falsy for now\n            const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\n            if (selectedRadio) {\n                selectedRadioValue = selectedRadio.value;\n            }\n\n            const searchSuboutline = selectedRadioValue === 'suboutline' && initialFindNode; // Will contain the node or null\n            const searchNodeOnly = selectedRadioValue === 'node'; // selected node only\n\n            for (let i = startIndex; i < endIndex; i++) {\n                const row = flatRows[i];\n                const div = document.createElement(\"div\");\n                div.className = \"node\";\n                if (row.label) {\n                    div.title = row.label;\n                }\n\n                if (row.node === selectedNode) {\n                    div.classList.add(\"selected\");\n                } else if (selectedNode && isAncestorOf(row.node, selectedNode)) {\n                    div.classList.add(\"ancestor\");\n                }\n\n                if (searchNodeOnly && row.node === selectedNode) {\n                    div.classList.add(\"initial-find\");\n                }\n\n                if (searchSuboutline && (row.node === searchSuboutline || isAncestorOf(searchSuboutline, row.node))) {\n                    div.classList.add(\"initial-find\");\n                }\n\n                div.style.top = (i * ROW_HEIGHT) + \"px\";\n                div.style.height = ROW_HEIGHT + \"px\";\n\n                const leftPosition = (row.depth * 20) + leftOffset;\n                div.style.left = leftPosition + \"px\";\n                div.style.width = (viewportWidth - leftPosition) + \"px\";\n\n                const caret = document.createElement(\"span\");\n                caret.className = row.toggled ? \"caret toggled\" : \"caret\";\n\n                row.toggled = false; // Reset toggled state after rendering\n\n                if (row.hasChildren) {\n                    caret.setAttribute(\"data-expanded\", row.isExpanded ? \"true\" : \"false\");\n                }\n                div.appendChild(caret);\n\n                const labelSpan = document.createElement(\"span\");\n                labelSpan.className = \"node-text\";\n\n                // If dark mode, invert the icons' 4 bit to swap dirty borders inverted\n                if (currentTheme === 'dark') {\n                    let invertedIcon = data[row.node.gnx].icon ^ 8; // Toggle the 4 bit\n                    labelSpan.classList.add(\"icon\" + invertedIcon);\n                } else {\n                    labelSpan.classList.add(\"icon\" + (data[row.node.gnx].icon || 0));\n                }\n\n                labelSpan.textContent = row.label;\n                if (row.node === selectedNode) {\n                    selectedLabelElement = labelSpan;\n                }\n\n                div.appendChild(labelSpan);\n                SPACER.appendChild(div);\n            }\n        }\n\n        function safeLocalStorageGet(key) {\n            try {\n                return localStorage.getItem(key);\n            } catch (e) {\n                return null;\n            }\n        }\n\n        function safeLocalStorageSet(key, value) {\n            try {\n                localStorage.setItem(key, value);\n            } catch (e) {\n                // ignore\n            }\n        }\n\n        function saveMainRatio(proportion) {\n            safeLocalStorageSet('mainRatio', proportion);\n        }\n\n        const throttledSaveMainRatio = throttle(saveMainRatio, 500);\n\n        function getSavedMainRatio() {\n            const saved = safeLocalStorageGet('mainRatio');\n            return saved != null ? parseFloat(saved) : null;\n        }\n\n        function updateProportion() {\n            if (currentLayout === 'vertical') {\n                mainRatio = OUTLINE_FIND_CONTAINER.offsetWidth / window.innerWidth;\n            } else {\n                mainRatio = OUTLINE_FIND_CONTAINER.offsetHeight / window.innerHeight;\n            }\n            throttledSaveMainRatio(mainRatio);\n        }\n\n        function updateOutlineContainerSize() {\n            if (currentLayout === 'vertical') {\n                let newWidth = window.innerWidth * mainRatio;\n                if (newWidth < minWidth) {\n                    newWidth = minWidth;\n                }\n                OUTLINE_FIND_CONTAINER.style.width = `${newWidth}px`;\n                OUTLINE_FIND_CONTAINER.style.height = '100%';\n                CONFIG_BTN.style.inset = `auto auto 7px ${newWidth - 33}px`;\n            } else {\n                let newHeight = window.innerHeight * mainRatio;\n                if (newHeight < minWidth) {\n                    newHeight = minWidth;\n                }\n                OUTLINE_FIND_CONTAINER.style.height = `${newHeight}px`;\n                OUTLINE_FIND_CONTAINER.style.width = '100%';\n                CONFIG_BTN.style.inset = `${newHeight - 33}px 7px auto auto`;\n            }\n        }\n\n        const handleDrag = throttle(function (e) {\n            if (currentLayout === 'vertical') {\n                let clientX = e.clientX;\n                if (e.touches) {\n                    clientX = e.touches[0].clientX;\n                }\n                const newWidth = clientX;\n                if (newWidth >= minWidth) {\n                    OUTLINE_FIND_CONTAINER.style.width = (newWidth - 3) + 'px';\n                } else {\n                    OUTLINE_FIND_CONTAINER.style.width = (minWidth - 3) + 'px';\n                }\n                CONFIG_BTN.style.inset = `auto auto 7px ${newWidth - 33}px`;\n            } else {\n                let clientY = e.clientY;\n                if (e.touches) {\n                    clientY = e.touches[0].clientY;\n                }\n                const newHeight = clientY;\n                if (newHeight >= minWidth) {\n                    OUTLINE_FIND_CONTAINER.style.height = (newHeight - 3) + 'px';\n                } else {\n                    OUTLINE_FIND_CONTAINER.style.height = (minWidth - 3) + 'px';\n                }\n                renderTree(); // Resizing vertically, so need to re-render tree\n                CONFIG_BTN.style.inset = `${newHeight - 33}px 7px auto auto`;\n            }\n        }, 33);\n\n        function startDrag(e) {\n            isDragging = true;\n            document.body.classList.add('dragging-main');\n            e.preventDefault();\n            document.addEventListener('mousemove', handleDrag);\n            document.addEventListener('mouseup', stopDrag);\n            document.addEventListener('touchmove', handleDrag, { passive: false });\n            document.addEventListener('touchend', stopDrag);\n        }\n\n        function stopDrag() {\n            if (isDragging) {\n                isDragging = false;\n                document.body.classList.remove('dragging-main');\n                document.removeEventListener('mousemove', handleDrag);\n                document.removeEventListener('mouseup', stopDrag);\n                document.removeEventListener('touchmove', handleDrag);\n                document.removeEventListener('touchend', stopDrag);\n                updateProportion();\n                renderTree();\n            }\n        }\n\n        function saveSecondaryRatio(proportion) {\n            safeLocalStorageSet('secondaryRatio', proportion);\n        }\n\n        const throttledSaveSecondaryRatio = throttle(saveSecondaryRatio, 500);\n\n        function getSavedSecondaryRatio() {\n            const saved = safeLocalStorageGet('secondaryRatio');\n            return saved != null ? parseFloat(saved) : null;\n        }\n\n        function updateSecondaryProportion() {\n            if (currentLayout === 'vertical') {\n                secondaryRatio = (OUTLINE_PANE.offsetHeight - 6) / OUTLINE_FIND_CONTAINER.offsetHeight;\n            } else {\n                secondaryRatio = OUTLINE_PANE.offsetWidth / OUTLINE_FIND_CONTAINER.offsetWidth;\n            }\n            throttledSaveSecondaryRatio(secondaryRatio);\n        }\n\n        function updateOutlinePaneSize() {\n            if (currentLayout === 'vertical') {\n                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\n                let newHeight = containerHeight * secondaryRatio;\n\n                // Respect minimum heights\n                if (newHeight < minHeight) {\n                    newHeight = minHeight;\n                } else if (newHeight > containerHeight - minHeight) {\n                    newHeight = containerHeight - minHeight;\n                }\n                // Set flex properties to control the distribution\n                OUTLINE_PANE.style.flex = `0 0 ${newHeight}px`;\n            } else {\n                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\n                let newWidth = containerWidth * secondaryRatio;\n\n                // Respect minimum widths\n                if (newWidth < minHeight) {\n                    newWidth = minHeight;\n                } else if (newWidth > containerWidth - minHeight) {\n                    newWidth = containerWidth - minHeight;\n                }\n                // Set flex properties to control the distribution\n                OUTLINE_PANE.style.flex = `0 0 ${newWidth}px`;\n            }\n            FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\n        }\n\n        const handleSecondaryDrag = throttle(function (e) {\n            if (currentLayout === 'vertical') {\n                let clientY = e.clientY;\n                if (e.touches) {\n                    clientY = e.touches[0].clientY;\n                }\n                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\n                const relativeY = clientY - containerRect.top;\n                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\n                if (relativeY >= minHeight && relativeY <= containerHeight - minHeight) {\n                    OUTLINE_PANE.style.flex = `0 0 ${relativeY - 8}px`;\n                    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\n                }\n                renderTree(); // Resizing vertically, so need to re-render tree\n            } else {\n                let clientX = e.clientX;\n                if (e.touches) {\n                    clientX = e.touches[0].clientX;\n                }\n                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\n                const relativeX = clientX - containerRect.left;\n                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\n                if (relativeX >= minHeight && relativeX <= containerWidth - minHeight) {\n                    OUTLINE_PANE.style.flex = `0 0 ${relativeX - 3}px`;\n                    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\n                }\n            }\n        }, 33);\n\n        function startSecondaryDrag(e) {\n            secondaryIsDragging = true;\n            document.body.classList.add('dragging-secondary');\n            e.preventDefault();\n            document.addEventListener('mousemove', handleSecondaryDrag);\n            document.addEventListener('mouseup', stopSecondaryDrag);\n            document.addEventListener('touchmove', handleSecondaryDrag, { passive: false });\n            document.addEventListener('touchend', stopSecondaryDrag);\n        }\n\n        function stopSecondaryDrag() {\n            if (secondaryIsDragging) {\n                secondaryIsDragging = false;\n                document.body.classList.remove('dragging-secondary');\n                document.removeEventListener('mousemove', handleSecondaryDrag);\n                document.removeEventListener('mouseup', stopSecondaryDrag);\n                document.removeEventListener('touchmove', handleSecondaryDrag);\n                document.removeEventListener('touchend', stopSecondaryDrag);\n                updateSecondaryProportion();\n                renderTree();\n            }\n        }\n\n        function updatePanelSizes() {\n            updateOutlineContainerSize();\n            updateOutlinePaneSize();\n        }\n\n        function saveDocumentStateToLocalStorage() {\n            // Save the current configuration preferences\n            saveConfigPreferences();\n\n            // Use the allNodesInOrder tree, the full list from the top as if all nodes were expanded,\n            // to note the position of hoisted node(s), expanded node(s), and the currently selected node.\n            let hoistStackPositions = []; // empty means no hoist\n            for (const hoisted of hoistStack) {\n                const pos = allNodesInOrder.indexOf(hoisted);\n                if (pos !== -1) {\n                    hoistStackPositions.push(pos);\n                }\n            }\n            const expandedPositions = [];\n            for (const node of expanded) {\n                const pos = allNodesInOrder.indexOf(node);\n                if (pos !== -1) {\n                    expandedPositions.push(pos);\n                }\n            }\n            const selectedPosition = allNodesInOrder.indexOf(selectedNode); // -1 means no selection\n            const markedArray = Array.from(marked); // Marked are the gnx keys, not numeric positions from allNodesInOrder\n            const dataToSave = {\n                marked: markedArray,\n                hoistStack: hoistStackPositions,\n                selected: selectedPosition,\n                expanded: expandedPositions\n            };\n            safeLocalStorageSet(title + genTimestamp, JSON.stringify(dataToSave)); // Key is title + genTimestamp\n        }\n\n        function loadDocumentStateFromLocalStorage() {\n            // returns the selected node if found, otherwise null\n            let initialSelectedNode = null;\n            const savedData = safeLocalStorageGet(title + genTimestamp); // Key is title + genTimestamp\n            if (savedData) {\n                try {\n                    const parsedData = JSON.parse(savedData);\n                    // Start by rebuilding marked set and their related node icons\n                    if (parsedData && Array.isArray(parsedData.marked)) {\n                        marked.clear();\n                        parsedData.marked.forEach(gnx => {\n                            marked.add(gnx);\n                            // Update icon state to reflect marked status\n                            if (data[gnx]) {\n                                data[gnx].icon = (data[gnx].icon || 0) | 2; // Set marked bit\n                            }\n                        });\n                    }\n                    // If document stated data is found, rebuild hoist stack, expanded set, and selected node\n                    if (parsedData && Array.isArray(parsedData.expanded) && Array.isArray(parsedData.hoistStack) && typeof parsedData.selected === 'number') {\n                        const expandedPositions = parsedData.expanded;\n                        let expandedPositionsIndex = 0;\n                        const hoistPositions = parsedData.hoistStack;\n                        const selectedPosition = parsedData.selected;\n\n                        for (const hoisted of hoistPositions) {\n                            if (hoisted >= 0 && hoisted < allNodesInOrder.length) {\n                                hoistStack.push(allNodesInOrder[hoisted]);\n                            }\n                        }\n                        for (const node of expandedPositions) {\n                            if (node >= 0 && node < allNodesInOrder.length) {\n                                expanded.add(allNodesInOrder[node]);\n                            }\n                        }\n                        if (selectedPosition >= 0 && selectedPosition < allNodesInOrder.length) {\n                            initialSelectedNode = allNodesInOrder[selectedPosition];\n                        }\n\n                    }\n                    return initialSelectedNode;\n\n                } catch (e) {\n                    console.error('Error loading document state from localStorage:', e);\n                }\n            }\n        }\n\n        const getCurrentTheme = () => {\n            const savedTheme = safeLocalStorageGet('theme');\n            if (savedTheme) {\n                return savedTheme;\n            }\n            // Use OS preference as fallback\n            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n        };\n\n        const getCurrentLayout = () => {\n            return localStorage.getItem('layout') || 'vertical';\n        };\n\n        const applyTheme = (theme) => {\n            currentTheme = theme;\n            HTML_ELEMENT.setAttribute('data-theme', theme);\n            safeLocalStorageSet('theme', theme);\n            THEME_TOGGLE.title = theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme';\n            THEME_ICON.innerHTML = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';\n        };\n\n        const applyLayout = (layout) => {\n            currentLayout = layout;\n            localStorage.setItem('layout', layout);\n            LAYOUT_TOGGLE.title = layout === 'vertical' ? 'Switch to horizontal layout' : 'Switch to vertical layout';\n            if (layout === 'horizontal') {\n                HTML_ELEMENT.setAttribute('data-layout', 'horizontal');\n            } else {\n                HTML_ELEMENT.setAttribute('data-layout', 'vertical');\n            }\n            updatePanelSizes(); // Proportions will have changed so we must update sizes\n            if (flatRows) {\n                renderTree();\n            }\n        };\n\n        // Setup and organize all event handlers\n        function setupEventHandlers() {\n            setupOutlinePaneHandlers();\n            setupBodyPaneHandlers();\n            setupResizerHandlers();\n            setupWindowHandlers();\n            setupButtonHandlers();\n            setupFindPaneHandlers();\n            setupConfigCheckboxes();\n        }\n\n        function preventDefault(e) {\n            e.preventDefault(); // Utility function used in setupBodyPaneHandlers\n        }\n\n        function setupOutlinePaneHandlers() {\n            // Prevent text selection on double-click\n            OUTLINE_PANE.addEventListener(\"mousedown\", handleOutlinePaneMouseDown);\n            OUTLINE_PANE.addEventListener('click', handleOutlinePaneClick);\n            OUTLINE_PANE.addEventListener('dblclick', handleOutlinePaneDblClick);\n            OUTLINE_PANE.addEventListener('keydown', handleOutlinePaneKeyDown);\n            OUTLINE_PANE.addEventListener(\"scroll\", throttle(renderTree, 33));\n        }\n\n        function setupBodyPaneHandlers() {\n            BODY_PANE.addEventListener('keydown', handleBodyPaneKeyDown);\n            BODY_PANE.addEventListener(\"beforeinput\", preventDefault); // Block text changes\n            BODY_PANE.addEventListener(\"paste\", preventDefault); // Block text changes\n        }\n\n        function setupResizerHandlers() {\n            VERTICAL_RESIZER.addEventListener('mousedown', startDrag);\n            VERTICAL_RESIZER.addEventListener('touchstart', startDrag);\n            HORIZONTAL_RESIZER.addEventListener('mousedown', startSecondaryDrag);\n            HORIZONTAL_RESIZER.addEventListener('touchstart', startSecondaryDrag);\n        }\n\n        function setupWindowHandlers() {\n            window.addEventListener('resize', throttle(handleWindowResize, 33));\n            window.addEventListener('keydown', handleGlobalKeyDown);\n            window.addEventListener('beforeunload', saveDocumentStateToLocalStorage);\n        }\n\n        function setupButtonHandlers() {\n            COLLAPSE_ALL_BTN.addEventListener('click', collapseAll);\n            THEME_TOGGLE.addEventListener('click', handleThemeToggleClick);\n            LAYOUT_TOGGLE.addEventListener('click', handleLayoutToggleClick);\n            HOIST_BTN.addEventListener('click', hoistNode);\n            DEHOIST_BTN.addEventListener('click', dehoistNode);\n            PREV_BTN.addEventListener('click', previousHistory);\n            NEXT_BTN.addEventListener('click', nextHistory);\n            TOGGLE_MARK_BTN.addEventListener('click', toggleMarkCurrentNode);\n            NEXT_MARKED_BTN.addEventListener('click', gotoNextMarkedNode);\n            PREV_MARKED_BTN.addEventListener('click', gotoPrevMarkedNode);\n            CONFIG_BTN.addEventListener('click', toggleConfiguration);\n        }\n\n        function setupFindPaneHandlers() {\n            FIND_INPUT.addEventListener('keydown', function (e) {\n                if (e.key === 'Tab' && e.shiftKey) {\n                    e.preventDefault();\n                    OPT_BODY.focus();\n                }\n                if (e.key === 'Enter') {\n                    e.preventDefault();\n                    findNext();\n                }\n            });\n            OPT_BODY.addEventListener('keydown', function (e) {\n                if (e.key === 'Tab' && !e.shiftKey) {\n                    e.preventDefault();\n                    FIND_INPUT.focus();\n                }\n            });\n            const findScopeRadios = document.querySelectorAll('input[name=\"find-scope\"]');\n            findScopeRadios.forEach(radio => {\n                radio.addEventListener('change', function () {\n                    initialFindNode = null; // Reset initial find node when scope changes\n                    renderTree(); // Re-render to update node highlighting\n                });\n            });\n        }\n\n        function setupButtonFocusPrevention() {\n            const actionButtons = document.querySelectorAll('.action-button');\n            actionButtons.forEach(button => {\n                button.addEventListener('mousedown', (e) => {\n                    e.preventDefault();\n                });\n            });\n        }\n\n        function handleOutlinePaneMouseDown(e) {\n            if (e.detail === 2) e.preventDefault();\n        }\n\n        function handleOutlinePaneClick(event) {\n            const nodeEl = event.target.closest('.node');\n            if (!nodeEl) return;\n\n            const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\n            if (rowIndex < 0 || rowIndex >= flatRows.length) return;\n\n            const row = flatRows[rowIndex];\n\n            // Handle different click targets\n            if (event.target.classList.contains('caret') && row.hasChildren) {\n                event.stopPropagation();\n                // Both toggle and select in one operation\n                selectAndOrToggleAndRedraw(\n                    row.node !== selectedNode ? row.node : null,\n                    row.node\n                );\n            } else {\n                // Rest of the node (including icon and text)\n                event.stopPropagation();\n                if (row.node !== selectedNode) {\n                    selectAndOrToggleAndRedraw(row.node); // Just selection\n                }\n            }\n        }\n\n        function handleOutlinePaneDblClick(event) {\n            if (event.target.classList.contains('node-text')) {\n                event.preventDefault();\n                event.stopPropagation();\n\n                const nodeEl = event.target.closest('.node');\n                if (!nodeEl) return;\n\n                const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\n                if (rowIndex >= 0 && rowIndex < flatRows.length) {\n                    const row = flatRows[rowIndex];\n                    if (row.hasChildren) {\n                        // Handle both selection and toggle in one update\n                        selectAndOrToggleAndRedraw(\n                            row.node !== selectedNode ? row.node : null,\n                            row.node\n                        );\n                    }\n                }\n            }\n        }\n\n        const outlinePaneKeyMap = {\n            'Enter': () => BODY_PANE.focus(),\n            'Tab': () => BODY_PANE.focus(),\n            ' ': () => toggleSelected(),\n            'ArrowUp': () => selectVisBack(),\n            'ArrowDown': () => selectVisNext(),\n            'ArrowLeft': () => contractNodeOrGoToParent(),\n            'ArrowRight': () => expandNodeAndGoToFirstChild(),\n            'PageUp': () => gotoFirstSiblingOrParent(),\n            'PageDown': () => gotoLastSiblingOrVisNext(),\n            'Home': () => gotoFirstVisibleNode(),\n            'End': () => gotoLastVisibleNode()\n        };\n\n        function handleOutlinePaneKeyDown(e) {\n            const handler = outlinePaneKeyMap[e.key];\n            if (handler && !e.ctrlKey && !e.altKey && !e.metaKey) {\n                e.preventDefault();\n                handler();\n            }\n        }\n\n        function handleBodyPaneKeyDown(e) {\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                OUTLINE_PANE.focus();\n            }\n        }\n\n        function startFind() {\n            initialFindNode = null; // If null, find next will set this, used with \"Suboutline Only\" find radio option (value: suboutline)\n            if (HTML_ELEMENT.getAttribute('data-show-config') === 'true') {\n                toggleConfiguration(); // // Make find input visible if in settings screen\n            }\n            FIND_INPUT.focus();\n            FIND_INPUT.select();\n            renderTree(); // To show or remove initial-find highlight\n        }\n\n        // Global key handlers (work anywhere)\n        function handleGlobalKeyDown(e) {\n            if (e.key.toLowerCase() === 'f' && e.ctrlKey && !e.altKey && !e.metaKey) {\n                e.preventDefault();\n                startFind();\n            } else if (e.key.toLowerCase() === 'm' && e.ctrlKey && !e.altKey && !e.metaKey) {\n                e.preventDefault();\n                toggleMarkCurrentNode();\n            } else if (e.key === 'F2') {\n                e.preventDefault();\n                findPrevious();\n            } else if (e.key === 'F3') {\n                e.preventDefault();\n                findNext();\n            } else if (e.key === '-' && e.altKey && !e.ctrlKey && !e.metaKey) {\n                e.preventDefault();\n                collapseAll();\n            } else if (e.altKey && !e.ctrlKey && !e.metaKey) {\n                // Handle Alt+Arrow keys globally\n                switch (e.key) {\n                    case 'ArrowUp':\n                        e.preventDefault();\n                        OUTLINE_PANE.focus();\n                        selectVisBack();\n                        break;\n                    case 'ArrowDown':\n                        e.preventDefault();\n                        OUTLINE_PANE.focus();\n                        selectVisNext();\n                        break;\n                    case 'ArrowLeft':\n                        e.preventDefault();\n                        OUTLINE_PANE.focus();\n                        contractNodeOrGoToParent();\n                        break;\n                    case 'ArrowRight':\n                        e.preventDefault();\n                        OUTLINE_PANE.focus();\n                        expandNodeAndGoToFirstChild();\n                        break;\n                }\n            }\n        }\n\n        function handleWindowResize() {\n            updatePanelSizes();\n            renderTree();\n        }\n\n        function handleDOMContentLoaded() {\n            const initialSelectedNode = loadDocumentStateFromLocalStorage();\n            if (!initialSelectedNode) {\n                selectAndOrToggleAndRedraw(tree.children[0]); // sets selectedNode amd flatRows\n            } else {\n                selectAndOrToggleAndRedraw(initialSelectedNode); // sets selectedNode amd flatRows\n                if (data[selectedNode.gnx]) {\n                    BODY_PANE.textContent = data[selectedNode.gnx].bodyString || \"\";\n                }\n            }\n\n            // Layout has been initialized before dom loaded, to prevent 'fouc'\n            renderTree(); // flatRows already set by selectAndOrToggleAndRedraw: Ok to render now\n            scrollSelectedNodeIntoView();\n        }\n\n        function handleThemeToggleClick() {\n            // Only animate once button pressed, so page-load wont animate color changes.\n            HTML_ELEMENT.setAttribute('data-transition', 'true');\n            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n            applyTheme(newTheme);\n            renderTree(); // Re-render to update icon colors\n        }\n\n        function handleLayoutToggleClick() {\n            HTML_ELEMENT.setAttribute('data-transition', 'true');\n            const newLayout = currentLayout === 'vertical' ? 'horizontal' : 'vertical';\n            applyLayout(newLayout);\n        }\n\n        // Find functionality\n        function findNext() {\n            if (!selectedNode) return; // No selection, nothing to search from\n            const searchText = FIND_INPUT.value.trim();\n            if (!searchText) {\n                showToast('Empty find pattern', 1500);\n                return; // Empty search, do nothing\n            }\n\n            const searchInBody = OPT_BODY.checked;\n            const searchInHeadlines = OPT_HEADLINE.checked;\n            const ignoreCase = OPT_IGNORECASE.checked;\n            const isRegexp = OPT_REGEXP.checked;\n            const wholeWord = OPT_WHOLE.checked;\n            const markFind = OPT_MARK.checked;\n\n            if (!searchInBody && !searchInHeadlines) {\n                showToast('not searching headline or body', 2000);\n                return; // Nothing to search in\n            }\n            if (!initialFindNode) {\n                initialFindNode = selectedNode; // Set initial find node if not already set\n            }\n\n            let selectedRadioValue = ''; // Falsy for now\n            const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\n            if (selectedRadio) {\n                selectedRadioValue = selectedRadio.value;\n            }\n\n            let pattern; // Create regex pattern based on search options\n            try {\n                if (isRegexp) {\n                    pattern = searchText;\n                } else {\n                    pattern = searchText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape special regex characters\n                    if (wholeWord) {\n                        pattern = '\\\\b' + pattern + '\\\\b'; // Add word boundaries if whole word option is enabled\n                    }\n                }\n                const flags = ignoreCase ? 'gi' : 'g';\n                const regex = new RegExp(pattern, flags);\n\n                const startIndex = allNodesInOrder.indexOf(selectedNode);\n                if (startIndex === -1) return;\n\n                const totalNodes = allNodesInOrder.length;\n                let currentIndex = startIndex; // start from current selection\n\n                while (currentIndex < totalNodes) {\n                    const node = allNodesInOrder[currentIndex];\n                    if (selectedRadioValue === 'suboutline' && (initialFindNode !== node && isAncestorOf(initialFindNode, node) === false)) {\n                        break; // Reached outside suboutline of initialFindNode\n                    }\n\n                    let headString = data[node.gnx]?.headString || \"\";\n                    let body = data[node.gnx]?.bodyString || \"\";\n\n                    // If searching headlines, check there first, but skip if the focus in in the body pane and its the currently selected node\n                    if (searchInHeadlines && headString && !(node === selectedNode && findFocus() === 2)) {\n                        regex.lastIndex = 0; // Reset regex state\n                        let startOffset = 0;\n                        // If this is the currently selected node, check for current selection range existing in selectedLabelElement with getSelection()\n                        // and only search after that range. Keep that offset, if any, and apply it to the match index later.\n                        if (node === selectedNode && selectedLabelElement) {\n                            const selection = window.getSelection();\n                            if (selection.rangeCount > 0) {\n                                const range = selection.getRangeAt(0);\n                                if (selectedLabelElement.contains(range.commonAncestorContainer)) {\n                                    // Selection is inside the headline span\n                                    startOffset = range.endOffset;\n                                    headString = headString.substring(startOffset);\n                                }\n                            }\n                        }\n\n                        const match = regex.exec(headString);\n\n                        if (match) {\n                            // If 'mark find' is checked, mark the found node if not already marked\n                            if (markFind) {\n                                if (!marked.has(node.gnx)) {\n                                    marked.add(node.gnx);\n                                    if (data[node.gnx]) {\n                                        data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                                    }\n                                }\n                            }\n                            selectAndOrToggleAndRedraw(node); // This also calls scrollSelectedNodeIntoView\n\n                            // Focus outline pane and highlight match\n                            if (findFocus() !== 1) {\n                                OUTLINE_PANE.focus();\n                            }\n\n                            // Highlight the match in the headline using selectedLabelElement\n                            setTimeout(() => {\n                                highlightMatchInHeadline(match.index + startOffset, match.index + startOffset + match[0].length);\n                            });\n\n                            return;\n                        }\n                    }\n\n                    if (searchInBody && body) {\n                        regex.lastIndex = 0; // Reset regex state\n\n                        // If this is the currently selected node, check for current selection range existing in BODY_PANE with getSelection()\n                        // and only search after that range. Keep that offset, if any, and apply it to the match index later.\n                        let startOffset = 0;\n                        if (node === selectedNode && BODY_PANE) {\n                            const selection = window.getSelection();\n                            if (selection.rangeCount > 0) {\n                                const range = selection.getRangeAt(0);\n                                if (BODY_PANE.contains(range.commonAncestorContainer)) {\n                                    // Selection is inside the body pane\n                                    startOffset = range.endOffset;\n                                    body = body.substring(startOffset);\n                                }\n                            }\n                        }\n\n                        const match = regex.exec(body);\n                        if (match) {\n                            if (markFind) {\n                                if (!marked.has(node.gnx)) {\n                                    marked.add(node.gnx);\n                                    if (data[node.gnx]) {\n                                        data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                                    }\n                                }\n                            }\n                            selectAndOrToggleAndRedraw(node); // This also calls scrollSelectedNodeIntoView\n                            if (findFocus() !== 2) {\n                                BODY_PANE.focus();\n                            }\n                            setTimeout(() => {\n                                highlightMatchInBody(match.index + startOffset, match.index + startOffset + match[0].length);\n                            });\n                            return;\n                        }\n                    }\n                    if (selectedRadioValue === 'nodeonly') {\n                        break; // Only search current node\n                    }\n                    currentIndex++;\n                }\n\n                let searchedParams = [];\n                if (searchInHeadlines) searchedParams.push('head');\n                if (searchInBody) searchedParams.push('body');\n                showToast(`Not found: (${searchedParams.join(\", \")}) ${searchText}`, 1500);\n\n            } catch (e) {\n                showToast('Invalid search pattern: ' + e.message, 2000);\n            }\n\n        }\n\n        function findPrevious() {\n            if (!selectedNode) return; // No selection, nothing to search from\n            const searchText = FIND_INPUT.value.trim();\n            if (!searchText) {\n                showToast('Empty find pattern', 1500);\n                return; // Empty search, do nothing\n            }\n\n            const searchInBody = OPT_BODY.checked;\n            const searchInHeadlines = OPT_HEADLINE.checked;\n            const ignoreCase = OPT_IGNORECASE.checked;\n            const isRegexp = OPT_REGEXP.checked;\n            const wholeWord = OPT_WHOLE.checked;\n            const markFind = OPT_MARK.checked;\n\n            if (!searchInBody && !searchInHeadlines) {\n                showToast('not searching headline or body', 2000);\n                return; // Nothing to search in\n            }\n            if (!initialFindNode) {\n                initialFindNode = selectedNode; // Set initial find node if not already set\n            }\n\n            let selectedRadioValue = ''; // Falsy for now\n            const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\n            if (selectedRadio) {\n                selectedRadioValue = selectedRadio.value;\n            }\n\n            let pattern; // Create regex pattern based on search options\n            try {\n                if (isRegexp) {\n                    pattern = searchText;\n                } else {\n                    pattern = searchText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape special regex characters\n                    if (wholeWord) {\n                        pattern = '\\\\b' + pattern + '\\\\b'; // Add word boundaries if whole word option is enabled\n                    }\n                }\n                const flags = ignoreCase ? 'gi' : 'g';\n                const regex = new RegExp(pattern, flags);\n\n                const startIndex = allNodesInOrder.indexOf(selectedNode);\n                if (startIndex === -1) return;\n\n                // Helper function to find the last match in a string\n                function findLastMatch(str) {\n                    let lastMatchIndex = -1;\n                    let lastMatchLength = 0;\n\n                    let match;\n                    while ((match = regex.exec(str)) !== null) {\n                        lastMatchIndex = match.index;\n                        lastMatchLength = match[0].length;\n                        // Prevent infinite loop for zero-width matches\n                        if (regex.lastIndex === match.index) regex.lastIndex++;\n                    }\n\n                    return lastMatchIndex !== -1 ? { index: lastMatchIndex, length: lastMatchLength } : null;\n                }\n\n                // Flag to track if we found a match in the current node\n                let foundMatchInCurrentNode = false;\n\n                // First, check the current node with respect to the current selection\n                const node = selectedNode;\n                let headString = data[node.gnx]?.headString || \"\";\n                let body = data[node.gnx]?.bodyString || \"\";\n\n                // Get current selection info\n                const selection = window.getSelection();\n                let headlineOffset = Infinity;\n                let bodyOffset = Infinity;\n\n                if (selection.rangeCount > 0) {\n                    const range = selection.getRangeAt(0);\n                    if (selectedLabelElement && selectedLabelElement.contains(range.commonAncestorContainer)) {\n                        // Selection is in headline\n                        headlineOffset = range.startOffset;\n                    } else if (BODY_PANE.contains(range.commonAncestorContainer)) {\n                        // Selection is in body\n                        bodyOffset = range.startOffset;\n                    }\n                }\n\n                const currentFocus = findFocus();\n\n                // Check current node based on focus\n                if (currentFocus === 2 && searchInBody && body) {\n                    // If focused in body, check body first\n                    const limitedBody = body.substring(0, bodyOffset);\n                    const match = findLastMatch(limitedBody);\n\n                    if (match) {\n                        if (markFind && !marked.has(node.gnx)) {\n                            marked.add(node.gnx);\n                            if (data[node.gnx]) {\n                                data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                            }\n                        }\n\n                        selectAndOrToggleAndRedraw(node);\n                        BODY_PANE.focus();\n                        setTimeout(() => {\n                            highlightMatchInBody(match.index, match.index + match.length);\n                        });\n                        return;\n                    }\n                }\n\n                // Check headline if appropriate\n                if (searchInHeadlines && headString) {\n                    const limitedHeadline = currentFocus !== 2 ? headString.substring(0, headlineOffset) : headString;\n                    const match = findLastMatch(limitedHeadline);\n\n                    if (match) {\n                        if (markFind && !marked.has(node.gnx)) {\n                            marked.add(node.gnx);\n                            if (data[node.gnx]) {\n                                data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                            }\n                        }\n\n                        selectAndOrToggleAndRedraw(node);\n                        OUTLINE_PANE.focus();\n                        setTimeout(() => {\n                            highlightMatchInHeadline(match.index, match.index + match.length);\n                        });\n                        return;\n                    }\n                }\n\n                // Continue searching through previous nodes if no match was found in current node\n                let currentIndex = startIndex - 1;\n\n                while (currentIndex >= 0) {\n                    const node = allNodesInOrder[currentIndex];\n                    if (selectedRadioValue === 'nodeonly') {\n                        break; // Only search current node\n                    }\n                    if (selectedRadioValue === 'suboutline' && (initialFindNode !== node && isAncestorOf(initialFindNode, node) === false)) {\n                        break; // Reached outside suboutline of initialFindNode\n                    }\n                    let headString = data[node.gnx]?.headString || \"\";\n                    let body = data[node.gnx]?.bodyString || \"\";\n\n                    // In previous nodes, check body first (since we're going backward)\n                    if (searchInBody && body) {\n                        const match = findLastMatch(body);\n\n                        if (match) {\n                            if (markFind && !marked.has(node.gnx)) {\n                                marked.add(node.gnx);\n                                if (data[node.gnx]) {\n                                    data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                                }\n                            }\n\n                            selectAndOrToggleAndRedraw(node);\n                            BODY_PANE.focus();\n                            setTimeout(() => {\n                                highlightMatchInBody(match.index, match.index + match.length);\n                            });\n                            return;\n                        }\n                    }\n\n                    // Then check headline\n                    if (searchInHeadlines && headString) {\n                        const match = findLastMatch(headString);\n\n                        if (match) {\n                            if (markFind && !marked.has(node.gnx)) {\n                                marked.add(node.gnx);\n                                if (data[node.gnx]) {\n                                    data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                                }\n                            }\n\n                            selectAndOrToggleAndRedraw(node);\n                            OUTLINE_PANE.focus();\n                            setTimeout(() => {\n                                highlightMatchInHeadline(match.index, match.index + match.length);\n                            });\n                            return;\n                        }\n                    }\n                    currentIndex--;\n                }\n\n                let searchedParams = [];\n                if (searchInHeadlines) searchedParams.push('head');\n                if (searchInBody) searchedParams.push('body');\n                showToast(`Not found: (${searchedParams.join(\", \")}) ${searchText}`, 1500);\n\n            } catch (e) {\n                showToast('Invalid search pattern: ' + e.message, 2000);\n            }\n        }\n\n        function highlightMatchInHeadline(startIndex, endIndex) {\n            // Use the global selectedLabelElement which is already set after selectAndOrToggleAndRedraw\n            if (!selectedLabelElement) return;\n\n            // Find the first text node in the label element\n            let textNode = null;\n            for (const node of selectedLabelElement.childNodes) {\n                if (node.nodeType === Node.TEXT_NODE) {\n                    textNode = node;\n                    break;\n                }\n            }\n\n            if (!textNode) return;\n\n            try {\n                const range = document.createRange();\n                range.setStart(textNode, startIndex);\n                range.setEnd(textNode, endIndex);\n\n                const selection = window.getSelection();\n                selection.removeAllRanges();\n                selection.addRange(range);\n            } catch (e) {\n                console.error('Error setting headline selection:', e);\n            }\n        }\n\n        function highlightMatchInBody(startIndex, endIndex) {\n            // The body pane content is set directly as textContent, so it's a single text node\n            if (!BODY_PANE.firstChild || BODY_PANE.firstChild.nodeType !== Node.TEXT_NODE) return;\n\n            try {\n                const range = document.createRange();\n                range.setStart(BODY_PANE.firstChild, startIndex);\n                range.setEnd(BODY_PANE.firstChild, endIndex);\n\n                const selection = window.getSelection();\n                selection.removeAllRanges();\n                selection.addRange(range);\n            } catch (e) {\n                console.error('Error setting body selection:', e);\n            }\n        }\n\n        function findFocus() {\n            // Returns 1 if focus in outline-pane, 2 if in body-pane, 0 otherwise\n            if (document.activeElement === OUTLINE_PANE || OUTLINE_PANE.contains(document.activeElement)) {\n                return 1;\n            } else if (document.activeElement === BODY_PANE || BODY_PANE.contains(document.activeElement)) {\n                return 2;\n            }\n            return 0;\n        }\n\n        function initializeLayout() {\n            document.title = title; // Set the document title\n            const savedOutlineBodyRatio = getSavedMainRatio();\n            const savedOutlineFindRatio = getSavedSecondaryRatio();\n            if (savedOutlineBodyRatio != null) {\n                mainRatio = savedOutlineBodyRatio;\n            }\n            if (savedOutlineFindRatio != null) {\n                secondaryRatio = savedOutlineFindRatio;\n            }\n            updateMarkedButtonStates();\n            updateHoistButtonStates();\n            setupEventHandlers();\n            setupButtonFocusPrevention();\n        }\n\n        function setupConfigCheckboxes() {\n            SHOW_PREV_NEXT_MARK.addEventListener('change', updateButtonVisibility);\n            SHOW_TOGGLE_MARK.addEventListener('change', updateButtonVisibility);\n            SHOW_PREV_NEXT_HISTORY.addEventListener('change', updateButtonVisibility);\n            SHOW_HOIST_DEHOIST.addEventListener('change', updateButtonVisibility);\n            SHOW_LAYOUT_ORIENTATION.addEventListener('change', updateButtonVisibility);\n            SHOW_THEME_TOGGLE.addEventListener('change', updateButtonVisibility);\n            SHOW_NODE_ICONS.addEventListener('change', updateNodeIcons);\n            SHOW_COLLAPSE_ALL.addEventListener('change', updateButtonVisibility);\n            loadConfigPreferences();\n        }\n\n        function updateButtonVisibility() {\n            toggleButtonVisibility(NEXT_MARKED_BTN, PREV_MARKED_BTN, SHOW_PREV_NEXT_MARK.checked);\n            toggleButtonVisibility(TOGGLE_MARK_BTN, null, SHOW_TOGGLE_MARK.checked);\n            toggleButtonVisibility(NEXT_BTN, PREV_BTN, SHOW_PREV_NEXT_HISTORY.checked);\n            toggleButtonVisibility(HOIST_BTN, DEHOIST_BTN, SHOW_HOIST_DEHOIST.checked);\n            toggleButtonVisibility(LAYOUT_TOGGLE, null, SHOW_LAYOUT_ORIENTATION.checked);\n            toggleButtonVisibility(THEME_TOGGLE, null, SHOW_THEME_TOGGLE.checked);\n            toggleButtonVisibility(COLLAPSE_ALL_BTN, null, SHOW_COLLAPSE_ALL.checked);\n        }\n\n        function updateNodeIcons() {\n            HTML_ELEMENT.setAttribute('data-show-icons', SHOW_NODE_ICONS.checked ? 'true' : 'false');\n            renderTree(); // Re-render to apply icon changes\n        }\n\n        function toggleButtonVisibility(button1, button2, isVisible) {\n            if (button1) {\n                button1.classList.toggle('hidden-button', !isVisible);\n            }\n            if (button2) {\n                button2.classList.toggle('hidden-button', !isVisible);\n            }\n        }\n\n        function saveConfigPreferences() {\n            const selectedFindScope = document.querySelector('input[name=\"find-scope\"]:checked')?.value || 'entire';\n\n            const preferences = {\n                showPrevNextMark: SHOW_PREV_NEXT_MARK.checked,\n                showToggleMark: SHOW_TOGGLE_MARK.checked,\n                showPrevNextHistory: SHOW_PREV_NEXT_HISTORY.checked,\n                showHoistDehoist: SHOW_HOIST_DEHOIST.checked,\n                showLayoutOrientation: SHOW_LAYOUT_ORIENTATION.checked,\n                showThemeToggle: SHOW_THEME_TOGGLE.checked,\n                showNodeIcons: SHOW_NODE_ICONS.checked,\n                showCollapseAll: SHOW_COLLAPSE_ALL.checked,\n                // Find-pane options\n                findWholeWord: OPT_WHOLE.checked,\n                findIgnoreCase: OPT_IGNORECASE.checked,\n                findRegexp: OPT_REGEXP.checked,\n                findMark: OPT_MARK.checked,\n                findHeadline: OPT_HEADLINE.checked,\n                findBody: OPT_BODY.checked,\n                findScope: selectedFindScope\n            };\n            safeLocalStorageSet('configPreferences', JSON.stringify(preferences));\n        }\n\n        function loadConfigPreferences() {\n            const savedPrefs = safeLocalStorageGet('configPreferences');\n            if (savedPrefs) {\n                try {\n                    const prefs = JSON.parse(savedPrefs);\n                    SHOW_PREV_NEXT_MARK.checked = prefs.showPrevNextMark ?? false;\n                    SHOW_TOGGLE_MARK.checked = prefs.showToggleMark ?? false;\n                    SHOW_PREV_NEXT_HISTORY.checked = prefs.showPrevNextHistory ?? true;\n                    SHOW_HOIST_DEHOIST.checked = prefs.showHoistDehoist ?? false;\n                    SHOW_LAYOUT_ORIENTATION.checked = prefs.showLayoutOrientation ?? true;\n                    SHOW_THEME_TOGGLE.checked = prefs.showThemeToggle ?? true;\n                    SHOW_NODE_ICONS.checked = prefs.showNodeIcons ?? true;\n                    SHOW_COLLAPSE_ALL.checked = prefs.showCollapseAll ?? true;\n\n                    // Find-pane options\n                    OPT_WHOLE.checked = prefs.findWholeWord ?? OPT_WHOLE.checked;\n                    OPT_IGNORECASE.checked = prefs.findIgnoreCase ?? OPT_IGNORECASE.checked;\n                    OPT_REGEXP.checked = prefs.findRegexp ?? OPT_REGEXP.checked;\n                    OPT_MARK.checked = prefs.findMark ?? OPT_MARK.checked;\n                    OPT_HEADLINE.checked = prefs.findHeadline ?? OPT_HEADLINE.checked;\n                    OPT_BODY.checked = prefs.findBody ?? OPT_BODY.checked;\n\n                    // Set the find scope radio\n                    if (prefs.findScope) {\n                        const scopeRadio = document.getElementById('scope-' + prefs.findScope);\n                        if (scopeRadio) scopeRadio.checked = true;\n                    }\n\n                    updateButtonVisibility();\n                    updateNodeIcons();\n                } catch (e) {\n                    console.error('Error loading config preferences:', e);\n                }\n            } else {\n                updateButtonVisibility();\n                updateNodeIcons();\n            }\n        }\n\n        // Toast helper function\n        let __toastTimer = null;\n        function showToast(message, duration = 2000) {\n            if (!TOAST) return;\n            TOAST.textContent = message;\n            TOAST.hidden = false;\n            // Force reflow so the transition always runs when toggling\n            void TOAST.offsetWidth;\n            TOAST.classList.add('show');\n            if (__toastTimer) {\n                clearTimeout(__toastTimer);\n            }\n            __toastTimer = setTimeout(() => {\n                TOAST.classList.remove('show');\n                setTimeout(() => { TOAST.hidden = true; }, 220);\n                __toastTimer = null;\n            }, duration);\n        }\n\n        // Apply theme & layout before anything else to avoid flash of wrong theme\n        applyTheme(getCurrentTheme());\n        initializeLayout(); // gets ratios from localStorage and applies layout and theme\n        applyLayout(getCurrentLayout()); // flatRows will be null at this point so no render.\n        // Start everything once DOM is loaded\n        window.addEventListener('DOMContentLoaded', handleDOMContentLoaded);\n\n    </script>\n</body>\n\n</html>\n\"\"\"",
    "felix.20250921150949.1": "@language html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n@others\n\n</html>",
    "felix.20250921151054.1": "<head>\n    @others\n</head>\n\n",
    "felix.20250921151305.1": "<meta charset=\"UTF-8\">",
    "felix.20250921151315.1": "<title>Leo Document Viewer</title>",
    "felix.20250921151320.1": "<style>\n    :root {\n        /* light theme (default) */\n        --background-color: #ffffec;\n        --body-pane-color: #fff6f5;\n        --find-pane-color: #f9f9f9;\n        --resizer-color: #cae1ff;\n        --selected-bg: #cae1ff;\n        --ancestor-bg: #eef5ff;\n        --hover-bg: #dfecff;\n        --focus-outline: #0000ff;\n        --text-color: #000000;\n        --caret-dim-color: #888;\n        --find-text-color: #444;\n        --find-placeholder-color: #888;\n        --find-border-color: #a0a0a0;\n        --find-selection: #0078d7;\n        /* vertical layout (default) */\n        --main-direction: row;\n        --main-resizer-width: 5px;\n        --main-resizer-height: 100%;\n        --main-resizer-cursor: ew-resize;\n        --main-resizer-extension-width: 5px;\n        --main-resizer-extension-height: 100%;\n        --main-resizer-before-top: unset;\n        --main-resizer-before-left: -5px;\n        --main-resizer-after-right: -5px;\n        --main-resizer-after-bottom: unset;\n        --secondary-direction: column;\n        --secondary-height: 100%;\n        --secondary-resizer-width: 100%;\n        --secondary-resizer-height: 5px;\n        --secondary-resizer-cursor: ns-resize;\n        --secondary-resizer-extension-width: 100%;\n        --secondary-resizer-extension-height: 5px;\n        --secondary-resizer-before-top: -5px;\n        --secondary-resizer-before-left: unset;\n        --secondary-resizer-after-right: unset;\n        --secondary-resizer-after-bottom: -5px;\n        /* transitions */\n        --body-transition: unset;\n        --body-pane-transition: unset;\n        --find-pane-transition: unset;\n        /* configuration/find pane visibility */\n        --config-display: none;\n        --find-display: flex;\n    }\n\n    [data-show-config=\"true\"] {\n        --config-display: flex;\n        --find-display: none;\n    }\n\n    [data-transition=\"true\"] {\n        --body-transition: color 0.15s ease, background-color 0.15s ease;\n        --body-pane-transition: color 0.3s ease, background-color 0.3s ease;\n        --find-pane-transition: color 0.15s ease, background-color 0.15s ease;\n    }\n\n    [data-theme=\"dark\"] {\n        --background-color: #1e1e2e;\n        --body-pane-color: #2a2536;\n        --find-pane-color: #23202e;\n        --resizer-color: #454a6e;\n        --selected-bg: #454a6e;\n        --ancestor-bg: #2d3250;\n        --hover-bg: #3a3f5e;\n        --focus-outline: #7aa2f7;\n        --text-color: #cdd6f4;\n        --caret-dim-color: #999;\n        --find-text-color: #aeb6d1;\n        --find-placeholder-color: #5a699e;\n        --find-border-color: #81889e;\n        --find-selection: #3c54ce;\n    }\n\n    [data-layout=\"horizontal\"] {\n        --main-direction: column;\n        --main-resizer-width: 100%;\n        --main-resizer-height: 5px;\n        --main-resizer-cursor: ns-resize;\n        --main-resizer-extension-width: 100%;\n        --main-resizer-extension-height: 5px;\n        --main-resizer-before-top: -5px;\n        --main-resizer-before-left: unset;\n        --main-resizer-after-right: unset;\n        --main-resizer-after-bottom: -5px;\n        --secondary-direction: row;\n        --secondary-height: 100%;\n        --secondary-resizer-width: 5px;\n        --secondary-resizer-height: 100%;\n        --secondary-resizer-cursor: ew-resize;\n        --secondary-resizer-extension-width: 5px;\n        --secondary-resizer-extension-height: 100%;\n        --secondary-resizer-before-top: unset;\n        --secondary-resizer-before-left: -5px;\n        --secondary-resizer-after-right: -5px;\n        --secondary-resizer-after-bottom: unset;\n    }\n\n    /* Custom scrollbars */\n    * {\n        /* Firefox */\n        scrollbar-color: var(--resizer-color) transparent;\n    }\n\n    /* Chrome, Edge, Safari */\n    ::-webkit-scrollbar {\n        width: 5px;\n        height: 5px;\n    }\n\n    ::-webkit-scrollbar-track {\n        background: transparent;\n        border-radius: 5px;\n    }\n\n    ::-webkit-scrollbar-thumb {\n        background-color: var(--resizer-color);\n        border-radius: 5px;\n    }\n\n    ::-webkit-scrollbar-thumb:hover {\n        background-color: var(--hover-bg);\n    }\n\n    .icon0 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/></svg>');\n    }\n\n    .icon1 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n    }\n\n    .icon2 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/></svg>');\n    }\n\n    .icon3 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\">   <path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n    }\n\n    .icon4 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon5 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon6 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon7 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon8 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/></svg>');\n    }\n\n    .icon9 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n    }\n\n    .icon10 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/></svg>');\n    }\n\n    .icon11 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\n    }\n\n    .icon12 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon13 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon14 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    .icon15 {\n        background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\n    }\n\n    body {\n        margin: 0;\n        display: flex;\n        flex-direction: var(--main-direction);\n        height: 100vh;\n        background-color: var(--background-color);\n        color: var(--text-color);\n        transition: var(--body-transition)\n    }\n\n    body.dragging-main {\n        cursor: var(--main-resizer-cursor) !important;\n    }\n\n    body.dragging-secondary {\n        cursor: var(--secondary-resizer-cursor) !important;\n    }\n\n    #outline-pane {\n        position: relative;\n        white-space: nowrap;\n        padding-top: 6px;\n        overflow-x: hidden;\n        overflow-y: auto;\n        font-family: sans-serif;\n    }\n\n    #spacer {\n        position: relative;\n    }\n\n    #collapse-all-btn {\n        position: fixed;\n        z-index: 100;\n        opacity: 0;\n        transition: opacity 0.2s ease;\n        pointer-events: none;\n    }\n\n    #outline-pane:hover #collapse-all-btn {\n        opacity: 1;\n        pointer-events: auto;\n    }\n\n    .outline-icon {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        width: 16px;\n        height: 16px;\n    }\n\n    .outline-icon:hover svg {\n        transform: scale(1.1);\n        transition: transform 0.1s ease;\n    }\n\n    #main-resizer {\n        position: relative;\n        width: var(--main-resizer-width);\n        height: var(--main-resizer-height);\n        cursor: var(--main-resizer-cursor);\n        background-color: var(--resizer-color);\n        flex-shrink: 0;\n    }\n\n    #main-resizer::before,\n    #main-resizer::after {\n        content: \"\";\n        position: absolute;\n        height: var(--main-resizer-extension-height);\n        width: var(--main-resizer-extension-width);\n        cursor: var(--main-resizer-cursor);\n    }\n\n    #main-resizer::before {\n        top: var(--main-resizer-before-top);\n        left: var(--main-resizer-before-left)\n    }\n\n    #main-resizer::after {\n        right: var(--main-resizer-after-right);\n        bottom: var(--main-resizer-after-bottom)\n    }\n\n    #outline-find-container {\n        display: flex;\n        flex-direction: var(--secondary-direction);\n        height: var(--secondary-height);\n        overflow: hidden;\n    }\n\n    #secondary-resizer {\n        position: relative;\n        height: var(--secondary-resizer-height);\n        width: var(--secondary-resizer-width);\n        cursor: var(--secondary-resizer-cursor);\n        background-color: var(--resizer-color);\n        flex-shrink: 0;\n    }\n\n    #secondary-resizer::before,\n    #secondary-resizer::after {\n        content: \"\";\n        position: absolute;\n        width: var(--secondary-resizer-extension-width);\n        height: var(--secondary-resizer-extension-height);\n        cursor: var(--secondary-resizer-cursor);\n    }\n\n    #secondary-resizer::before {\n        top: var(--secondary-resizer-before-top);\n        left: var(--secondary-resizer-before-left);\n    }\n\n    #secondary-resizer::after {\n        bottom: var(--secondary-resizer-after-bottom);\n        right: var(--secondary-resizer-after-right);\n    }\n\n    #outline-pane,\n    #find-pane {\n        overflow-y: auto;\n        flex: 1 1 0;\n    }\n\n    #body-pane {\n        flex: 1;\n        padding: 1rem 0 0 1rem;\n        background-color: var(--body-pane-color);\n        overflow-y: auto;\n        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\n        white-space: pre-wrap;\n        transition: var(--body-pane-transition);\n    }\n\n    #outline-pane:focus,\n    #body-pane:focus,\n    #outline-pane:focus-visible,\n    #body-pane:focus-visible {\n        /* \n            Note: Outline will appear under the items positioned absolutely.\n            See pseudo-elements with \"z-index: -1\" that appear below this outline.\n         */\n        outline: 3px solid var(--focus-outline);\n        outline-offset: -3px;\n    }\n\n    .node-text:hover::before,\n    .selected>.node-text::before,\n    .ancestor>.node-text::before,\n    .initial-find>.node-text::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: -2px;\n        right: 0;\n        bottom: 0;\n        z-index: -1;\n        border-radius: 4px;\n    }\n\n    .selected>.node-text::before,\n    .selected>.node-text:hover::before {\n        background-color: var(--selected-bg);\n    }\n\n    .ancestor>.node-text::before {\n        background-color: var(--ancestor-bg);\n    }\n\n    .node-text:hover::before {\n        background-color: var(--hover-bg);\n    }\n\n    .initial-find>.node-text::before {\n        border: 1.5px solid var(--find-selection);\n        border-style: dotted;\n    }\n\n    .node {\n        position: absolute;\n        white-space: nowrap;\n        cursor: pointer;\n        display: grid;\n        grid-template-columns: 1em 1fr;\n        align-items: start;\n    }\n\n    body.dragging-main .node {\n        cursor: var(--main-resizer-cursor);\n    }\n\n    body.dragging-secondary .node {\n        cursor: var(--secondary-resizer-cursor);\n    }\n\n    .caret {\n        grid-column: 1;\n        display: inline-block;\n        width: 32px;\n        height: 26px;\n        position: relative;\n        left: -16px;\n        user-select: none;\n    }\n\n    .node-text {\n        position: relative;\n        background-repeat: no-repeat;\n        background-position-x: 2px;\n        background-position-y: 1px;\n        background-size: 19px 19px;\n        grid-column: 2;\n        display: block;\n        padding: 2px 0 2px 26px;\n        margin-right: 1.2rem;\n        border-radius: 4px;\n    }\n\n    /* Special handling for node icons */\n    [data-show-icons=\"false\"] .node-text {\n        background-image: none !important;\n        padding-left: 4px !important;\n        /* Reduce padding when icons are hidden */\n    }\n\n    .caret::after {\n        display: inline-block;\n        position: relative;\n        left: 16px;\n        transform-origin: 50% 50%;\n        transition: transform 160ms cubic-bezier(.2, .9, .3, 1), color 120ms;\n    }\n\n    .caret[data-expanded=\"true\"]::after {\n        content: \"‚ùØ\";\n        transform: rotate(90deg);\n    }\n\n    .caret[data-expanded=\"false\"]::after {\n        content: \"‚ùØ\";\n        transform: rotate(0deg);\n        color: var(--caret-dim-color);\n    }\n\n    .caret.toggled[data-expanded=\"true\"]::after {\n        content: \"‚ùØ\";\n        transform: rotate(90deg);\n        animation: rotateOpen 120ms ease-out;\n    }\n\n    .caret.toggled[data-expanded=\"false\"]::after {\n        content: \"‚ùØ\";\n        transform: rotate(0deg);\n        color: var(--caret-dim-color);\n        animation: rotateClose 120ms ease-out;\n    }\n\n    @keyframes rotateOpen {\n        from {\n            transform: rotate(0deg);\n            color: var(--caret-dim-color);\n        }\n\n        to {\n            transform: rotate(90deg);\n            color: inherit;\n        }\n    }\n\n    @keyframes rotateClose {\n        from {\n            transform: rotate(90deg);\n            color: inherit;\n        }\n\n        to {\n            transform: rotate(0deg);\n            color: var(--caret-dim-color);\n        }\n    }\n\n    /* buttons */\n    #button-container {\n        position: fixed;\n        top: 12px;\n        right: 12px;\n        display: flex;\n        flex-direction: row-reverse;\n        gap: 8px;\n        z-index: 1000;\n    }\n\n    .action-button {\n        width: 32px;\n        height: 32px;\n        border-radius: 50%;\n        background: var(--resizer-color);\n        color: var(--text-color);\n        border: 2px solid var(--text-color);\n        cursor: pointer;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font-size: 18px;\n        line-height: 1;\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n        z-index: 1000;\n        overflow: hidden;\n        transition: transform 0.2s ease;\n        user-select: none;\n    }\n\n    .action-button:hover {\n        transform: scale(1.1);\n    }\n\n    .action-button:disabled {\n        opacity: 0.4;\n        cursor: default;\n        box-shadow: none;\n        border-color: var(--caret-dim-color);\n    }\n\n    .action-button:disabled:hover {\n        transform: none;\n    }\n\n    .svg-icon {\n        position: relative;\n        top: 0;\n        left: 0;\n        transition: top 0.3s ease, left 0.3s ease, transform 0.3s ease;\n    }\n\n    #dehoist-btn:active #dehoist-icon {\n        top: -10px;\n    }\n\n    #hoist-btn:active #hoist-icon {\n        top: 10px;\n    }\n\n    #prev-btn:active #prev-icon {\n        left: -10px;\n    }\n\n    #next-btn:active #next-icon {\n        left: 10px;\n    }\n\n    #toggle-icon {\n        position: relative;\n        top: 0;\n        transition: top 0.3s ease;\n    }\n\n    #theme-toggle:active #toggle-icon {\n        top: 25px;\n    }\n\n    #layout-icon {\n        position: relative;\n        top: 0;\n    }\n\n    [data-layout=\"horizontal\"] #layout-icon {\n        transform: rotate(90deg);\n    }\n\n    [data-transition=\"true\"] #layout-icon {\n        transition: transform 0.3s ease;\n    }\n\n    .svg-icon svg {\n        display: block;\n        width: 20px;\n        height: 20px;\n    }\n\n    .action-button:disabled:active #toggle-icon,\n    .action-button:disabled:active #dehoist-icon,\n    .action-button:disabled:active #hoist-icon {\n        top: 0 !important;\n    }\n\n    .action-button:disabled:active #prev-icon,\n    .action-button:disabled:active #next-icon {\n        left: 0 !important;\n    }\n\n    #toggle-mark-btn:active #toggle-mark-icon {\n        transform: scale(0.7);\n    }\n\n    #prev-marked-btn:active #prev-marked-icon {\n        left: -10px;\n    }\n\n    #next-marked-btn:active #next-marked-icon {\n        left: 10px;\n    }\n\n    .hidden-button {\n        display: none !important;\n    }\n\n    /* find pane */\n    #find-pane {\n        scrollbar-gutter: stable;\n        font-family: sans-serif;\n        padding: 0.5rem 0 0 0.5rem;\n        overflow-x: hidden;\n        background-color: var(--find-pane-color);\n        position: relative;\n        transition: var(--find-pane-transition);\n        container-type: inline-size;\n        container-name: find-pane;\n    }\n\n    #find-controls,\n    #config-controls {\n        gap: 0.5rem;\n        align-items: flex-start;\n        flex-wrap: wrap;\n    }\n\n    @container find-pane (min-width: 450px) {\n        #config-controls {\n            justify-content: center;\n        }\n    }\n\n    #config-btn {\n        position: fixed;\n        z-index: 2001;\n        cursor: pointer;\n        font-size: 20px;\n        opacity: 0.6;\n        transition: transform 0.2s ease, opacity 0.2s ease;\n        text-shadow: 0 3px 3px rgba(0, 0, 0, 0.4);\n        user-select: none;\n    }\n\n    #config-btn:hover {\n        transform: scale(1.2);\n        opacity: 1;\n    }\n\n    #find-controls {\n        padding-top: 0.5rem;\n        display: var(--find-display);\n    }\n\n    #config-controls {\n        padding-top: 0;\n        display: var(--config-display);\n    }\n\n    .config-title {\n        cursor: default;\n        user-select: none;\n        width: 100%;\n        text-align: center;\n        font-weight: bold;\n        margin: 0;\n        font-size: 1em;\n        color: var(--find-text-color);\n    }\n\n    .config-title svg {\n        vertical-align: middle;\n    }\n\n    .sub-title {\n        width: 100%;\n        text-align: center;\n        margin: 0;\n        color: var(--caret-dim-color);\n        font-style: italic;\n        font-size: 0.9em;\n        cursor: default;\n        user-select: none;\n    }\n\n    #find-pane .config-col.shortcuts {\n        list-style: none;\n        padding: 0;\n        margin: -5px 0 0 0;\n        font-size: 0.8em;\n        color: var(--find-text-color);\n        gap: 0;\n        min-width: 285px;\n        cursor: default;\n        user-select: none;\n    }\n\n    #find-pane .config-col.shortcuts li {\n        padding: 0.25rem 0.5rem;\n        display: flex;\n        align-items: center;\n    }\n\n    #find-pane .config-col.shortcuts kbd {\n        display: inline-block;\n        padding: 0.1rem 0.4rem;\n        margin: 0 0.2rem;\n        font-family: monospace;\n        font-size: 0.9em;\n        line-height: 1.4;\n        color: var(--text-color);\n        background-color: var(--resizer-color);\n        border: 1px solid var(--find-border-color);\n        border-radius: 3px;\n        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);\n    }\n\n    .kbd-spacer {\n        display: inline-block;\n        width: 100px;\n    }\n\n    #find-pane .find-col,\n    #find-pane .config-col {\n        display: flex;\n        flex-direction: column;\n        gap: 0.35rem;\n        min-width: 110px;\n    }\n\n    #find-pane .find-col label,\n    #find-pane .config-col label {\n        display: inline-flex;\n        align-items: center;\n        gap: 0.5rem;\n        cursor: pointer;\n        user-select: none;\n        font-size: 0.8em;\n        color: var(--find-text-color);\n    }\n\n    .config-col label {\n        padding-left: 0.5rem;\n    }\n\n    #find-pane input[type=\"checkbox\"],\n    #find-pane input[type=\"radio\"] {\n        flex-shrink: 0;\n        width: 16px;\n        height: 16px;\n        margin: 0;\n    }\n\n    #find-input {\n        width: 100%;\n        /* max-width: 260px; */\n        box-sizing: border-box;\n        padding: 0.4rem 0.5rem;\n        margin: 0;\n        border-radius: 3px;\n        border: 1px solid var(--find-border-color);\n        background: transparent;\n        color: var(--find-text-color);\n        font-family: sans-serif;\n        display: var(--find-display)\n    }\n\n    #find-input::placeholder {\n        color: var(--find-placeholder-color);\n    }\n\n    input[type=\"checkbox\"] {\n        appearance: none;\n        width: 20px;\n        height: 20px;\n        border: 1px solid var(--find-border-color);\n        border-radius: 3px;\n        background-color: var(--find-pane-color);\n        position: relative;\n    }\n\n    input[type=\"checkbox\"]:checked::after {\n        content: \"\";\n        position: absolute;\n        left: 4px;\n        top: -2px;\n        width: 4px;\n        height: 12px;\n        border: solid var(--find-border-color);\n        border-width: 0 2px 2px 0;\n        transform: rotate(45deg);\n    }\n\n    input[type=\"radio\"] {\n        appearance: none;\n        width: 20px;\n        height: 20px;\n        border: 1px solid var(--find-border-color);\n        border-radius: 50%;\n        background-color: var(--find-pane-color);\n        position: relative;\n    }\n\n    input[type=\"radio\"]:checked::after {\n        content: \"\";\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        width: 8px;\n        height: 8px;\n        transform: translate(-50%, -50%);\n        background-color: var(--find-text-color);\n        border-radius: 50%;\n    }\n\n    input[type=\"radio\"]:focus:checked::after,\n    input[type=\"radio\"]:focus-visible:checked::after {\n        background-color: var(--find-selection);\n    }\n\n    input[type=\"checkbox\"]:focus:checked::after,\n    input[type=\"checkbox\"]:focus-visible:checked::after {\n        border: solid var(--find-selection);\n        border-width: 0 2px 2px 0;\n    }\n\n    #find-pane input:focus,\n    #find-pane input:focus-visible {\n        border-color: var(--find-selection);\n        outline: 2px solid var(--find-selection);\n        outline-offset: -1px;\n    }\n\n    a {\n        color: var(--caret-dim-color);\n        text-decoration: underline;\n    }\n\n    a:hover {\n        color: var(--find-text-color);\n    }\n\n    .footer {\n        margin-bottom: 1rem;\n    }\n\n    /* toast */\n    #toast {\n        position: fixed;\n        top: 16px;\n        left: 50%;\n        transform: translateX(-50%) translateY(-10px);\n        background: var(--body-pane-color);\n        color: var(--find-text-color);\n        padding: 8px 12px;\n        border-radius: 6px;\n        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);\n        opacity: 0;\n        pointer-events: none;\n        transition: opacity 180ms ease, transform 180ms ease;\n        z-index: 2000;\n        font-family: sans-serif;\n        font-size: 13px;\n        white-space: pre;\n    }\n\n    #toast.show {\n        opacity: 1;\n        transform: translateX(-50%) translateY(0);\n        pointer-events: auto;\n    }\n</style>",
    "felix.20250921151110.1": "<body>\n    @others\n</body>",
    "felix.20250921152808.1": "<!--\n    * Layout *\n    The body element is split in two (outline-find-container and body-pane) by the main-resizer.\n    The outline-find-container is split in two (outline-pane and find-pane) by the secondary-resizer.\n    So in total, there are three panes and two resizers. The rest are just floating buttons which are not part of the layout.\n-->\n<div id=\"outline-find-container\">\n    <div id=\"outline-pane\" tabindex=\"0\">\n        <div id=\"spacer\"></div>\n        <div id=\"collapse-all-btn\" class=\"outline-icon\" title=\"Collapse All\" role=\"button\"\n            aria-label=\"Collapse All\">\n            <svg width=\"16\" height=\"16\" fill=\"currentColor\">\n                <path\n                    d=\"M 6 2 L 5 3 L 5 5 L 3 5 L 2 6 L 2 13 L 3 14 L 10 14 L 11 13 L 11 11 L 13 11 L 14 10 L 14 3 L 13 2 L 6 2 z M 6 3 L 13 3 L 13 10 L 11 10 L 11 6 L 10 5 L 6 5 L 6 3 z M 3 6 L 10 6 L 10 13 L 3 13 L 3 6 z M 4 9 L 4 10 L 9 10 L 9 9 L 4 9 z \"\n                    style=\"fill:var(--find-border-color);\" />\n            </svg>\n        </div>\n    </div>\n    <div id=\"secondary-resizer\"></div>\n    <div id=\"find-pane\">\n        <input id=\"find-input\" type=\"text\" autocomplete=\"off\" placeholder=\"&lt;find pattern here&gt;\"\n            title=\"Ctrl+F: Search | F3/F2: Next/Prev\" aria-label=\"Find pattern\">\n        <div id=\"find-controls\" role=\"region\" aria-label=\"Find options\">\n            <div class=\"find-col\" aria-label=\"Search options\">\n                <label for=\"opt-whole\">\n                    <input id=\"opt-whole\" type=\"checkbox\" name=\"find-option\" />\n                    Whole Word\n                </label>\n                <label for=\"opt-ignorecase\">\n                    <input id=\"opt-ignorecase\" type=\"checkbox\" name=\"find-option\" checked />\n                    Ignore Case\n                </label>\n                <label for=\"opt-regexp\">\n                    <input id=\"opt-regexp\" type=\"checkbox\" name=\"find-option\" />\n                    Regexp\n                </label>\n                <label for=\"opt-mark\">\n                    <input id=\"opt-mark\" type=\"checkbox\" name=\"find-option\" />\n                    Mark Finds\n                </label>\n            </div>\n            <div class=\"find-col\" role=\"radiogroup\" aria-label=\"Search scope\">\n                <label for=\"scope-entire\">\n                    <input id=\"scope-entire\" type=\"radio\" name=\"find-scope\" value=\"entire\" checked />\n                    Entire Outline\n                </label>\n                <label for=\"scope-suboutline\">\n                    <input id=\"scope-suboutline\" type=\"radio\" name=\"find-scope\" value=\"suboutline\" />\n                    Suboutline Only\n                </label>\n                <label for=\"scope-node\">\n                    <input id=\"scope-node\" type=\"radio\" name=\"find-scope\" value=\"node\" />\n                    Node Only\n                </label>\n                <label for=\"opt-headline\">\n                    <input id=\"opt-headline\" type=\"checkbox\" name=\"find-target\" checked />\n                    Search Headline\n                </label>\n                <label for=\"opt-body\">\n                    <input id=\"opt-body\" type=\"checkbox\" name=\"find-target\" checked />\n                    Search Body\n                </label>\n            </div>\n        </div>\n        <span id=\"config-btn\" aria-label=\"Configuration\" title=\"Configuration\">‚öôÔ∏è</span>\n        <div id=\"config-controls\" role=\"region\" aria-label=\"Configuration settings\">\n            <span class=\"config-title\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" height=\"32\" width=\"32\" viewBox=\"0 0 16 16\">\n                    <path d=\"M2.875 1.21h10.566v8.482H2.875z\" fill=\"#7c2504\" />\n                    <path\n                        d=\"M11.093 1.21c-1.14.782-1.827 2.105-1.828 3.523 0 1.747 1.023 3.246 2.482 3.89v6.021h1.694V1.21zm-8.218 0V14.88h1.713V9.009a4.073 4.225 0 003.167-4.115A4.073 4.225 0 005.673 1.21z\"\n                        fill=\"#b04620\" />\n                    <path\n                        d=\"M6.35 6.339c.12.188.21.425.174.645-.245.565-.76 1.076-1.191 1.44-.73.668-1.442.894-2.433.993V4.002C4 4.79 5.58 5.269 6.35 6.339z\"\n                        fill=\"#c96b4b\" />\n                    <path\n                        d=\"M4.332 8.389c-.158 0-.79.316-.79.316l-.65.561h-.07l-.034 3.3.333.28.562-.105c.37-.073.72-.394 1.106-.368 0 0-.368.375-.457.614-.177.595-.124 1.405.334 1.79.25.201.612.202.93.246 1.464-.037 4.222.01 5.74.035.626-.22.74-.879.841-1.422.07-.409.049-.903-.193-1.21-.215-.265-.877-.527-.877-.527s1.117.332 1.68.482c.2.054.601.15.601.15l.123-3.844-1.035-.298-1.176.07c-1.934.446-3.108.225-4.914.245l-1.053-.28s-.843-.035-1-.035z\"\n                        fill=\"#e4dcc8\" />\n                    <path\n                        d=\"M4.708 2.514c-.947.022-1.475.03-1.808 1.194-.061.43.13.923.439 1.228.415.386 1.612.462 2.264.738.249.037.546.14.755 0 .277-.202.345-.987.473-1.37.003-.511-.243-1.192-.649-1.597-.477-.294-.98-.212-1.474-.193zm7.065.1c-.2.002-.405.024-.613.036-.518-.066-.748.086-.983.526-.343.738-.604 2.514.21 2.878.915.34 1.406-.481 2.001-.824.271-.149.585-.198.878-.299.049-1.108.161-1.483-.51-2.018-.322-.249-.648-.301-.983-.298z\"\n                        fill=\"#f9f2b3\" />\n                    <path\n                        d=\"M2.49.713V10l-1.516.143a.334.334 0 10.063.666l1.453-.138v.59l-1.483.288a.334.334 0 10.127.656l1.356-.263v3.349H13.88v-4.025h1.032a.334.334 0 100-.67h-1.032v-.64l1.054-.108a.334.334 0 10-.067-.665l-.987.101V.713H2.49zm.905.905h9.579v2.411a1.607 1.607 0 00-.088-.224c-.315-.63-.738-.878-1.277-.857-.636.001-1.105.415-1.342 1.009-.152.398-.113.704-.09 1.082.016.24.4.593.692.537.453-.088 1.18-.482 1.757-.765.18-.088.289-.19.348-.303v4.869l-2.427.246a.334.334 0 10.067.665l2.36-.24v.549h-2.405a.334.334 0 100 .669h2.405v3.12H3.395v-.677c.117.087.348.15.436.11.33-.153.357-.46.749-.83.182-.171.323-.42.599-.562.246-.126.727-.052 1.452-.207 1.346-.232 2.858-.122 3.97.085.707.134.891.457 1.033.776.11.248.07.353.247.558.137.16.505.353.716.169.168-.147 0-.502.182-.682.204-.204.28-.442.007-.745-.902-.485-1.542-.586-2.66-.737-.199-.02-.316-.245-.461-.38-.345-.32-.675-.483-1.103-.532.016-.055.037-.204.068-.244.695-.897 1.659-1.467 2.392-1.634.273-.062.157-.392.093-.431-.145-.088-.331-.093-.5-.093-.319.001-.633.08-.95.098-.952.054-1.783.082-2.651.006-.287-.025-.576-.058-.864-.046-.463.02-.554.254-.43.598.045.128.579.135.84.272.423.22.632.51 1.103 1.097.058.071.126.137.167.218.023.046.023.1.03.15-.514.002-.712.127-1.025.46-.363.38-.283.403-1.243.553-.22.034-.458.033-.678.069-.413.067-1.056.097-1.375.472-.062.073-.1.14-.143.208v-.719l2.476-.48a.334.334 0 10-.128-.657l-2.348.456v-.5l2.445-.231a.334.334 0 10-.063-.666l-2.382.225v-5.62c.2.094.516.16.657.221.442.194.737.484 1.025.634.18.094.866.282 1.016.147.222-.2.262-1.117.074-1.538a2.12 2.12 0 00-.651-.854c-.09-.072-.43-.153-.68-.148-.25.004-.556.053-.711.091-.315.079-.473.259-.683.505-.012.012-.031.05-.047.076z\"\n                        fill=\"#1c0e01\" />\n                    <path\n                        d=\"M4.487 3.186c-.11.182-.05.382.062.533.094.125.222.226.36.298.222.11.36.162.484-.062.151-.264.091-.52-.112-.72-.23-.204-.581-.277-.794-.05zm7 .26c-.326.03-.478.33-.472.633a.91.91 0 00.162.385c.247-.037.604-.197.769-.36.093-.133.21-.369.149-.509-.152-.191-.403-.18-.608-.149z\"\n                        fill=\"#fff\" />\n                </svg>\n                Leo Outline Viewer </span>\n            <span class=\"sub-title\">Visible Controls</span>\n            <div class=\"config-col\" aria-label=\"Config options\">\n                <label for=\"show-prev-next-mark\">\n                    <input id=\"show-prev-next-mark\" type=\"checkbox\" name=\"config-option\" />\n                    Previous/Next Marked\n                </label>\n                <label for=\"show-toggle-mark\">\n                    <input id=\"show-toggle-mark\" type=\"checkbox\" name=\"config-option\" />\n                    Mark/Unmark\n                </label>\n                <label for=\"show-prev-next-history\">\n                    <input id=\"show-prev-next-history\" type=\"checkbox\" name=\"config-option\" checked />\n                    Previous/Next History\n                </label>\n                <label for=\"show-hoist-dehoist\">\n                    <input id=\"show-hoist-dehoist\" type=\"checkbox\" name=\"config-option\" />\n                    Hoist/De-hoist\n                </label>\n            </div>\n            <div class=\"config-col\" aria-label=\"Config options\">\n                <label for=\"show-layout-orientation\">\n                    <input id=\"show-layout-orientation\" type=\"checkbox\" name=\"config-option\" checked />\n                    Layout Orientation\n                </label>\n                <label for=\"show-theme-toggle\">\n                    <input id=\"show-theme-toggle\" type=\"checkbox\" name=\"config-option\" checked />\n                    Dark/Light Theme\n                </label>\n                <label for=\"show-node-icons\">\n                    <input id=\"show-node-icons\" type=\"checkbox\" name=\"config-option\" checked />\n                    Node Icons\n                </label>\n                <label for=\"show-collapse-all\">\n                    <input id=\"show-collapse-all\" type=\"checkbox\" name=\"config-option\" checked />\n                    Collapse All\n                </label>\n                <!-- Future possible options: -->\n                <!-- <label for=\"show-chapters\">\n                    <input id=\"show-chapters\" type=\"checkbox\" name=\"config-option\" />\n                    Chapters\n                </label> -->\n            </div>\n            <span class=\"sub-title\">Keyboard Shortcuts</span>\n            <ul class=\"config-col shortcuts\">\n                <li><span class=\"kbd-spacer\"><kbd>Arrows</kbd></span> ‚Äî Navigate Outline</li>\n                <li><span class=\"kbd-spacer\"><kbd>Alt</kbd>+<kbd>Arrows</kbd></span> ‚Äî Navigate from Body Pane</li>\n                <li><span class=\"kbd-spacer\"><kbd>Ctrl</kbd>+<kbd>F</kbd></span> ‚Äî Find‚Ä¶</li>\n                <li><span class=\"kbd-spacer\"><kbd>F2</kbd>/<kbd>F3</kbd></span> ‚Äî Previous/Next Match</li>\n                <li><span class=\"kbd-spacer\"><kbd>Ctrl</kbd>+<kbd>M</kbd></span> ‚Äî Mark Node</li>\n                <li><span class=\"kbd-spacer\"><kbd>Alt</kbd>+<kbd>-</kbd></span> ‚Äî Collapse All</li>\n            </ul>\n            <span class=\"sub-title footer\">\n                <a href=\"https://leo-editor.github.io/leo-editor/\" target=\"_blank\">Leo Editor</a>\n                <span>Outline Viewer - 1.0.1 - Made by</span>\n                <a href=\"https://github.com/boltex\" target=\"_blank\">F√©lix</a>\n            </span>\n        </div>\n    </div>\n</div>\n<div id=\"main-resizer\"></div>\n<div id=\"body-pane\" tabindex=\"0\" contenteditable=\"plaintext-only\" spellcheck=\"false\"></div>\n<div id=\"button-container\">\n    <button tabindex=\"-1\" id=\"theme-toggle\" class=\"action-button\" aria-label=\"Toggle dark/light mode\"><span\n            id=\"toggle-icon\">üåì</span></button>\n    <button tabindex=\"-1\" id=\"layout-toggle\" class=\"action-button\" aria-label=\"Toggle layout orientation\"><span\n            id=\"layout-icon\">üìê</span></button>\n    <button tabindex=\"-1\" id=\"dehoist-btn\" class=\"action-button\" aria-label=\"De-hoist\" title=\"De-hoist\" disabled>\n        <span class=\"svg-icon\" id=\"dehoist-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 17 17\">\n                <path\n                    d=\"m 9.717,5.896 0.701,1.249 h 3.238 v 6.494 H 2.344 V 9.3649687 L 1.096,10.038969 V 14.896 h 13.808 v -9 z M 3.198,0.844 1.733,8.267 4.326,6.865 6.23,10.258 9.687,8.388 7.78,4.997 10.374,3.596 Z\"\n                    style=\"fill:var(--find-text-color);\" />\n            </svg>\n        </span>\n    </button>\n    <button tabindex=\"-1\" id=\"hoist-btn\" class=\"action-button\" aria-label=\"Hoist\" title=\"Hoist\">\n        <span class=\"svg-icon\" id=\"hoist-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 17 17\">\n                <path\n                    d=\"M 7.907,10.33 3.089,4.496 h 2.947 l 0.062,-3.89 3.93,0.002 -0.065,3.89 2.948,-0.001 z M 1.096,5.896 v 9 h 13.808 v -9 h -0.596094 l -1.07,1.249 H 13.656 v 6.494 H 2.344 V 7.145 h 0.4117139 l -1.031,-1.249 z\"\n                    style=\"fill:var(--find-text-color);\" />\n            </svg>\n        </span>\n    </button>\n    <button tabindex=\"-1\" id=\"next-btn\" class=\"action-button\" aria-label=\"Goto Next\" title=\"Goto Next\" disabled>\n        <span class=\"svg-icon\" id=\"next-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                <polygon points=\"14,10 6,3 6,17\" fill=\"#494\" />\n            </svg>\n        </span>\n    </button>\n    <button tabindex=\"-1\" id=\"prev-btn\" class=\"action-button\" aria-label=\"Goto Previous\" title=\"Goto Previous\"\n        disabled>\n        <span class=\"svg-icon\" id=\"prev-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                <polygon points=\"6,10 14,3 14,17\" fill=\"#494\" />\n            </svg>\n        </span>\n    </button>\n    <button tabindex=\"-1\" id=\"next-marked-btn\" class=\"action-button\" aria-label=\"Go to Next Marked Node\"\n        title=\"Go to Next Marked Node\" disabled>\n        <span class=\"svg-icon\" id=\"next-marked-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                <polygon points=\"14,10 6,3 6,17\" fill=\"#cb1919\" />\n            </svg>\n        </span>\n    </button>\n    <button tabindex=\"-1\" id=\"toggle-mark-btn\" class=\"action-button\" aria-label=\"Toggle Mark\" title=\"Toggle Mark\">\n        <span class=\"svg-icon\" id=\"toggle-mark-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"1.5 1 13 13\">\n                <path\n                    d=\"m 5.0855,2.17 c -0.532,0 -0.73,0.196 -0.73,0.728 v 10.933 l 3.645,-2.253 3.644,2.253 V 2.898 c 0,-0.532 -0.197,-0.729 -0.463,-0.7285 z m 3.906,4.088 0.525,1.574 -0.146,0.124 -1.37,-0.976 -1.37,0.976 -0.146,-0.124 0.525,-1.574 -1.356,-0.991 0.066,-0.168 1.676,-0.022 0.51,-1.574 h 0.182 l 0.51,1.574 1.677,0.022 0.08813,0.129125 z\"\n                    style=\"fill:#cb1919;\" />\n            </svg>\n        </span>\n    </button>\n    <button tabindex=\"-1\" id=\"prev-marked-btn\" class=\"action-button\" aria-label=\"Go to Previous Marked Node\"\n        title=\"Go to Previous Marked Node\" disabled>\n        <span class=\"svg-icon\" id=\"prev-marked-icon\">\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\n                <polygon points=\"6,10 14,3 14,17\" fill=\"#cb1919\" />\n            </svg>\n        </span>\n    </button>\n</div>\n<div id=\"toast\" role=\"status\" aria-live=\"polite\" hidden></div>",
    "felix.20250921152833.1": "@language javascript\n<script>\n    @others\n</script>",
    "felix.20250921155000.1": "/* Start of data */\nconst title = \"Virtual Tree View Demo 2\"; // Also used as key for localstorage save/restore of expanded and marked sets.\nconst genTimestamp = \"1234567890\"; // Change this to force reload of saved localstorage data.\nconst tree = {\n    \"gnx\": 0,\n    \"children\": [\n        {\n            \"gnx\": 1\n        },\n        {\n            \"gnx\": 2,\n            \"children\": [\n                {\n                    \"gnx\": 3,\n                    \"children\": [\n                        {\n                            \"gnx\": 4,\n                            \"children\": [\n                                {\n                                    \"gnx\": 5\n                                }\n                            ]\n                        }\n                    ]\n                },\n                {\n                    \"gnx\": 3\n                },\n                {\n                    \"gnx\": 6\n                },\n                {\n                    \"gnx\": 7\n                }\n            ]\n        },\n        {\n            \"gnx\": 8,\n            \"children\": [\n                {\n                    \"gnx\": 9\n                },\n                {\n                    \"gnx\": 10\n                },\n                {\n                    \"gnx\": 11\n                }\n            ]\n        }\n    ]\n};\nconst data = {\n    \"1\": {\n        \"headString\": \"first node no body\",\n        \"bodyString\": \"\"\n    },\n    \"2\": {\n        \"headString\": \"second node\",\n        \"bodyString\": \"Some body content\\nmultiple lines\\n\\nend of first body\"\n    },\n    \"3\": {\n        \"headString\": \"First child clone\",\n        \"bodyString\": \"Some child content\"\n    },\n    \"4\": {\n        \"headString\": \"Child of clone\",\n        \"bodyString\": \"Body of the child of a clone!\"\n    },\n    \"5\": {\n        \"headString\": \"Also has child!\",\n        \"bodyString\": \"Yep, child of clone also has child!\\n\"\n    },\n    \"6\": {\n        \"headString\": \"trailing newlines\",\n        \"bodyString\": \"inside other at same level\\n\\n\"\n    },\n    \"7\": {\n        \"headString\": \"last same level\",\n        \"bodyString\": \"Some body text\"\n    },\n    \"8\": {\n        \"headString\": \"third top node no body\",\n        \"bodyString\": \"\"\n    },\n    \"9\": {\n        \"headString\": \"third top node child 1\",\n        \"bodyString\": \"Some text in child 1\\nblabla\\n\"\n    },\n    \"10\": {\n        \"headString\": \"third top node child 2\",\n        \"bodyString\": \"Bla blabla bla,\\nbla blablabla bla.\"\n    },\n    \"11\": {\n        \"headString\": \"third top node child 3\",\n        \"bodyString\": \"Last node of the tree's natural tree order.\\n\"\n    }\n};\n/* End of data */\n\n",
    "felix.20250921155018.1": "// Note: Also use buildClones and buildParentRefs\n// to add icon member to data entries as needed:\n// hasBody: 1, isMarked: 2, isClone: 4, isDirty: 8\nlet allNodesInOrder = []; // Store all nodes in natural tree order (initialized after tree is built)\n\n// Build clones when repeated in the tree\nfunction buildClones(node) {\n\n    const visitedNodes = {}; // Keys are gnx, values are node references\n\n    // Helper function for recursion that has access to the visitedNodes object\n    function buildClonesWithChildren(node) {\n        const gnx = node && node.gnx;\n        // Initialize data entry safely if it exists\n        if (gnx != null && data[gnx]) {\n            if (!('icon' in data[gnx])) data[gnx].icon = 0;\n        }\n        if (gnx != null && Object.prototype.hasOwnProperty.call(visitedNodes, gnx)) {\n            // If we've already seen this node, fill its children with JSON stringify/parse for deep copy.\n            node.children = JSON.parse(JSON.stringify(visitedNodes[gnx].children || []));\n            if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 4; // set clone bit\n            // Do not recurse into children, they are already built\n        } else {\n            if (gnx != null && data[gnx] && data[gnx].bodyString) {\n                data[gnx].icon = (data[gnx].icon || 0) | 1; // set hasBody bit\n            }\n            visitedNodes[gnx] = node;\n            if (node.children) {\n                for (const child of node.children) {\n                    buildClonesWithChildren(child);\n                }\n            }\n        }\n    }\n    buildClonesWithChildren(node); // Start the recursive process\n}\n\n// Add parent references to all nodes recursively\nfunction buildParentRefs(node, parent = null) {\n    node.parent = parent;\n    if (node.children) {\n        for (const child of node.children) {\n            buildParentRefs(child, node); // recurse with current node as parent\n        }\n    }\n}\n\n// Helper function to get all nodes in tree order\nfunction getAllNodesInTreeOrder(node) {\n    const result = [];\n    function traverse(n) {\n        if (n !== tree) { // Skip the hidden root node itself\n            result.push(n);\n        }\n        if (n.children) {\n            for (const child of n.children) {\n                traverse(child);\n            }\n        }\n    }\n    traverse(node);\n    return result;\n}\n\nbuildClones(tree);\nbuildParentRefs(tree);\nallNodesInOrder = getAllNodesInTreeOrder(tree); // Initialize the global array once\n\n",
    "felix.20250921155109.1": "let flatRows = null; // Array of nodes currently visible in the outline pane, null at init time to not trigger render\nconst expanded = new Set(); // No need to add the root because 'isExpanded' will return true for it\nconst marked = new Set(); // Set of gnx (not nodes) that are marked\nlet selectedNode = null; // Track the currently selected node\nlet initialFindNode = null; // Node where to start the find (null means from the top)\nlet currentTheme = 'light'; // Default theme\nlet currentLayout = 'vertical'; // Default layout\nlet isDragging = false;\nlet mainRatio = 0.25; // Default proportion between outline-find-container and body-pane widths (defaults to 1/4)\nlet secondaryIsDragging = false;\nlet secondaryRatio = 0.75; // Default proportion between the outline-pane and the find-pane (defaults to 3/4)\nlet __toastTimer = null;\nconst navigationHistory = [];\nlet currentHistoryIndex = -1; // -1 means no history yet\nconst hoistStack = []; // Track hoisted nodes\n\nconst minWidth = 20;\nconst minHeight = 20;\n\nconst outlinePaneKeyMap = {\n    'Enter': () => BODY_PANE.focus(),\n    'Tab': () => BODY_PANE.focus(),\n    ' ': () => toggleSelected(),\n    'ArrowUp': () => selectVisBack(),\n    'ArrowDown': () => selectVisNext(),\n    'ArrowLeft': () => contractNodeOrGoToParent(),\n    'ArrowRight': () => expandNodeAndGoToFirstChild(),\n    'PageUp': () => gotoFirstSiblingOrParent(),\n    'PageDown': () => gotoLastSiblingOrVisNext(),\n    'Home': () => gotoFirstVisibleNode(),\n    'End': () => gotoLastVisibleNode()\n};\n\n",
    "felix.20250921155114.1": "// Elements\nlet selectedLabelElement = null; // Track the currently selected label element in the outline pane\nconst ROW_HEIGHT = 26;\nconst LEFT_OFFSET = 16; // Padding from left edge\nconst OUTLINE_FIND_CONTAINER = document.getElementById(\"outline-find-container\");\nconst OUTLINE_PANE = document.getElementById(\"outline-pane\");\nconst COLLAPSE_ALL_BTN = document.getElementById(\"collapse-all-btn\");\nconst SPACER = document.getElementById(\"spacer\");\nconst BODY_PANE = document.getElementById(\"body-pane\");\nconst VERTICAL_RESIZER = document.getElementById('main-resizer');\nconst FIND_PANE = document.getElementById(\"find-pane\");\nconst HORIZONTAL_RESIZER = document.getElementById('secondary-resizer');\nconst THEME_TOGGLE = document.getElementById('theme-toggle');\nconst THEME_ICON = document.getElementById('toggle-icon');\nconst LAYOUT_TOGGLE = document.getElementById('layout-toggle');\nconst LAYOUT_ICON = document.getElementById('layout-icon');\n\nconst DEHOIST_BTN = document.getElementById('dehoist-btn');\nconst HOIST_BTN = document.getElementById('hoist-btn');\nconst NEXT_BTN = document.getElementById('next-btn');\nconst PREV_BTN = document.getElementById('prev-btn');\n\nconst NEXT_MARKED_BTN = document.getElementById('next-marked-btn');\nconst TOGGLE_MARK_BTN = document.getElementById('toggle-mark-btn');\nconst PREV_MARKED_BTN = document.getElementById('prev-marked-btn');\n\nconst FIND_INPUT = document.getElementById('find-input');\nconst OPT_HEADLINE = document.getElementById('opt-headline');\nconst OPT_BODY = document.getElementById('opt-body');\nconst OPT_WHOLE = document.getElementById('opt-whole');\nconst OPT_IGNORECASE = document.getElementById('opt-ignorecase');\nconst OPT_REGEXP = document.getElementById('opt-regexp');\nconst OPT_MARK = document.getElementById('opt-mark');\n\nconst CONFIG_BTN = document.getElementById('config-btn');\n\nconst SHOW_PREV_NEXT_MARK = document.getElementById('show-prev-next-mark');\nconst SHOW_TOGGLE_MARK = document.getElementById('show-toggle-mark');\nconst SHOW_PREV_NEXT_HISTORY = document.getElementById('show-prev-next-history');\nconst SHOW_HOIST_DEHOIST = document.getElementById('show-hoist-dehoist');\nconst SHOW_LAYOUT_ORIENTATION = document.getElementById('show-layout-orientation');\nconst SHOW_THEME_TOGGLE = document.getElementById('show-theme-toggle');\nconst SHOW_NODE_ICONS = document.getElementById('show-node-icons');\nconst SHOW_COLLAPSE_ALL = document.getElementById('show-collapse-all');\n\nconst TOAST = document.getElementById('toast');\nconst HTML_ELEMENT = document.documentElement;\n\n",
    "felix.20250921155143.1": "// * Navigation helpers\nfunction children(node) {\n    // Given a node, return a shallow copy of its children array or an empty array.\n    return node && node.children ? node.children.slice() : [];\n}\n\nfunction childIndex(node) {\n    // Given a node, return its index among its siblings (0 for first, 1 for second, etc).\n    const parent = node.parent;\n    if (parent) {\n        const siblings = children(parent);\n        return siblings.indexOf(node);\n    }\n    return 0; // Should not happen for valid nodes because the top nodes are in the #outline-pane div\n};\n\nfunction parents(node) {\n    // Given a node, return an array of its ancestor nodes, closest first.\n    const ancestors = [];\n    let current = node;\n    while (current) {\n        const parent = current.parent;\n        if (parent) {\n            ancestors.push(parent);\n        }\n        current = parent;\n    }\n    return ancestors;\n};\n\nfunction isAncestorOf(possibleAncestor, descendant) {\n    // Return true if possibleAncestor is an ancestor of descendant.\n    let current = descendant.parent;\n    while (current) {\n        if (current === possibleAncestor) {\n            return true;\n        }\n        current = current.parent;\n    }\n    return false;\n}\n\nfunction hasChildren(node) {\n    // Given a node, return true if it has children.\n    return node.children && node.children.length > 0;\n}\n\nfunction isExpanded(node) {\n    // Given a node, return true if it is expanded.\n    if (!node.parent) return true; // The root node is always considered expanded\n    return expanded.has(node);\n}\n\nfunction isDescendantOfHoistedNode(node) {\n    if (!node || hoistStack.length === 0) return false;\n\n    const hoistedNode = hoistStack[hoistStack.length - 1];\n    return hoistedNode === node || isAncestorOf(hoistedNode, node);\n}\n\nfunction isVisible(node) {\n    // Return True if node is visible in the outline.\n    if (!node.parent) return false; // Root node is not visible\n\n    // First check if the node is descendant of the hoisted node\n    if (hoistStack.length > 0 && !isDescendantOfHoistedNode(node)) {\n        return false;\n    }\n\n    // Then check if all ancestors are expanded\n    const ancestors = parents(node);\n    for (const ancestor of ancestors) {\n        if (!isExpanded(ancestor)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction hasBack(node) {\n    // Given a node, return true if it has a previous sibling.\n    const parent = node.parent;\n    if (parent) {\n        const siblings = children(parent);\n        const index = siblings.indexOf(node);\n        return index > 0;\n    }\n    return false;\n}\n\nfunction hasNext(node) {\n    // Given a node, return true if it has a next sibling.\n    const parent = node.parent;\n    if (parent) {\n        const siblings = children(parent);\n        const index = siblings.indexOf(node);\n        return index < siblings.length - 1;\n    }\n    return false;\n}\n\nfunction hasParent(node) {\n    // Given a node, return true if it has a parent. Except if that parent is the hidden root node.\n    return !!node.parent && !!node.parent.parent;\n}\n\nfunction hasThreadBack(node) {\n    // Much cheaper than computing the actual value.\n    return hasBack(node) || hasParent(node);\n}\n\nfunction moveToBack(node) {\n    // Given a node, return its previous sibling. If first, or no parent, return null.\n    const parent = node.parent;\n    if (parent) {\n        const siblings = children(parent);\n        const index = siblings.indexOf(node);\n        return index > 0 ? siblings[index - 1] : null;\n    }\n    return null;\n}\n\nfunction moveToFirstChild(node) {\n    // Given a node, return its first child if any. Else return null.\n    return hasChildren(node) ? node.children[0] : null;\n}\n\nfunction moveToLastChild(node) {\n    // Given a node, return its last child if any. Else return null.\n    return hasChildren(node) ? node.children[node.children.length - 1] : null;\n}\n\nfunction moveToLastNode(node) {\n    // Given a node, return the last node of its tree or itself if no children.\n    while (hasChildren(node)) {\n        node = moveToLastChild(node);\n    }\n    return node;\n}\n\nfunction moveToNext(node) {\n    // Given a node, return its next sibling. If already last, return null.\n    const parent = node.parent;\n    if (parent) {\n        const siblings = children(parent);\n        const index = siblings.indexOf(node);\n        return index < siblings.length - 1 ? siblings[index + 1] : null;\n    }\n    return null;\n}\n\nfunction moveToNodeAfterTree(node) {\n    // Given a node, return the node after the position's tree.\n    while (node) {\n        if (hasNext(node)) {\n            node = moveToNext(node);\n            break;\n        }\n        node = moveToParent(node);\n    }\n    return node;\n}\n\nfunction moveToParent(node) {\n    // Given a node, return its parent or null if no parent.\n    const parent = node.parent;\n    if (parent) {\n        return parent;\n    }\n    return null;\n}\n\nfunction moveToThreadBack(node) {\n    // Given a node, return the previous node in the outline.\n    if (hasBack(node)) {\n        node = moveToBack(node);\n        node = moveToLastNode(node);\n    } else {\n        node = moveToParent(node);\n    }\n    return node;\n}\n\nfunction moveToThreadNext(node) {\n    // Given a node, return the next node in the outline.\n    if (hasChildren(node)) {\n        node = moveToFirstChild(node);\n    } else if (hasNext(node)) {\n        node = moveToNext(node);\n    } else {\n        node = moveToParent(node);\n        while (node) {\n            if (node && hasNext(node)) {\n                node = moveToNext(node);\n                break;\n            }\n            node = moveToParent(node);\n        }\n    }\n    return node;\n};\n\nfunction moveToVisBack(node) {\n    // Given a node, return the previous visible node in the outline.\n    while (node) {\n        // Short-circuit if possible.\n        const back = moveToBack(node);\n        if (back && hasChildren(back) && isExpanded(back))\n            node = moveToThreadBack(node);\n        else if (back) {\n            node = moveToBack(node);\n        } else {\n            node = moveToParent(node);  // Same as p.moveToThreadBack()\n        }\n        if (node && isVisible(node)) {\n            return node;\n        }\n    }\n    return node;\n}\n\nfunction moveToVisNext(node) {\n    // Given a node, return the next visible node in the outline.\n    while (node) {\n        if (hasChildren(node)) {\n            if (isExpanded(node)) {\n                node = moveToFirstChild(node);\n            } else {\n                node = moveToNodeAfterTree(node);\n            }\n        } else if (hasNext(node)) {\n            node = moveToNext(node);\n        } else {\n            node = moveToThreadNext(node);\n        }\n        if (node && isVisible(node)) {\n            return node;\n        }\n    }\n};\n\n",
    "felix.20250921155219.1": "// * Navigation actions\nfunction hoistNode() {\n    if (!selectedNode) return;\n\n    // If selected node is already hoisted: no-op (Even if button should be disabled in that case)\n    if (hoistStack.length > 0 && hoistStack[hoistStack.length - 1] === selectedNode) return;\n\n    if (!selectedNode.parent) return; // root node (though it should never be selected anyway)\n\n    hoistStack.push(selectedNode);\n    if (hasChildren(selectedNode) && !isExpanded(selectedNode)) {\n        expanded.add(selectedNode);\n        selectedNode.toggled = true; // Mark as toggled\n    }\n    updateHoistButtonStates();\n    flatRows = flattenTree(getCurrentRoot(), 0, false);\n    renderTree();\n}\n\nfunction dehoistNode() {\n    if (hoistStack.length === 0) return;\n    const previousHoist = hoistStack.pop();\n    selectAndOrToggleAndRedraw(previousHoist);\n    updateHoistButtonStates();\n}\n\nfunction expandNodeAndGoToFirstChild() {\n    // If the presently selected node has children, expand it if needed and go to the first child.\n    let node = selectedNode;\n    if (hasChildren(node)) {\n        if (!isExpanded(node)) {\n            expanded.add(node);\n            node.toggled = true; // Mark as toggled\n        }\n        node = moveToFirstChild(node);\n        selectAndOrToggleAndRedraw(node);\n    }\n}\n\nfunction contractNodeOrGoToParent() {\n    // If the presently selected node is expanded, collapse it. Otherwise go to the parent.\n    let node = selectedNode;\n    if (hasChildren(node) && isExpanded(node)) {\n        selectAndOrToggleAndRedraw(null, node);\n    } else if (hasParent(node)) {\n        const parent = moveToParent(node);\n        if (isVisible(parent)) {\n            // Contract all children first\n            for (const child of children(parent)) {\n                if (isExpanded(child)) {\n                    expanded.delete(child);\n                    child.toggled = true; // Mark as toggled\n                }\n            }\n            selectAndOrToggleAndRedraw(parent);\n        }\n    }\n}\n\nfunction selectVisBack() {\n    // Select the visible node preceding the presently selected node.\n    let node = selectedNode;\n    if (moveToVisBack(node)) {\n        node = moveToVisBack(node);\n        selectAndOrToggleAndRedraw(node);\n    }\n}\n\nfunction selectVisNext() {\n    // Select the visible node following the presently selected node.\n    let node = selectedNode;\n    if (moveToVisNext(node)) {\n        node = moveToVisNext(node);\n        selectAndOrToggleAndRedraw(node);\n    }\n}\n\nfunction gotoFirstSiblingOrParent() {\n    // Select the first sibling of the presently selected node, or its parent if already first.\n    let node = selectedNode;\n    const currentRoot = getCurrentRoot();\n    if (hasBack(node)) {\n        let firstVisibleSibling = null;\n        let current = node;\n        while (hasBack(current)) {\n            let prev = moveToBack(current);\n            if (isVisible(prev)) {\n                firstVisibleSibling = prev;\n                current = prev;\n            } else {\n                break;\n            }\n        }\n        if (firstVisibleSibling) {\n            node = firstVisibleSibling;\n        }\n    } else if (hasParent(node) && node !== currentRoot) {\n        const parent = moveToParent(node);\n        if (parent === currentRoot || isDescendantOfHoistedNode(parent)) {\n            node = parent;\n        }\n    }\n    selectAndOrToggleAndRedraw(node);\n};\n\nfunction gotoLastSiblingOrVisNext() {\n    // Select the last sibling of the presently selected node, or the next visible node if already last.\n    let node = selectedNode;\n    const currentRoot = getCurrentRoot();\n    if (hasNext(node)) {\n        let lastVisibleSibling = null;\n        let current = node;\n        while (hasNext(current)) {\n            let next = moveToNext(current);\n            if (isVisible(next)) {\n                lastVisibleSibling = next;\n                current = next;\n            } else {\n                break;\n            }\n        }\n        if (lastVisibleSibling) {\n            node = lastVisibleSibling;\n        }\n    } else if (moveToVisNext(node)) {\n        node = moveToVisNext(node);\n    }\n    if (node) selectAndOrToggleAndRedraw(node);\n};\n\n\nfunction gotoFirstVisibleNode() {\n    // Get the current root (could be hoisted node or hidden root)\n    const currentRoot = getCurrentRoot();\n\n    // If we're hoisted, the first visible node could be the hoisted node itself\n    if (hoistStack.length > 0) {\n        selectAndOrToggleAndRedraw(currentRoot);\n        return;\n    }\n\n    // Otherwise, select the first child of the root node\n    const firstNode = moveToFirstChild(currentRoot);\n    if (firstNode) {\n        selectAndOrToggleAndRedraw(firstNode);\n    }\n};\n\nfunction gotoLastVisibleNode() {\n    // Select the last visible node in the outline.\n    let node = selectedNode;\n    while (node) {\n        const next = moveToVisNext(node);\n        if (next && isVisible(next)) {\n            node = next;\n        } else {\n            break;\n        }\n    }\n    if (node) selectAndOrToggleAndRedraw(node);\n};\n\nfunction collapseAll() {\n    // Collapse all nodes in visible outline and select the proper top-level node\n    const currentRoot = getCurrentRoot();\n    if (currentRoot === tree) {\n        expanded.clear();\n    } else {\n        const nodesToRemove = [];\n        expanded.forEach(node => {\n            if (node === currentRoot || isAncestorOf(currentRoot, node)) {\n                nodesToRemove.push(node);\n            }\n        });\n        nodesToRemove.forEach(node => expanded.delete(node));\n    }\n    if (hoistStack.length > 0) {\n        selectAndOrToggleAndRedraw(currentRoot);\n    } else {\n        let node = selectedNode;\n        // If currently selected node is a descendant of a top-level node, find that top-level node\n        while (node && hasParent(node) && node.parent !== tree) {\n            node = moveToParent(node);\n        }\n        if (node) selectAndOrToggleAndRedraw(node);\n    }\n};\n\nfunction toggleSelected() {\n    if (selectedNode && selectedNode.children && selectedNode.children.length > 0) {\n        selectAndOrToggleAndRedraw(null, selectedNode);\n    }\n}\n\nfunction toggleMark(node) {\n    if (!node) return;\n    const gnx = node.gnx;\n    if (marked.has(gnx)) {\n        marked.delete(gnx);\n        if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) & ~2; // Clear marked bit\n    } else {\n        marked.add(gnx);\n        if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 2; // Set marked bit\n    }\n    updateMarkedButtonStates();\n    // Only need to redraw the affected node if visible, no need to re-flatten because structure didn't change\n    if (isVisible(node)) {\n        renderTree();\n    }\n}\n\nfunction toggleMarkCurrentNode() {\n    if (selectedNode) {\n        toggleMark(selectedNode);\n    }\n}\n\nfunction gotoNextMarkedNode() {\n    if (!selectedNode || marked.size === 0) return;\n\n    const currentIndex = allNodesInOrder.findIndex(node => node === selectedNode);\n    if (currentIndex === -1) return; // Should never happen\n\n    let foundMarked = false;\n    for (let i = 1; i <= allNodesInOrder.length; i++) {\n        const nextIndex = (currentIndex + i) % allNodesInOrder.length; // Wrap around\n        const node = allNodesInOrder[nextIndex];\n\n        if (node === selectedNode) continue;\n\n        if (marked.has(node.gnx)) {\n            selectAndOrToggleAndRedraw(node);\n            foundMarked = true;\n            break;\n        }\n    }\n\n    if (!foundMarked) {\n        if (marked.size === 1 && marked.has(selectedNode.gnx)) {\n            showToast(\"Only one marked node.\");\n        } else {\n            showToast(\"No other marked nodes found.\");\n        }\n    }\n}\n\nfunction gotoPrevMarkedNode() {\n    if (!selectedNode || marked.size === 0) return;\n\n    const currentIndex = allNodesInOrder.findIndex(node => node === selectedNode);\n    if (currentIndex === -1) return; // Should never happen\n\n    let foundMarked = false;\n    for (let i = 1; i <= allNodesInOrder.length; i++) {\n        const prevIndex = (currentIndex - i + allNodesInOrder.length) % allNodesInOrder.length; // Wrap around\n        const node = allNodesInOrder[prevIndex];\n\n        if (node === selectedNode) continue;\n\n        if (marked.has(node.gnx)) {\n            selectAndOrToggleAndRedraw(node);\n            foundMarked = true;\n            break;\n        }\n    }\n\n    if (!foundMarked) {\n        if (marked.size === 1 && marked.has(selectedNode.gnx)) {\n            showToast(\"Only one marked node.\");\n        } else {\n            showToast(\"No other marked nodes found.\");\n        }\n    }\n}\n\n",
    "felix.20250921155503.1": "// * Button states\nfunction updateMarkedButtonStates() {\n    const hasMarkedNodes = marked.size > 0;\n    NEXT_MARKED_BTN.disabled = !hasMarkedNodes;\n    PREV_MARKED_BTN.disabled = !hasMarkedNodes;\n}\n\nfunction updateHoistButtonStates() {\n    const isCurrentlyHoisted = hoistStack.length > 0 && hoistStack[hoistStack.length - 1] === selectedNode;\n    DEHOIST_BTN.disabled = hoistStack.length === 0;\n    HOIST_BTN.disabled = !selectedNode || !hasChildren(selectedNode) || isCurrentlyHoisted;\n}\n\nfunction updateHistoryButtonStates() {\n    PREV_BTN.disabled = currentHistoryIndex <= 0;\n    NEXT_BTN.disabled = currentHistoryIndex >= navigationHistory.length - 1 || navigationHistory.length === 0;\n}\n\nfunction toggleConfiguration() {\n    if (HTML_ELEMENT.getAttribute('data-show-config') === 'true') {\n        HTML_ELEMENT.setAttribute('data-show-config', 'false');\n        CONFIG_BTN.innerHTML = '‚öôÔ∏è';\n        CONFIG_BTN.setAttribute('title', 'Configuration');\n        CONFIG_BTN.setAttribute('aria-label', 'Configuration');\n    } else {\n        HTML_ELEMENT.setAttribute('data-show-config', 'true');\n        CONFIG_BTN.innerHTML = '‚úîÔ∏è';\n        CONFIG_BTN.setAttribute('title', 'Back to Find');\n        CONFIG_BTN.setAttribute('aria-label', 'Back to Find');\n    }\n}\n\n",
    "felix.20250921155509.1": "// * History\nfunction addToHistory(node) {\n    if (navigationHistory.length > 0 &&\n        navigationHistory[currentHistoryIndex] === node) {\n        return; // Already the current node, do nothing\n    }\n\n    // If we're not at the end, truncate the forward history\n    if (currentHistoryIndex < navigationHistory.length - 1) {\n        navigationHistory.splice(currentHistoryIndex + 1);\n    }\n\n    navigationHistory.push(node);\n    currentHistoryIndex = navigationHistory.length - 1;\n\n    updateHistoryButtonStates();\n}\n\nfunction previousHistory() {\n    if (currentHistoryIndex > 0) {\n        currentHistoryIndex--;\n        const node = navigationHistory[currentHistoryIndex];\n\n        // Navigate to the node without adding to history\n        selectAndOrToggleAndRedraw(node);\n        updateHistoryButtonStates();\n    }\n}\n\nfunction nextHistory() {\n    if (currentHistoryIndex < navigationHistory.length - 1) {\n        currentHistoryIndex++;\n        const node = navigationHistory[currentHistoryIndex];\n\n        // Navigate to the node without adding to history\n        selectAndOrToggleAndRedraw(node);\n        updateHistoryButtonStates();\n    }\n}\n\n",
    "felix.20250921155516.1": "// * Rendering helpers\nfunction getCurrentRoot() {\n    // Return the current top of the hoist stack or the main tree root\n    return hoistStack.length > 0 ? hoistStack[hoistStack.length - 1] : tree;\n}\n\nfunction flattenTree(node, depth = 0, isRoot = true) {\n    // This only flattens the tree structure into an array of rows for rendering.\n    // It check for expansion state to include children as needed because only expanded nodes' children are visible.\n    // The isRoot parameter indicates if this node is the hidden root node (not visible).\n\n    let rows = [];\n\n    // Only add non-root nodes to the rows\n    if (!isRoot) {\n        rows.push({\n            label: data[node.gnx].headString,\n            depth,\n            toggled: node.toggled || false, // Will make it render with toggled class\n            hasChildren: !!node.children && node.children.length > 0,\n            isExpanded: isExpanded(node),\n            node\n        });\n    }\n    if (node.toggled) {\n        node.toggled = false; // Reset because it should not persist\n    }\n\n    if (isExpanded(node) && node.children) {\n        for (const child of node.children) {\n            // Root node's children appear at depth 0\n            const childDepth = isRoot ? 0 : depth + 1;\n            rows.push(...flattenTree(child, childDepth, false));\n        }\n    }\n\n    return rows;\n}\n\nfunction selectAndOrToggleAndRedraw(newSelectedNode = null, nodeToToggle = null) {\n    // Handle toggling if requested\n    if (nodeToToggle) {\n        if (isExpanded(nodeToToggle)) {\n            expanded.delete(nodeToToggle);\n        } else {\n            expanded.add(nodeToToggle);\n        }\n        nodeToToggle.toggled = true; // Mark as toggled\n    }\n\n    const isNew = newSelectedNode && newSelectedNode !== selectedNode;\n\n    // Handle selection if requested\n    if (isNew) {\n        let hoistTop = getCurrentRoot();\n\n        // While the top of hoist stack is not an ancestor of the new selected node, pop it\n        while (newSelectedNode !== hoistTop && hoistStack.length > 0 && !isAncestorOf(hoistTop, newSelectedNode)) {\n            hoistStack.pop();\n            hoistTop = getCurrentRoot();\n        }\n\n        // Ensure all parent nodes are expanded so the selected node is visible\n        let currentNode = newSelectedNode;\n        while (currentNode && currentNode.parent && currentNode !== hoistTop) {\n            // Skip the hidden root node since it's always expanded (When hoist is implemented, stop at hoist root)\n            if (currentNode.parent.parent) {\n                expanded.add(currentNode.parent);\n            }\n            currentNode = currentNode.parent;\n        }\n\n        selectedNode = newSelectedNode;\n        addToHistory(newSelectedNode);\n        updateHoistButtonStates();\n    }\n\n    // Only rebuild and redraw once\n    const currentRoot = getCurrentRoot();\n    const isHoisted = hoistStack.length > 0;\n\n    // If hoisted, pass isRoot=false to make the hoisted node visible\n    // If not hoisted, use the hidden root with isRoot=true\n    flatRows = flattenTree(currentRoot, 0, !isHoisted);\n    renderTree();\n\n    // Update body pane if selection changed (selectedNode cannot be null here because of isNew check)\n    if (isNew) {\n        if (newSelectedNode && data[newSelectedNode.gnx]) {\n            BODY_PANE.textContent = data[newSelectedNode.gnx].bodyString || \"\";\n        } else {\n            BODY_PANE.textContent = \"\";\n        }\n    }\n    scrollSelectedNodeIntoView();\n}\n\nfunction scrollSelectedNodeIntoView() {\n    if (!selectedNode || !flatRows) return; // Not initialized yet\n\n    const selectedIndex = flatRows.findIndex(row => row.node === selectedNode);\n    if (selectedIndex === -1) return; // Not found (shouldn't happen)\n    const nodePosition = selectedIndex * ROW_HEIGHT;\n\n    const scrollTop = OUTLINE_PANE.scrollTop;\n    const viewportHeight = OUTLINE_PANE.clientHeight;\n\n    if (nodePosition < scrollTop) {\n        OUTLINE_PANE.scrollTop = nodePosition;\n    } else if (nodePosition + ROW_HEIGHT > scrollTop + viewportHeight) {\n        OUTLINE_PANE.scrollTop = nodePosition - viewportHeight + ROW_HEIGHT;\n    }\n}\n\nfunction renderTree() {\n    if (!flatRows) return; // Not initialized yet\n\n    // Render visible rows only\n    const scrollTop = OUTLINE_PANE.scrollTop;\n    const viewportHeight = OUTLINE_PANE.clientHeight;\n    const viewportWidth = OUTLINE_PANE.clientWidth;\n\n    const startIndex = Math.floor(scrollTop / ROW_HEIGHT);\n    const visibleCount = Math.ceil(viewportHeight / ROW_HEIGHT) + 1;\n    const endIndex = Math.min(flatRows.length, startIndex + visibleCount);\n    let leftOffset = LEFT_OFFSET;\n\n    // If all nodes have no children, remove the left offset\n    if (flatRows.every(row => !row.hasChildren)) {\n        leftOffset = 0;\n    }\n\n    SPACER.innerHTML = \"\";\n    SPACER.style.height = flatRows.length * ROW_HEIGHT + \"px\";\n\n    let selectedRadioValue = ''; // Falsy for now\n    const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\n    if (selectedRadio) {\n        selectedRadioValue = selectedRadio.value;\n    }\n\n    const searchSuboutline = selectedRadioValue === 'suboutline' && initialFindNode; // Will contain the node or null\n    const searchNodeOnly = selectedRadioValue === 'node'; // selected node only\n\n    for (let i = startIndex; i < endIndex; i++) {\n        const row = flatRows[i];\n        const div = document.createElement(\"div\");\n        div.className = \"node\";\n        if (row.label) {\n            div.title = row.label;\n        }\n\n        if (row.node === selectedNode) {\n            div.classList.add(\"selected\");\n        } else if (selectedNode && isAncestorOf(row.node, selectedNode)) {\n            div.classList.add(\"ancestor\");\n        }\n\n        if (searchNodeOnly && row.node === selectedNode) {\n            div.classList.add(\"initial-find\");\n        }\n\n        if (searchSuboutline && (row.node === searchSuboutline || isAncestorOf(searchSuboutline, row.node))) {\n            div.classList.add(\"initial-find\");\n        }\n\n        div.style.top = (i * ROW_HEIGHT) + \"px\";\n        div.style.height = ROW_HEIGHT + \"px\";\n\n        const leftPosition = (row.depth * 20) + leftOffset;\n        div.style.left = leftPosition + \"px\";\n        div.style.width = (viewportWidth - leftPosition) + \"px\";\n\n        const caret = document.createElement(\"span\");\n        caret.className = row.toggled ? \"caret toggled\" : \"caret\";\n\n        row.toggled = false; // Reset toggled state after rendering\n\n        if (row.hasChildren) {\n            caret.setAttribute(\"data-expanded\", row.isExpanded ? \"true\" : \"false\");\n        }\n        div.appendChild(caret);\n\n        const labelSpan = document.createElement(\"span\");\n        labelSpan.className = \"node-text\";\n\n        // If dark mode, invert the icons' 4 bit to swap dirty borders inverted\n        if (currentTheme === 'dark') {\n            let invertedIcon = data[row.node.gnx].icon ^ 8; // Toggle the 4 bit\n            labelSpan.classList.add(\"icon\" + invertedIcon);\n        } else {\n            labelSpan.classList.add(\"icon\" + (data[row.node.gnx].icon || 0));\n        }\n\n        labelSpan.textContent = row.label;\n        if (row.node === selectedNode) {\n            selectedLabelElement = labelSpan;\n        }\n\n        div.appendChild(labelSpan);\n        SPACER.appendChild(div);\n    }\n}\n\n",
    "felix.20250921163309.1": "function throttle(func, limit) {\n    let lastCall = 0;\n    let timeout;\n\n    return function (...args) {\n        const now = Date.now();\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        if (now - lastCall >= limit) {\n            lastCall = now;\n            func.apply(this, args);\n        } else {\n            timeout = setTimeout(() => {\n                lastCall = Date.now();\n                func.apply(this, args);\n            }, limit - (now - lastCall));\n        }\n    };\n}\n\nfunction showToast(message, duration = 2000) {\n    if (!TOAST) return;\n    TOAST.textContent = message;\n    TOAST.hidden = false;\n    // Force reflow so the transition always runs when toggling\n    void TOAST.offsetWidth;\n    TOAST.classList.add('show');\n    if (__toastTimer) {\n        clearTimeout(__toastTimer);\n    }\n    __toastTimer = setTimeout(() => {\n        TOAST.classList.remove('show');\n        setTimeout(() => { TOAST.hidden = true; }, 220);\n        __toastTimer = null;\n    }, duration);\n}\n\nfunction safeLocalStorageGet(key) {\n    try {\n        return localStorage.getItem(key);\n    } catch (e) {\n        return null;\n    }\n}\n\nfunction safeLocalStorageSet(key, value) {\n    try {\n        localStorage.setItem(key, value);\n    } catch (e) {\n        // ignore\n    }\n}\n\nfunction preventDefault(e) {\n    e.preventDefault(); // Utility function used in setupBodyPaneHandlers\n}\n\n",
    "felix.20250921155710.1": "function updateProportion() {\n    if (currentLayout === 'vertical') {\n        mainRatio = OUTLINE_FIND_CONTAINER.offsetWidth / window.innerWidth;\n    } else {\n        mainRatio = OUTLINE_FIND_CONTAINER.offsetHeight / window.innerHeight;\n    }\n}\n\nfunction updateOutlineContainerSize() {\n    if (currentLayout === 'vertical') {\n        let newWidth = window.innerWidth * mainRatio;\n        if (newWidth < minWidth) {\n            newWidth = minWidth;\n        }\n        OUTLINE_FIND_CONTAINER.style.width = `${newWidth}px`;\n        OUTLINE_FIND_CONTAINER.style.height = '100%';\n        CONFIG_BTN.style.inset = `auto auto 7px ${newWidth - 33}px`;\n    } else {\n        let newHeight = window.innerHeight * mainRatio;\n        if (newHeight < minWidth) {\n            newHeight = minWidth;\n        }\n        OUTLINE_FIND_CONTAINER.style.height = `${newHeight}px`;\n        OUTLINE_FIND_CONTAINER.style.width = '100%';\n        CONFIG_BTN.style.inset = `${newHeight - 33}px 7px auto auto`;\n    }\n}\n\nconst handleDrag = throttle(function (e) {\n    if (currentLayout === 'vertical') {\n        let clientX = e.clientX;\n        if (e.touches) {\n            clientX = e.touches[0].clientX;\n        }\n        const newWidth = clientX;\n        if (newWidth >= minWidth) {\n            OUTLINE_FIND_CONTAINER.style.width = (newWidth - 3) + 'px';\n        } else {\n            OUTLINE_FIND_CONTAINER.style.width = (minWidth - 3) + 'px';\n        }\n        CONFIG_BTN.style.inset = `auto auto 7px ${newWidth - 33}px`;\n    } else {\n        let clientY = e.clientY;\n        if (e.touches) {\n            clientY = e.touches[0].clientY;\n        }\n        const newHeight = clientY;\n        if (newHeight >= minWidth) {\n            OUTLINE_FIND_CONTAINER.style.height = (newHeight - 3) + 'px';\n        } else {\n            OUTLINE_FIND_CONTAINER.style.height = (minWidth - 3) + 'px';\n        }\n        renderTree(); // Resizing vertically, so need to re-render tree\n        CONFIG_BTN.style.inset = `${newHeight - 33}px 7px auto auto`;\n    }\n    COLLAPSE_ALL_BTN.style.inset = `6px auto auto ${OUTLINE_PANE.clientWidth - 18}px`;\n}, 33);\n\nfunction startDrag(e) {\n    isDragging = true;\n    document.body.classList.add('dragging-main');\n    e.preventDefault();\n    document.addEventListener('mousemove', handleDrag);\n    document.addEventListener('mouseup', stopDrag);\n    document.addEventListener('touchmove', handleDrag, { passive: false });\n    document.addEventListener('touchend', stopDrag);\n}\n\nfunction stopDrag() {\n    if (isDragging) {\n        isDragging = false;\n        document.body.classList.remove('dragging-main');\n        document.removeEventListener('mousemove', handleDrag);\n        document.removeEventListener('mouseup', stopDrag);\n        document.removeEventListener('touchmove', handleDrag);\n        document.removeEventListener('touchend', stopDrag);\n        updateProportion();\n        renderTree();\n    }\n}\n\nfunction updateSecondaryProportion() {\n    if (currentLayout === 'vertical') {\n        secondaryRatio = (OUTLINE_PANE.offsetHeight - 6) / OUTLINE_FIND_CONTAINER.offsetHeight;\n    } else {\n        secondaryRatio = OUTLINE_PANE.offsetWidth / OUTLINE_FIND_CONTAINER.offsetWidth;\n    }\n}\n\nfunction updateOutlinePaneSize() {\n    if (currentLayout === 'vertical') {\n        const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\n        let newHeight = containerHeight * secondaryRatio;\n\n        // Respect minimum heights\n        if (newHeight < minHeight) {\n            newHeight = minHeight;\n        } else if (newHeight > containerHeight - minHeight) {\n            newHeight = containerHeight - minHeight;\n        }\n        // Set flex properties to control the distribution\n        OUTLINE_PANE.style.flex = `0 0 ${newHeight}px`;\n    } else {\n        const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\n        let newWidth = containerWidth * secondaryRatio;\n\n        // Respect minimum widths\n        if (newWidth < minHeight) {\n            newWidth = minHeight;\n        } else if (newWidth > containerWidth - minHeight) {\n            newWidth = containerWidth - minHeight;\n        }\n        // Set flex properties to control the distribution\n        OUTLINE_PANE.style.flex = `0 0 ${newWidth}px`;\n    }\n    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\n    COLLAPSE_ALL_BTN.style.inset = `6px auto auto ${OUTLINE_PANE.clientWidth - 18}px`;\n}\n\nconst handleSecondaryDrag = throttle(function (e) {\n    if (currentLayout === 'vertical') {\n        let clientY = e.clientY;\n        if (e.touches) {\n            clientY = e.touches[0].clientY;\n        }\n        const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\n        const relativeY = clientY - containerRect.top;\n        const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\n        if (relativeY >= minHeight && relativeY <= containerHeight - minHeight) {\n            OUTLINE_PANE.style.flex = `0 0 ${relativeY - 8}px`;\n            FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\n        }\n        renderTree(); // Resizing vertically, so need to re-render tree\n    } else {\n        let clientX = e.clientX;\n        if (e.touches) {\n            clientX = e.touches[0].clientX;\n        }\n        const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\n        const relativeX = clientX - containerRect.left;\n        const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\n        if (relativeX >= minHeight && relativeX <= containerWidth - minHeight) {\n            OUTLINE_PANE.style.flex = `0 0 ${relativeX - 3}px`;\n            FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\n        }\n    }\n    COLLAPSE_ALL_BTN.style.inset = `6px auto auto ${OUTLINE_PANE.clientWidth - 18}px`;\n}, 33);\n\nfunction startSecondaryDrag(e) {\n    secondaryIsDragging = true;\n    document.body.classList.add('dragging-secondary');\n    e.preventDefault();\n    document.addEventListener('mousemove', handleSecondaryDrag);\n    document.addEventListener('mouseup', stopSecondaryDrag);\n    document.addEventListener('touchmove', handleSecondaryDrag, { passive: false });\n    document.addEventListener('touchend', stopSecondaryDrag);\n}\n\nfunction stopSecondaryDrag() {\n    if (secondaryIsDragging) {\n        secondaryIsDragging = false;\n        document.body.classList.remove('dragging-secondary');\n        document.removeEventListener('mousemove', handleSecondaryDrag);\n        document.removeEventListener('mouseup', stopSecondaryDrag);\n        document.removeEventListener('touchmove', handleSecondaryDrag);\n        document.removeEventListener('touchend', stopSecondaryDrag);\n        updateSecondaryProportion();\n        renderTree();\n    }\n}\n\nfunction updatePanelSizes() {\n    updateOutlineContainerSize();\n    updateOutlinePaneSize();\n}\n\nfunction applyTheme(theme) {\n    currentTheme = theme;\n    HTML_ELEMENT.setAttribute('data-theme', theme);\n    THEME_TOGGLE.title = theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme';\n    THEME_ICON.innerHTML = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';\n};\n\nfunction applyLayout(layout) {\n    currentLayout = layout;\n    LAYOUT_TOGGLE.title = layout === 'vertical' ? 'Switch to horizontal layout' : 'Switch to vertical layout';\n    if (layout === 'horizontal') {\n        HTML_ELEMENT.setAttribute('data-layout', 'horizontal');\n    } else {\n        HTML_ELEMENT.setAttribute('data-layout', 'vertical');\n    }\n    updatePanelSizes(); // Proportions will have changed so we must update sizes\n    if (flatRows) {\n        renderTree();\n    }\n};\n\n",
    "felix.20250921170854.1": "// Setup and organize all event handlers\nfunction setupEventHandlers() {\n    setupOutlinePaneHandlers();\n    setupBodyPaneHandlers();\n    setupResizerHandlers();\n    setupWindowHandlers();\n    setupButtonHandlers();\n    setupFindPaneHandlers();\n    setupConfigCheckboxes();\n}\n\nfunction setupOutlinePaneHandlers() {\n    OUTLINE_PANE.addEventListener(\"mousedown\", handleOutlinePaneMouseDown);\n    OUTLINE_PANE.addEventListener('click', handleOutlinePaneClick);\n    OUTLINE_PANE.addEventListener('dblclick', handleOutlinePaneDblClick);\n    OUTLINE_PANE.addEventListener('keydown', handleOutlinePaneKeyDown);\n    OUTLINE_PANE.addEventListener(\"scroll\", throttle(renderTree, 33));\n}\n\nfunction setupBodyPaneHandlers() {\n    BODY_PANE.addEventListener('keydown', handleBodyPaneKeyDown);\n    BODY_PANE.addEventListener(\"beforeinput\", preventDefault); // Block text changes\n    BODY_PANE.addEventListener(\"paste\", preventDefault); // Block text changes\n}\n\nfunction setupResizerHandlers() {\n    VERTICAL_RESIZER.addEventListener('mousedown', startDrag);\n    VERTICAL_RESIZER.addEventListener('touchstart', startDrag);\n    HORIZONTAL_RESIZER.addEventListener('mousedown', startSecondaryDrag);\n    HORIZONTAL_RESIZER.addEventListener('touchstart', startSecondaryDrag);\n}\n\nfunction setupWindowHandlers() {\n    window.addEventListener('resize', throttle(handleWindowResize, 33));\n    window.addEventListener('keydown', handleGlobalKeyDown);\n    window.addEventListener('beforeunload', saveAll);\n}\n\nfunction setupButtonHandlers() {\n    COLLAPSE_ALL_BTN.addEventListener('click', collapseAll);\n    THEME_TOGGLE.addEventListener('click', handleThemeToggleClick);\n    LAYOUT_TOGGLE.addEventListener('click', handleLayoutToggleClick);\n    HOIST_BTN.addEventListener('click', hoistNode);\n    DEHOIST_BTN.addEventListener('click', dehoistNode);\n    PREV_BTN.addEventListener('click', previousHistory);\n    NEXT_BTN.addEventListener('click', nextHistory);\n    TOGGLE_MARK_BTN.addEventListener('click', toggleMarkCurrentNode);\n    NEXT_MARKED_BTN.addEventListener('click', gotoNextMarkedNode);\n    PREV_MARKED_BTN.addEventListener('click', gotoPrevMarkedNode);\n    CONFIG_BTN.addEventListener('click', toggleConfiguration);\n}\n\nfunction setupFindPaneHandlers() {\n    FIND_INPUT.addEventListener('keydown', function (e) {\n        if (e.key === 'Tab' && e.shiftKey) {\n            e.preventDefault();\n            OPT_BODY.focus();\n        }\n        if (e.key === 'Enter') {\n            e.preventDefault();\n            findNext();\n        }\n    });\n    OPT_BODY.addEventListener('keydown', function (e) {\n        if (e.key === 'Tab' && !e.shiftKey) {\n            e.preventDefault();\n            FIND_INPUT.focus();\n        }\n    });\n    const findScopeRadios = document.querySelectorAll('input[name=\"find-scope\"]');\n    findScopeRadios.forEach(radio => {\n        radio.addEventListener('change', function () {\n            initialFindNode = null; // Reset initial find node when scope changes\n            renderTree(); // Re-render to update node highlighting\n        });\n    });\n}\n\nfunction setupButtonFocusPrevention() {\n    const actionButtons = document.querySelectorAll('.action-button');\n    actionButtons.forEach(button => {\n        button.addEventListener('mousedown', (e) => {\n            e.preventDefault();\n        });\n    });\n}\n\nfunction setupConfigCheckboxes() {\n    SHOW_PREV_NEXT_MARK.addEventListener('change', updateButtonVisibility);\n    SHOW_TOGGLE_MARK.addEventListener('change', updateButtonVisibility);\n    SHOW_PREV_NEXT_HISTORY.addEventListener('change', updateButtonVisibility);\n    SHOW_HOIST_DEHOIST.addEventListener('change', updateButtonVisibility);\n    SHOW_LAYOUT_ORIENTATION.addEventListener('change', updateButtonVisibility);\n    SHOW_THEME_TOGGLE.addEventListener('change', updateButtonVisibility);\n    SHOW_NODE_ICONS.addEventListener('change', updateNodeIcons);\n    SHOW_COLLAPSE_ALL.addEventListener('change', updateButtonVisibility);\n}\n\n",
    "felix.20250921172409.1": "function handleOutlinePaneMouseDown(e) {\n    if (e.detail === 2) e.preventDefault(); // Prevent text selection on double-click\n}\n\nfunction handleOutlinePaneClick(event) {\n    const nodeEl = event.target.closest('.node');\n    if (!nodeEl) return;\n\n    const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\n    if (rowIndex < 0 || rowIndex >= flatRows.length) return;\n\n    const row = flatRows[rowIndex];\n\n    // Handle different click targets\n    if (event.target.classList.contains('caret') && row.hasChildren) {\n        event.stopPropagation();\n        // Both toggle and select in one operation\n        selectAndOrToggleAndRedraw(\n            row.node !== selectedNode ? row.node : null,\n            row.node\n        );\n    } else {\n        // Rest of the node (including icon and text)\n        event.stopPropagation();\n        if (row.node !== selectedNode) {\n            selectAndOrToggleAndRedraw(row.node); // Just selection\n        }\n    }\n}\n\nfunction handleOutlinePaneDblClick(event) {\n    if (event.target.classList.contains('node-text')) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        const nodeEl = event.target.closest('.node');\n        if (!nodeEl) return;\n\n        const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\n        if (rowIndex >= 0 && rowIndex < flatRows.length) {\n            const row = flatRows[rowIndex];\n            if (row.hasChildren) {\n                // Handle both selection and toggle in one update\n                selectAndOrToggleAndRedraw(\n                    row.node !== selectedNode ? row.node : null,\n                    row.node\n                );\n            }\n        }\n    }\n}\n\nfunction handleOutlinePaneKeyDown(e) {\n    const handler = outlinePaneKeyMap[e.key];\n    if (handler && !e.ctrlKey && !e.altKey && !e.metaKey) {\n        e.preventDefault();\n        handler();\n    }\n}\n\nfunction handleBodyPaneKeyDown(e) {\n    if (e.key === 'Tab') {\n        e.preventDefault();\n        OUTLINE_PANE.focus();\n    }\n}\n\nfunction startFind() {\n    initialFindNode = null; // If null, find next will set this, used with \"Suboutline Only\" find radio option (value: suboutline)\n    if (HTML_ELEMENT.getAttribute('data-show-config') === 'true') {\n        toggleConfiguration(); // // Make find input visible if in settings screen\n    }\n    FIND_INPUT.focus();\n    FIND_INPUT.select();\n    renderTree(); // To show or remove initial-find highlight\n}\n\n// Global key handlers (work anywhere)\nfunction handleGlobalKeyDown(e) {\n    if (e.key.toLowerCase() === 'f' && e.ctrlKey && !e.altKey && !e.metaKey) {\n        e.preventDefault();\n        startFind();\n    } else if (e.key.toLowerCase() === 'm' && e.ctrlKey && !e.altKey && !e.metaKey) {\n        e.preventDefault();\n        toggleMarkCurrentNode();\n    } else if (e.key === 'F2') {\n        e.preventDefault();\n        findPrevious();\n    } else if (e.key === 'F3') {\n        e.preventDefault();\n        findNext();\n    } else if (e.key === '-' && e.altKey && !e.ctrlKey && !e.metaKey) {\n        e.preventDefault();\n        collapseAll();\n    } else if (e.altKey && !e.ctrlKey && !e.metaKey) {\n        // Handle Alt+Arrow keys globally\n        switch (e.key) {\n            case 'ArrowUp':\n                e.preventDefault();\n                OUTLINE_PANE.focus();\n                selectVisBack();\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n                OUTLINE_PANE.focus();\n                selectVisNext();\n                break;\n            case 'ArrowLeft':\n                e.preventDefault();\n                OUTLINE_PANE.focus();\n                contractNodeOrGoToParent();\n                break;\n            case 'ArrowRight':\n                e.preventDefault();\n                OUTLINE_PANE.focus();\n                expandNodeAndGoToFirstChild();\n                break;\n        }\n    }\n}\n\nfunction handleWindowResize() {\n    updatePanelSizes();\n    renderTree();\n}\n\nfunction handleDOMContentLoaded() {\n    loadConfigPreferences();\n\n    const initialSelectedNode = loadDocumentStateFromLocalStorage();\n    if (!initialSelectedNode) {\n        selectAndOrToggleAndRedraw(tree.children[0]); // sets selectedNode amd flatRows\n    } else {\n        selectAndOrToggleAndRedraw(initialSelectedNode); // sets selectedNode amd flatRows\n        if (data[selectedNode.gnx]) {\n            BODY_PANE.textContent = data[selectedNode.gnx].bodyString || \"\";\n        }\n    }\n}\n\nfunction handleThemeToggleClick() {\n    // Only animate once button pressed, so page-load wont animate color changes.\n    HTML_ELEMENT.setAttribute('data-transition', 'true');\n    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n    applyTheme(newTheme);\n    renderTree(); // Re-render to update icon colors\n}\n\nfunction handleLayoutToggleClick() {\n    HTML_ELEMENT.setAttribute('data-transition', 'true');\n    const newLayout = currentLayout === 'vertical' ? 'horizontal' : 'vertical';\n    applyLayout(newLayout);\n}\n\nfunction updateButtonVisibility() {\n    toggleButtonVisibility(NEXT_MARKED_BTN, PREV_MARKED_BTN, SHOW_PREV_NEXT_MARK.checked);\n    toggleButtonVisibility(TOGGLE_MARK_BTN, null, SHOW_TOGGLE_MARK.checked);\n    toggleButtonVisibility(NEXT_BTN, PREV_BTN, SHOW_PREV_NEXT_HISTORY.checked);\n    toggleButtonVisibility(HOIST_BTN, DEHOIST_BTN, SHOW_HOIST_DEHOIST.checked);\n    toggleButtonVisibility(LAYOUT_TOGGLE, null, SHOW_LAYOUT_ORIENTATION.checked);\n    toggleButtonVisibility(THEME_TOGGLE, null, SHOW_THEME_TOGGLE.checked);\n    toggleButtonVisibility(COLLAPSE_ALL_BTN, null, SHOW_COLLAPSE_ALL.checked);\n}\n\nfunction updateNodeIcons() {\n    HTML_ELEMENT.setAttribute('data-show-icons', SHOW_NODE_ICONS.checked ? 'true' : 'false');\n    renderTree(); // Re-render to apply icon changes\n}\n\nfunction toggleButtonVisibility(button1, button2, isVisible) {\n    if (button1) {\n        button1.classList.toggle('hidden-button', !isVisible);\n    }\n    if (button2) {\n        button2.classList.toggle('hidden-button', !isVisible);\n    }\n}\n\n",
    "felix.20250921164204.1": "function saveAll() {\n    saveLayoutPreferences();\n    saveConfigPreferences();\n    saveDocumentStateToLocalStorage();\n}\n\nfunction saveDocumentStateToLocalStorage() {\n    // Use the allNodesInOrder tree, the full list from the top as if all nodes were expanded,\n    // to note the position of hoisted node(s), expanded node(s), and the currently selected node.\n    let hoistStackPositions = []; // empty means no hoist\n    for (const hoisted of hoistStack) {\n        const pos = allNodesInOrder.indexOf(hoisted);\n        if (pos !== -1) {\n            hoistStackPositions.push(pos);\n        }\n    }\n    const expandedPositions = [];\n    for (const node of expanded) {\n        const pos = allNodesInOrder.indexOf(node);\n        if (pos !== -1) {\n            expandedPositions.push(pos);\n        }\n    }\n    const selectedPosition = allNodesInOrder.indexOf(selectedNode); // -1 means no selection\n    const markedArray = Array.from(marked); // Marked are the gnx keys, not numeric positions from allNodesInOrder\n    const dataToSave = {\n        marked: markedArray,\n        hoistStack: hoistStackPositions,\n        selected: selectedPosition,\n        expanded: expandedPositions\n    };\n    safeLocalStorageSet(title + genTimestamp, JSON.stringify(dataToSave)); // Key is title + genTimestamp\n}\n\nfunction loadDocumentStateFromLocalStorage() {\n    // returns the selected node if found, otherwise null\n    let initialSelectedNode = null;\n    const savedData = safeLocalStorageGet(title + genTimestamp); // Key is title + genTimestamp\n    if (savedData) {\n        try {\n            const parsedData = JSON.parse(savedData);\n            // Start by rebuilding marked set and their related node icons\n            if (parsedData && Array.isArray(parsedData.marked)) {\n                marked.clear();\n                parsedData.marked.forEach(gnx => {\n                    marked.add(gnx);\n                    // Update icon state to reflect marked status\n                    if (data[gnx]) {\n                        data[gnx].icon = (data[gnx].icon || 0) | 2; // Set marked bit\n                    }\n                });\n            }\n            // If document stated data is found, rebuild hoist stack, expanded set, and selected node\n            if (parsedData && Array.isArray(parsedData.expanded) && Array.isArray(parsedData.hoistStack) && typeof parsedData.selected === 'number') {\n                const expandedPositions = parsedData.expanded;\n                let expandedPositionsIndex = 0;\n                const hoistPositions = parsedData.hoistStack;\n                const selectedPosition = parsedData.selected;\n\n                for (const hoisted of hoistPositions) {\n                    if (hoisted >= 0 && hoisted < allNodesInOrder.length) {\n                        hoistStack.push(allNodesInOrder[hoisted]);\n                    }\n                }\n                for (const node of expandedPositions) {\n                    if (node >= 0 && node < allNodesInOrder.length) {\n                        expanded.add(allNodesInOrder[node]);\n                    }\n                }\n                if (selectedPosition >= 0 && selectedPosition < allNodesInOrder.length) {\n                    initialSelectedNode = allNodesInOrder[selectedPosition];\n                }\n\n            }\n            return initialSelectedNode;\n\n        } catch (e) {\n            console.error('Error loading document state from localStorage:', e);\n        }\n    }\n}\n\nfunction saveLayoutPreferences() {\n    const layoutPreferences = {\n        mainRatio: mainRatio,\n        secondaryRatio: secondaryRatio,\n        theme: currentTheme,\n        layout: currentLayout\n    };\n    safeLocalStorageSet('layoutPreferences', JSON.stringify(layoutPreferences));\n}\n\nfunction saveConfigPreferences() {\n    const selectedFindScope = document.querySelector('input[name=\"find-scope\"]:checked')?.value || 'entire';\n\n    const preferences = {\n        showPrevNextMark: SHOW_PREV_NEXT_MARK.checked,\n        showToggleMark: SHOW_TOGGLE_MARK.checked,\n        showPrevNextHistory: SHOW_PREV_NEXT_HISTORY.checked,\n        showHoistDehoist: SHOW_HOIST_DEHOIST.checked,\n        showLayoutOrientation: SHOW_LAYOUT_ORIENTATION.checked,\n        showThemeToggle: SHOW_THEME_TOGGLE.checked,\n        showNodeIcons: SHOW_NODE_ICONS.checked,\n        showCollapseAll: SHOW_COLLAPSE_ALL.checked,\n        // Find-pane options\n        findWholeWord: OPT_WHOLE.checked,\n        findIgnoreCase: OPT_IGNORECASE.checked,\n        findRegexp: OPT_REGEXP.checked,\n        findMark: OPT_MARK.checked,\n        findHeadline: OPT_HEADLINE.checked,\n        findBody: OPT_BODY.checked,\n        findScope: selectedFindScope\n    };\n    safeLocalStorageSet('configPreferences', JSON.stringify(preferences));\n}\n\nfunction loadThemeAndLayoutPreferences() {\n    const savedPrefs = safeLocalStorageGet('layoutPreferences');\n    if (savedPrefs) {\n        try {\n            const prefs = JSON.parse(savedPrefs);\n            if (typeof prefs.mainRatio === 'number') {\n                mainRatio = prefs.mainRatio;\n            }\n            if (typeof prefs.secondaryRatio === 'number') {\n                secondaryRatio = prefs.secondaryRatio;\n            }\n            if (prefs.theme) {\n                applyTheme(prefs.theme);\n            }\n            if (prefs.layout) {\n                applyLayout(prefs.layout);\n            }\n        } catch (e) {\n            console.error('Error loading layout preferences:', e);\n        }\n    }\n}\n\nfunction loadConfigPreferences() {\n    const savedPrefs = safeLocalStorageGet('configPreferences');\n    if (savedPrefs) {\n        try {\n            const prefs = JSON.parse(savedPrefs);\n            SHOW_PREV_NEXT_MARK.checked = prefs.showPrevNextMark ?? false;\n            SHOW_TOGGLE_MARK.checked = prefs.showToggleMark ?? false;\n            SHOW_PREV_NEXT_HISTORY.checked = prefs.showPrevNextHistory ?? true;\n            SHOW_HOIST_DEHOIST.checked = prefs.showHoistDehoist ?? false;\n            SHOW_LAYOUT_ORIENTATION.checked = prefs.showLayoutOrientation ?? true;\n            SHOW_THEME_TOGGLE.checked = prefs.showThemeToggle ?? true;\n            SHOW_NODE_ICONS.checked = prefs.showNodeIcons ?? true;\n            SHOW_COLLAPSE_ALL.checked = prefs.showCollapseAll ?? true;\n\n            // Find-pane options\n            OPT_WHOLE.checked = prefs.findWholeWord ?? OPT_WHOLE.checked;\n            OPT_IGNORECASE.checked = prefs.findIgnoreCase ?? OPT_IGNORECASE.checked;\n            OPT_REGEXP.checked = prefs.findRegexp ?? OPT_REGEXP.checked;\n            OPT_MARK.checked = prefs.findMark ?? OPT_MARK.checked;\n            OPT_HEADLINE.checked = prefs.findHeadline ?? OPT_HEADLINE.checked;\n            OPT_BODY.checked = prefs.findBody ?? OPT_BODY.checked;\n\n            // Set the find scope radio\n            if (prefs.findScope) {\n                const scopeRadio = document.getElementById('scope-' + prefs.findScope);\n                if (scopeRadio) scopeRadio.checked = true;\n            }\n\n            updateButtonVisibility();\n            updateNodeIcons();\n        } catch (e) {\n            console.error('Error loading config preferences:', e);\n        }\n    } else {\n        updateButtonVisibility();\n        updateNodeIcons();\n    }\n}\n\n",
    "felix.20250921172713.1": "// Find functionality\nfunction findNext() {\n    if (!selectedNode) return; // No selection, nothing to search from\n    const searchText = FIND_INPUT.value.trim();\n    if (!searchText) {\n        showToast('Empty find pattern', 1500);\n        return; // Empty search, do nothing\n    }\n\n    const searchInBody = OPT_BODY.checked;\n    const searchInHeadlines = OPT_HEADLINE.checked;\n    const ignoreCase = OPT_IGNORECASE.checked;\n    const isRegexp = OPT_REGEXP.checked;\n    const wholeWord = OPT_WHOLE.checked;\n    const markFind = OPT_MARK.checked;\n\n    if (!searchInBody && !searchInHeadlines) {\n        showToast('not searching headline or body', 2000);\n        return; // Nothing to search in\n    }\n    if (!initialFindNode) {\n        initialFindNode = selectedNode; // Set initial find node if not already set\n    }\n\n    let selectedRadioValue = ''; // Falsy for now\n    const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\n    if (selectedRadio) {\n        selectedRadioValue = selectedRadio.value;\n    }\n\n    let pattern; // Create regex pattern based on search options\n    try {\n        if (isRegexp) {\n            pattern = searchText;\n        } else {\n            pattern = searchText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape special regex characters\n            if (wholeWord) {\n                pattern = '\\\\b' + pattern + '\\\\b'; // Add word boundaries if whole word option is enabled\n            }\n        }\n        const flags = ignoreCase ? 'gi' : 'g';\n        const regex = new RegExp(pattern, flags);\n\n        const startIndex = allNodesInOrder.indexOf(selectedNode);\n        if (startIndex === -1) return;\n\n        const totalNodes = allNodesInOrder.length;\n        let currentIndex = startIndex; // start from current selection\n\n        while (currentIndex < totalNodes) {\n            const node = allNodesInOrder[currentIndex];\n            if (selectedRadioValue === 'suboutline' && (initialFindNode !== node && isAncestorOf(initialFindNode, node) === false)) {\n                break; // Reached outside suboutline of initialFindNode\n            }\n\n            let headString = data[node.gnx]?.headString || \"\";\n            let body = data[node.gnx]?.bodyString || \"\";\n\n            // If searching headlines, check there first, but skip if the focus in in the body pane and its the currently selected node\n            if (searchInHeadlines && headString && !(node === selectedNode && findFocus() === 2)) {\n                regex.lastIndex = 0; // Reset regex state\n                let startOffset = 0;\n                // If this is the currently selected node, check for current selection range existing in selectedLabelElement with getSelection()\n                // and only search after that range. Keep that offset, if any, and apply it to the match index later.\n                if (node === selectedNode && selectedLabelElement) {\n                    const selection = window.getSelection();\n                    if (selection.rangeCount > 0) {\n                        const range = selection.getRangeAt(0);\n                        if (selectedLabelElement.contains(range.commonAncestorContainer)) {\n                            // Selection is inside the headline span\n                            startOffset = range.endOffset;\n                            headString = headString.substring(startOffset);\n                        }\n                    }\n                }\n\n                const match = regex.exec(headString);\n\n                if (match) {\n                    // If 'mark find' is checked, mark the found node if not already marked\n                    if (markFind) {\n                        if (!marked.has(node.gnx)) {\n                            marked.add(node.gnx);\n                            if (data[node.gnx]) {\n                                data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                            }\n                        }\n                    }\n                    selectAndOrToggleAndRedraw(node); // This also calls scrollSelectedNodeIntoView\n\n                    // Focus outline pane and highlight match\n                    if (findFocus() !== 1) {\n                        OUTLINE_PANE.focus();\n                    }\n\n                    // Highlight the match in the headline using selectedLabelElement\n                    setTimeout(() => {\n                        highlightMatchInHeadline(match.index + startOffset, match.index + startOffset + match[0].length);\n                    });\n\n                    return;\n                }\n            }\n\n            if (searchInBody && body) {\n                regex.lastIndex = 0; // Reset regex state\n\n                // If this is the currently selected node, check for current selection range existing in BODY_PANE with getSelection()\n                // and only search after that range. Keep that offset, if any, and apply it to the match index later.\n                let startOffset = 0;\n                if (node === selectedNode && BODY_PANE) {\n                    const selection = window.getSelection();\n                    if (selection.rangeCount > 0) {\n                        const range = selection.getRangeAt(0);\n                        if (BODY_PANE.contains(range.commonAncestorContainer)) {\n                            // Selection is inside the body pane\n                            startOffset = range.endOffset;\n                            body = body.substring(startOffset);\n                        }\n                    }\n                }\n\n                const match = regex.exec(body);\n                if (match) {\n                    if (markFind) {\n                        if (!marked.has(node.gnx)) {\n                            marked.add(node.gnx);\n                            if (data[node.gnx]) {\n                                data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                            }\n                        }\n                    }\n                    selectAndOrToggleAndRedraw(node); // This also calls scrollSelectedNodeIntoView\n                    if (findFocus() !== 2) {\n                        BODY_PANE.focus();\n                    }\n                    setTimeout(() => {\n                        highlightMatchInBody(match.index + startOffset, match.index + startOffset + match[0].length);\n                    });\n                    return;\n                }\n            }\n            if (selectedRadioValue === 'nodeonly') {\n                break; // Only search current node\n            }\n            currentIndex++;\n        }\n\n        let searchedParams = [];\n        if (searchInHeadlines) searchedParams.push('head');\n        if (searchInBody) searchedParams.push('body');\n        showToast(`Not found: (${searchedParams.join(\", \")}) ${searchText}`, 1500);\n\n    } catch (e) {\n        showToast('Invalid search pattern: ' + e.message, 2000);\n    }\n\n}\n\nfunction findPrevious() {\n    if (!selectedNode) return; // No selection, nothing to search from\n    const searchText = FIND_INPUT.value.trim();\n    if (!searchText) {\n        showToast('Empty find pattern', 1500);\n        return; // Empty search, do nothing\n    }\n\n    const searchInBody = OPT_BODY.checked;\n    const searchInHeadlines = OPT_HEADLINE.checked;\n    const ignoreCase = OPT_IGNORECASE.checked;\n    const isRegexp = OPT_REGEXP.checked;\n    const wholeWord = OPT_WHOLE.checked;\n    const markFind = OPT_MARK.checked;\n\n    if (!searchInBody && !searchInHeadlines) {\n        showToast('not searching headline or body', 2000);\n        return; // Nothing to search in\n    }\n    if (!initialFindNode) {\n        initialFindNode = selectedNode; // Set initial find node if not already set\n    }\n\n    let selectedRadioValue = ''; // Falsy for now\n    const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\n    if (selectedRadio) {\n        selectedRadioValue = selectedRadio.value;\n    }\n\n    let pattern; // Create regex pattern based on search options\n    try {\n        if (isRegexp) {\n            pattern = searchText;\n        } else {\n            pattern = searchText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape special regex characters\n            if (wholeWord) {\n                pattern = '\\\\b' + pattern + '\\\\b'; // Add word boundaries if whole word option is enabled\n            }\n        }\n        const flags = ignoreCase ? 'gi' : 'g';\n        const regex = new RegExp(pattern, flags);\n\n        const startIndex = allNodesInOrder.indexOf(selectedNode);\n        if (startIndex === -1) return;\n\n        // Helper function to find the last match in a string\n        function findLastMatch(str) {\n            let lastMatchIndex = -1;\n            let lastMatchLength = 0;\n\n            let match;\n            while ((match = regex.exec(str)) !== null) {\n                lastMatchIndex = match.index;\n                lastMatchLength = match[0].length;\n                // Prevent infinite loop for zero-width matches\n                if (regex.lastIndex === match.index) regex.lastIndex++;\n            }\n\n            return lastMatchIndex !== -1 ? { index: lastMatchIndex, length: lastMatchLength } : null;\n        }\n\n        // Flag to track if we found a match in the current node\n        let foundMatchInCurrentNode = false;\n\n        // First, check the current node with respect to the current selection\n        const node = selectedNode;\n        let headString = data[node.gnx]?.headString || \"\";\n        let body = data[node.gnx]?.bodyString || \"\";\n\n        // Get current selection info\n        const selection = window.getSelection();\n        let headlineOffset = Infinity;\n        let bodyOffset = Infinity;\n\n        if (selection.rangeCount > 0) {\n            const range = selection.getRangeAt(0);\n            if (selectedLabelElement && selectedLabelElement.contains(range.commonAncestorContainer)) {\n                // Selection is in headline\n                headlineOffset = range.startOffset;\n            } else if (BODY_PANE.contains(range.commonAncestorContainer)) {\n                // Selection is in body\n                bodyOffset = range.startOffset;\n            }\n        }\n\n        const currentFocus = findFocus();\n\n        // Check current node based on focus\n        if (currentFocus === 2 && searchInBody && body) {\n            // If focused in body, check body first\n            const limitedBody = body.substring(0, bodyOffset);\n            const match = findLastMatch(limitedBody);\n\n            if (match) {\n                if (markFind && !marked.has(node.gnx)) {\n                    marked.add(node.gnx);\n                    if (data[node.gnx]) {\n                        data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                    }\n                }\n                selectAndOrToggleAndRedraw(node);\n                BODY_PANE.focus();\n                setTimeout(() => {\n                    highlightMatchInBody(match.index, match.index + match.length);\n                });\n                return;\n            }\n        }\n\n        // Check headline if appropriate\n        if (searchInHeadlines && headString) {\n            const limitedHeadline = currentFocus !== 2 ? headString.substring(0, headlineOffset) : headString;\n            const match = findLastMatch(limitedHeadline);\n\n            if (match) {\n                if (markFind && !marked.has(node.gnx)) {\n                    marked.add(node.gnx);\n                    if (data[node.gnx]) {\n                        data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                    }\n                }\n                selectAndOrToggleAndRedraw(node);\n                OUTLINE_PANE.focus();\n                setTimeout(() => {\n                    highlightMatchInHeadline(match.index, match.index + match.length);\n                });\n                return;\n            }\n        }\n\n        // Continue searching through previous nodes if no match was found in current node\n        let currentIndex = startIndex - 1;\n\n        while (currentIndex >= 0) {\n            const node = allNodesInOrder[currentIndex];\n            if (selectedRadioValue === 'nodeonly') {\n                break; // Only search current node\n            }\n            if (selectedRadioValue === 'suboutline' && (initialFindNode !== node && isAncestorOf(initialFindNode, node) === false)) {\n                break; // Reached outside suboutline of initialFindNode\n            }\n            let headString = data[node.gnx]?.headString || \"\";\n            let body = data[node.gnx]?.bodyString || \"\";\n\n            // In previous nodes, check body first (since we're going backward)\n            if (searchInBody && body) {\n                const match = findLastMatch(body);\n                if (match) {\n                    if (markFind && !marked.has(node.gnx)) {\n                        marked.add(node.gnx);\n                        if (data[node.gnx]) {\n                            data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                        }\n                    }\n                    selectAndOrToggleAndRedraw(node);\n                    BODY_PANE.focus();\n                    setTimeout(() => {\n                        highlightMatchInBody(match.index, match.index + match.length);\n                    });\n                    return;\n                }\n            }\n\n            // Then check headline\n            if (searchInHeadlines && headString) {\n                const match = findLastMatch(headString);\n\n                if (match) {\n                    if (markFind && !marked.has(node.gnx)) {\n                        marked.add(node.gnx);\n                        if (data[node.gnx]) {\n                            data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\n                        }\n                    }\n\n                    selectAndOrToggleAndRedraw(node);\n                    OUTLINE_PANE.focus();\n                    setTimeout(() => {\n                        highlightMatchInHeadline(match.index, match.index + match.length);\n                    });\n                    return;\n                }\n            }\n            currentIndex--;\n        }\n\n        let searchedParams = [];\n        if (searchInHeadlines) searchedParams.push('head');\n        if (searchInBody) searchedParams.push('body');\n        showToast(`Not found: (${searchedParams.join(\", \")}) ${searchText}`, 1500);\n    } catch (e) {\n        showToast('Invalid search pattern: ' + e.message, 2000);\n    }\n}\n\nfunction highlightMatchInHeadline(startIndex, endIndex) {\n    // Use the global selectedLabelElement which is already set after selectAndOrToggleAndRedraw\n    if (!selectedLabelElement) return;\n    // Find the first text node in the label element\n    let textNode = null;\n    for (const node of selectedLabelElement.childNodes) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            textNode = node;\n            break;\n        }\n    }\n    if (!textNode) return;\n    try {\n        const range = document.createRange();\n        range.setStart(textNode, startIndex);\n        range.setEnd(textNode, endIndex);\n\n        const selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(range);\n    } catch (e) {\n        console.error('Error setting headline selection:', e);\n    }\n}\n\nfunction highlightMatchInBody(startIndex, endIndex) {\n    // The body pane content is set directly as textContent, so it's a single text node\n    if (!BODY_PANE.firstChild || BODY_PANE.firstChild.nodeType !== Node.TEXT_NODE) return;\n    try {\n        const range = document.createRange();\n        range.setStart(BODY_PANE.firstChild, startIndex);\n        range.setEnd(BODY_PANE.firstChild, endIndex);\n\n        const selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(range);\n    } catch (e) {\n        console.error('Error setting body selection:', e);\n    }\n}\n\nfunction findFocus() {\n    // Returns 1 if focus in outline-pane, 2 if in body-pane, 0 otherwise\n    if (document.activeElement === OUTLINE_PANE || OUTLINE_PANE.contains(document.activeElement)) {\n        return 1;\n    } else if (document.activeElement === BODY_PANE || BODY_PANE.contains(document.activeElement)) {\n        return 2;\n    }\n    return 0;\n}\n\n",
    "felix.20250921173505.1": "function initializeThemeAndLayout() {\n    document.title = title; // Set the document title\n    loadThemeAndLayoutPreferences();\n    updateMarkedButtonStates();\n    updateHoistButtonStates();\n    setupEventHandlers();\n    setupButtonFocusPrevention();\n}\n\n// Apply theme & layout before anything else to avoid flash of unstyled content\ninitializeThemeAndLayout(); // gets ratios from localStorage and applies layout and theme\n// Start everything once DOM is loaded\nwindow.addEventListener('DOMContentLoaded', handleDOMContentLoaded);\n\n"
  }
}