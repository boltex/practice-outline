<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Outline Demo</title>
    <style>
        body {
            margin: 0;
            display: flex;
            height: 100vh;
        }

        body.dragging {
            cursor: ew-resize !important;
        }

        #outline-pane {
            width: 250px;
            white-space: nowrap;
            background: #ffffec;
            padding: 1rem 0 0 0;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: sans-serif;
        }

        #resizer {
            width: 5px;
            cursor: ew-resize;
            background: #cae1ff;
        }

        #body-pane {
            flex: 1;
            padding: 1rem 0 0 1rem;
            background: #fff6f5;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
        }

        #outline-pane:focus,
        #body-pane:focus,
        #outline-pane:focus-visible,
        #body-pane:focus-visible {
            outline: 3px solid blue;
            outline-offset: -3px;
        }

        /* Tree styling */
        ul {
            list-style: none;
            padding-left: 1rem;
            margin: 0;
        }

        /* Each list item: 2-column grid (caret | label) */
        li {
            display: grid;
            grid-template-columns: 1em 1fr;
            align-items: start;
            row-gap: 2px;
            /* space between the row and its children */
            padding: 2px 0;
        }

        /* Caret stays a small target in the first column */
        li>.caret {
            grid-column: 1;
            display: inline-block;
            width: 1em;
            cursor: pointer;
            user-select: none;
        }

        /* Caret glyphs */
        li>.caret::after {
            content: "â¯";
            display: inline-block;
            transform-origin: 50% 50%;
            transition: transform 160ms cubic-bezier(.2, .9, .3, 1), color 120ms;
            transform: rotate(0deg);
        }

        li[data-expanded="true"]>.caret::after {
            transform: rotate(90deg);
            color: inherit;
        }

        li[data-expanded="false"]>.caret::after {
            transform: rotate(0deg);
            color: #888;
        }

        /* Label fills remaining width in second column with 'block' */
        li>.node-text {
            grid-column: 2;
            display: block;
            cursor: pointer;
            padding: 2px 4px;
            margin-right: 1rem;
            border-radius: 4px;
        }

        /* Selected + ancestor styles still just target the label */
        li.selected>.node-text {
            background: #cae1ff;
        }

        li.ancestor>.node-text {
            background: #eef5ff;
        }

        /* Children appear underneath the row, same indentation as before */
        li>ul {
            grid-column: 1 / -1;
            margin: 0;
            padding-left: 1rem;
        }

        /* Hide caret if there are no children */
        li:has(> ul:empty)>.caret {
            visibility: hidden;
        }

        /* Collapse children when needed */
        li[data-expanded="false"]>ul {
            display: none;
        }
    </style>
</head>

<body>
    <!-- 
    'li' elements represent nodes. They each have a caret, text span and a single 'ul' for children.
    data-id distinguishes node positions, the data-gnx identifies body content.
    1 body can be used in multiple positions (nodes) that's why data-id and data-gnx differ.
    (TODO: data-id MAY be omitted if not needed.)
    data-expanded controls whether children are shown or hidden.
    Clicking the caret expands/collapses and selects the node. Clickng the text selects only.
    -->
    <div id="outline-pane" tabindex="0">
        <ul>
            <li data-id="1" data-gnx="1" data-expanded="false">
                <span class="caret"></span><span class="node-text">Section 1</span>
                <ul>
                    <li data-id="2" data-gnx="2" data-expanded="false">
                        <span class="caret"></span><span class="node-text">Page A</span>
                        <ul>
                            <li data-id="3" data-gnx="3" data-expanded="false">
                                <span class="caret"></span><span class="node-text">Subpage A.1</span>
                                <ul></ul>
                            </li>
                            <li data-id="4" data-gnx="4" data-expanded="false">
                                <span class="caret"></span><span class="node-text">Subpage A.2</span>
                                <ul></ul>
                            </li>
                        </ul>
                    </li>
                    <li data-id="5" data-gnx="5" data-expanded="false">
                        <span class="caret"></span><span class="node-text">Page B</span>
                        <ul></ul>
                    </li>
                </ul>
            </li>
            <li data-id="6" data-gnx="6" data-expanded="false">
                <span class="caret"></span><span class="node-text">Section 2</span>
                <ul>
                    <li data-id="7" data-gnx="7" data-expanded="false">
                        <span class="caret"></span><span class="node-text">Page C (Repeated)</span>
                        <ul></ul>
                    </li>
                    <li data-id="8" data-gnx="8" data-expanded="false">
                        <span class="caret"></span><span class="node-text">Page D</span>
                        <ul></ul>
                    </li>
                    <li data-id="9" data-gnx="7" data-expanded="false">
                        <span class="caret"></span><span class="node-text">Page C (Repeated)</span>
                        <ul></ul>
                    </li>
                </ul>
            </li>
        </ul>
    </div>

    <div id="resizer"></div>

    <div id="body-pane" tabindex="0" contenteditable="plaintext-only"></div>

    <script>
        const bodies = {
            "1": "Section 1 content here\nMultiple lines supported.",
            "2": "Page A content here\nMore text.",
            "3": "Subpage A.1 content here",
            "4": "Subpage A.2 content here",
            "5": "Page B content here",
            "6": "Section 2 content here",
            "7": "Page C (Repeated) content here\nSame (body content) GNX used twice, with different (position) IDs.",
            "8": "Page D content here"
        };

        document.addEventListener("DOMContentLoaded", () => {
            const lis = document.querySelectorAll("#outline-pane li");
            const bodyDiv = document.getElementById("body-pane");
            const resizer = document.getElementById('resizer');
            const outlineDiv = document.getElementById('outline-pane');
            const minWidth = 0;
            let selectedLi = null;
            let outlineProportion;
            let isDragging = false;

            // Navigation helpers
            const children = (p) => {
                // Given an 'li' position element, return an array of its child 'li' elements.
                const ul = p.querySelector('ul');
                if (ul) {
                    return Array.from(ul.children).filter(c => c.tagName === 'LI');
                }
                return [];
            };

            const childIndex = (p) => {
                // Given an 'li' position element, return its index among its siblings (0 for first, 1 for second, etc).
                const parent = p.parentElement.closest('li, #outline-pane'); // include #outline-pane for top-level nodes
                if (parent) {
                    const children = Array.from(parent.querySelectorAll(':scope > ul > li'));
                    return children.indexOf(p);
                }
                return 0; // Should not happen for valid nodes because the top nodes are in the #outline-pane div
            };

            const parents = (p) => {
                // Given an 'li' position element, return an array of its ancestor 'li' elements, closest first.
                const ancestors = [];
                let current = p;
                while (current) {
                    const parent = current.parentElement.closest('li');
                    if (parent) {
                        ancestors.push(parent);
                    }
                    current = parent;
                }
                return ancestors;
            };

            const hasChildren = (p) => {
                // Given an 'li' position element, return true if it has children.
                const ul = p.querySelector('ul');
                return ul && ul.children.length > 0;
            };

            const numberOfChildren = (p) => {
                // Given an 'li' position element, return the number of children it has.
                const ul = p.querySelector('ul');
                return ul ? ul.children.length : 0;
            };

            const isCloned = (p) => {
                // Given an 'li' position element, return true if it is a clone (another node shares its gnx).
                const gnx = p.getAttribute('data-gnx');
                let count = 0;
                document.querySelectorAll(`#outline-pane li[data-gnx="${gnx}"]`).forEach(() => count++);
                return count > 1;
            };

            const isExpanded = (p) => {
                // Given an 'li' position element, return true if it is expanded.
                return p.getAttribute('data-expanded') === 'true';
            };

            const isVisible = (p) => {
                // Given an 'li' position element, return true if all its ancestors are expanded. (but not neccessarily itself)
                let current = p;
                while (current) {
                    const parent = current.parentElement.closest('li');
                    if (parent) {
                        if (parent.getAttribute('data-expanded') !== 'true') {
                            return false;
                        }
                    }
                    current = parent;
                }
                return true;
            };

            const isAncestorOf = (p, p2) => {
                // Return True if p is one of the direct ancestors of p2.
                let current = p2;
                while (current) {
                    const parent = current.parentElement.closest('li');
                    if (parent) {
                        if (parent === p) {
                            return true;
                        }
                    } else {
                        return false;
                    }
                    current = parent;
                }
                return false;
            };

            const level = (p) => {
                // Given an 'li' position element, return its level (0 for top-level, 1 for children, etc).
                let lvl = 0;
                let current = p;
                while (current) {
                    const parent = current.parentElement.closest('li');
                    if (parent) {
                        lvl++;
                    }
                    current = parent;
                }
                return lvl;
            };

            const hasBack = (p) => {
                // Given an 'li' position element, return true if it has a previous sibling.
                const parent = p.parentElement.closest('li');
                if (parent) {
                    const prev = p.previousElementSibling;
                    return prev && prev.tagName === 'LI';
                }
                return false;
            };

            const hasNext = (p) => {
                // Given an 'li' position element, return true if it has a next sibling.
                const parent = p.parentElement.closest('li');
                if (parent) {
                    const next = p.nextElementSibling;
                    return next && next.tagName === 'LI';
                }
                return false;
            };

            const hasParent = (p) => {
                // Given an 'li' position element, return true if it has a parent.
                const parent = p.parentElement.closest('li');
                return !!parent;
            };

            const hasThreadBack = (p) => {
                // Much cheaper than computing the actual value.
                return hasBack(p) || hasParent(p);
            }

            const moveToBack = (p) => {
                // Given an 'li' position element, return its previous 'li' sibling. If first, or no parent, return null.
                const parent = p.parentElement.closest('li');
                if (parent) {
                    const prev = p.previousElementSibling;
                    if (prev && prev.tagName === 'LI') {
                        return prev;
                    }
                }
                return null;
            };

            const moveToFirstChild = (p) => {
                // Given an 'li' position element, return its first child 'li' if any. Else return null.
                const ul = p.querySelector('ul');
                if (ul && ul.children.length > 0) {
                    return ul.children[0];
                }
                return null;
            };

            const moveToLastChild = (p) => {
                // Given an 'li' position element, return its last child 'li' if any. Else return null.
                const ul = p.querySelector('ul');
                if (ul && ul.children.length > 0) {
                    return ul.children[ul.children.length - 1];
                }
                return null;
            };

            const moveToLastNode = (p) => {
                // Given an 'li' position element, return the last node of its tree or itself if no children.
                let current = p;
                while (hasChildren(current)) {
                    current = moveToLastChild(current);
                }
                return current;
            };

            const moveToNext = (p) => {
                // Given an 'li' position element, return its next sibling. If already last, return null.
                const parent = p.parentElement.closest('li');
                if (parent) {
                    const next = p.nextElementSibling;
                    if (next && next.tagName === 'LI') {
                        return next;
                    }
                }
                return null;
            };

            const moveToNodeAfterTree = (p) => {
                // Given an 'li' position element, return the node after the position's tree.
                // TODO , the original python from the Leo Editor is
                /*
                    while p:
                        if p.hasNext():
                            p.moveToNext()
                            break
                        p.moveToParent()
                    return p
                */

            };

            const moveToNthChild = (p, n) => {
                // Given an 'li' position element, return its nth child 'li' if it exists. Else return null.
                const ul = p.querySelector('ul');
                if (ul && ul.children.length > n) {
                    return ul.children[n];
                }
                return null;
            };

            const moveToParent = (p) => {
                // Given an 'li' position element, return its parent 'li' if any. Else return null.
                const parent = p.parentElement.closest('li');
                if (parent) {
                    return parent;
                }
                return null;
            };

            // Keyboard navigation and focus management
            outlineDiv.addEventListener('dblclick', (event) => {
                if (event.target.classList.contains('node-text')) {
                    console.log(`Double-Clicked on ${event.target.textContent} TODO: allow rename and copy to clones if any on enter/escape/blur`);
                }
            });

            outlineDiv.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    e.preventDefault();
                    bodyDiv.focus();
                }

                // Arrow keys
                else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    // TODO: Navigate to previous visible node in outline
                }
                else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    // TODO: Navigate to next visible node in outline
                }
                else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    // TODO: Collapse current node if expanded, or navigate to parent
                }
                else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    // TODO: Expand current node if collapsed, or navigate to first child
                }

                // Page navigation
                else if (e.key === 'PageUp') {
                    e.preventDefault();
                    // TODO: Navigate multiple nodes up (viewport height)
                }
                else if (e.key === 'PageDown') {
                    e.preventDefault();
                    // TODO: Navigate multiple nodes down (viewport height)
                }

                // Home/End
                else if (e.key === 'Home') {
                    e.preventDefault();
                    // TODO: Navigate to first node in outline
                }
                else if (e.key === 'End') {
                    e.preventDefault();
                    // TODO: Navigate to last visible node in outline
                }
            });

            bodyDiv.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    e.preventDefault();
                    outlineDiv.focus();
                }
            });

            function updateProportion() {
                outlineProportion = outlineDiv.offsetWidth / window.innerWidth;
            }

            const throttle = (func, limit) => {
                let lastCall = 0;
                let timeout;

                return function (...args) {
                    const now = Date.now();
                    const context = this;
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    if (now - lastCall >= limit) {
                        lastCall = now;
                        func.apply(context, args);
                    } else {
                        timeout = setTimeout(() => {
                            lastCall = Date.now();
                            func.apply(context, args);
                        }, limit - (now - lastCall));
                    }
                };
            };

            const updateOutlineWidth = throttle(() => {
                let newWidth = window.innerWidth * outlineProportion;
                // Respect minimum width
                if (newWidth < minWidth) {
                    newWidth = minWidth;
                }
                outlineDiv.style.width = `${newWidth}px`;
            }, 125);

            const handleDrag = throttle((e) => {
                let clientX = e.clientX;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                }
                const newWidth = clientX;

                if (newWidth >= minWidth) {
                    outlineDiv.style.width = newWidth + 'px';
                } else {
                    outlineDiv.style.width = minWidth + 'px';
                }
            }, 125);

            const stopDrag = () => {
                if (isDragging) {
                    isDragging = false;
                    document.body.classList.remove('dragging');
                    document.removeEventListener('mousemove', handleDrag);
                    document.removeEventListener('mouseup', stopDrag);
                    document.removeEventListener('touchmove', handleDrag);
                    document.removeEventListener('touchend', stopDrag);
                    updateProportion();
                }
            };

            const startDrag = (e) => {
                isDragging = true;
                document.body.classList.add('dragging');
                e.preventDefault();
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchmove', handleDrag, { passive: false });
                document.addEventListener('touchend', stopDrag);
            };

            resizer.addEventListener('mousedown', startDrag);
            resizer.addEventListener('touchstart', startDrag);

            updateProportion();

            window.addEventListener('resize', updateOutlineWidth);

            function selectNode(li) {
                if (selectedLi) selectedLi.classList.remove("selected");

                // Remove previous ancestor highlights
                document.querySelectorAll("#outline-pane li.ancestor").forEach(a => a.classList.remove("ancestor"));

                // The body-pane is contenteditable, so grab its content before changing focus
                if (selectedLi) {
                    const prevGnx = selectedLi.getAttribute("data-gnx");
                    bodies[prevGnx] = bodyDiv.textContent;
                }

                li.classList.add("selected");
                selectedLi = li;

                // Highlight ancestors
                let parent = li.parentElement;
                while (parent && parent.classList) {
                    if (parent.tagName === "LI") {
                        parent.classList.add("ancestor");
                    }
                    parent = parent.parentElement; // move up to the LI parent
                }

                // Show body content
                const gnx = li.getAttribute("data-gnx");
                bodyDiv.textContent = bodies[gnx] || "";
            }

            // Caret click: toggle expand + select
            document.querySelectorAll("#outline-pane .caret").forEach(caret => {
                caret.addEventListener("click", e => {
                    e.stopPropagation();
                    const li = caret.parentElement;
                    const expanded = li.getAttribute("data-expanded") === "true";
                    li.setAttribute("data-expanded", expanded ? "false" : "true");
                    selectNode(li);
                });
            });

            // Text click: select only
            document.querySelectorAll("#outline-pane li > span.node-text").forEach(span => {
                span.addEventListener("click", e => {
                    e.stopPropagation();
                    selectNode(span.parentElement);
                });
            });

            // Auto-select first node
            if (lis.length > 0) selectNode(lis[0]);
        });
    </script>

</body>

</html>