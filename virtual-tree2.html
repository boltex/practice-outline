<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Virtualised Tree</title>
    <style>
        :root {
            /* -------------------------------------- Light theme (default) */
            --background-color: #ffffec;
            --body-pane-color: #fff6f5;
            --find-pane-color: #f9f9f9;
            --resizer-color: #cae1ff;
            --selected-bg: #cae1ff;
            --ancestor-bg: #eef5ff;
            --hover-bg: #dfecff;
            --focus-outline: #0000ff;
            --text-color: #000000;
            --caret-dim-color: #888;
            /* -------------------------------------- vertical layout (default) */
            /* body contains both outline-find-container, main splitter and body-pane */
            --main-direction: row;

            --main-resizer-width: 5px;
            --main-resizer-height: 100%;
            --main-resizer-cursor: ew-resize;

            --main-resizer-extension-width: 5px;
            --main-resizer-extension-height: 100%;

            --main-resizer-before-top: unset;
            --main-resizer-before-left: -5px;
            --main-resizer-after-right: -5px;
            --main-resizer-after-bottom: unset;

            /* outline-find-container contains outline-pane, secondary splitter and find-pane */
            --secondary-direction: column;
            --secondary-height: 100%;

            --secondary-resizer-width: 100%;
            --secondary-resizer-height: 5px;
            --secondary-resizer-cursor: ns-resize;

            --secondary-resizer-extension-width: 100%;
            --secondary-resizer-extension-height: 5px;

            --secondary-resizer-before-top: -5px;
            --secondary-resizer-before-left: unset;
            --secondary-resizer-after-right: unset;
            --secondary-resizer-after-bottom: -5px;
        }

        [data-theme="dark"] {
            /* Dark theme */
            --background-color: #1e1e2e;
            --body-pane-color: #2a2536;
            --find-pane-color: #23202e;
            --resizer-color: #454a6e;
            --selected-bg: #454a6e;
            --ancestor-bg: #2d3250;
            --hover-bg: #3a3f5e;
            --focus-outline: #7aa2f7;
            --text-color: #cdd6f4;
            --caret-dim-color: #999;
        }

        [data-layout="horizontal"] {
            /* horizontal layout */
            /* body contains both outline-find-container, main splitter and body-pane */
            --main-direction: column;

            --main-resizer-width: 100%;
            --main-resizer-height: 5px;
            --main-resizer-cursor: ns-resize;

            --main-resizer-extension-width: 100%;
            --main-resizer-extension-height: 5px;

            --main-resizer-before-top: -5px;
            --main-resizer-before-left: unset;
            --main-resizer-after-right: unset;
            --main-resizer-after-bottom: -5px;

            /* outline-find-container contains outline-pane, secondary splitter and find-pane */
            --secondary-direction: row;
            --secondary-height: 100%;

            --secondary-resizer-width: 5px;
            --secondary-resizer-height: 100%;
            --secondary-resizer-cursor: ew-resize;

            --secondary-resizer-extension-width: 5px;
            --secondary-resizer-extension-height: 100%;

            --secondary-resizer-before-top: unset;
            --secondary-resizer-before-left: -5px;
            --secondary-resizer-after-right: -5px;
            --secondary-resizer-after-bottom: unset;
        }

        .icon0 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/></svg>');
        }

        .icon1 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/></svg>');
        }

        .icon2 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/></svg>');
        }

        .icon3 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none">   <path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/></svg>');
        }

        .icon4 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon5 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon6 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon7 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%234d4d4d"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon8 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/></svg>');
        }

        .icon9 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/></svg>');
        }

        .icon10 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/></svg>');
        }

        .icon11 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/></svg>');
        }

        .icon12 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon13 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon14 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        .icon15 {
            background-image: url('data:image/svg+xml;utf8, <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"><path d="M7.074 4.5v8h1v-8z" fill="%23e54a16"/><path d="M0 4v9h15.15V4zm1 1h13.15v7H1z" fill="%23a4a59e"/><path d="M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z" fill="%2342a5f5"/><path d="M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z" fill="%23e54a16"/></svg>');
        }

        body {
            margin: 0;
            display: flex;
            flex-direction: var(--main-direction);
            height: 100vh;
            background-color: var(--background-color);
            color: var(--text-color);
        }

        [data-transition="true"] body {
            transition: color 0.15s ease, background-color 0.15s ease;
        }

        body.dragging-main {
            cursor: var(--main-resizer-cursor) !important;
        }

        body.dragging-secondary {
            cursor: var(--secondary-resizer-cursor) !important;
        }

        #outline-pane {
            white-space: nowrap;
            /* TODO : PADDING */
            /* padding: 1rem 0 0 0; */
            overflow-x: hidden;
            overflow-y: auto;
            font-family: sans-serif;
        }

        #main-resizer {
            position: relative;
            width: var(--main-resizer-width);
            height: var(--main-resizer-height);
            cursor: var(--main-resizer-cursor);
            background-color: var(--resizer-color);
        }

        #main-resizer::before,
        #main-resizer::after {
            /* Invisible extension width extended with before/after below */
            content: "";
            position: absolute;
            height: var(--main-resizer-extension-height);
            width: var(--main-resizer-extension-width);
            cursor: var(--main-resizer-cursor);
        }

        #main-resizer::before {
            top: var(--main-resizer-before-top);
            left: var(--main-resizer-before-left)
        }

        #main-resizer::after {
            right: var(--main-resizer-after-right);
            bottom: var(--main-resizer-after-bottom)
        }

        #outline-find-container {
            display: flex;
            flex-direction: var(--secondary-direction);
            height: var(--secondary-height);
            overflow: hidden;
        }

        #secondary-resizer {
            position: relative;
            height: var(--secondary-resizer-height);
            width: var(--secondary-resizer-width);
            cursor: var(--secondary-resizer-cursor);
            background-color: var(--resizer-color);
        }

        #secondary-resizer::before,
        #secondary-resizer::after {
            content: "";
            position: absolute;
            width: var(--secondary-resizer-extension-width);
            height: var(--secondary-resizer-extension-height);
            cursor: var(--secondary-resizer-cursor);
        }

        #secondary-resizer::before {
            top: var(--secondary-resizer-before-top);
            left: var(--secondary-resizer-before-left);
        }

        #secondary-resizer::after {
            bottom: var(--secondary-resizer-after-bottom);
            right: var(--secondary-resizer-after-right);
        }

        #outline-pane,
        #find-pane {
            overflow-y: auto;
            flex: 1 1 0;
        }

        #find-pane {
            background-color: var(--find-pane-color);
        }

        [data-transition="true"] #find-pane {
            transition: color 0.15s ease, background-color 0.15s ease;
        }

        #body-pane {
            flex: 1;
            padding: 1rem 0 0 1rem;
            background-color: var(--body-pane-color);
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
        }

        [data-transition="true"] #body-pane {
            transition: color 0.3s ease, background-color 0.3s ease;
        }

        #outline-pane:focus,
        #body-pane:focus,
        #outline-pane:focus-visible,
        #body-pane:focus-visible {
            /* 
              Note: Outline will appear under the items positioned absolutely.
              see pseudo-elements with "z-index: -1" that appear below this outline.
             */
            outline: 3px solid var(--focus-outline);
            outline-offset: -3px;
        }

        .node-text {
            position: relative;
        }

        .node-text:hover::before,
        .selected>.node-text::before,
        .ancestor>.node-text::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            border-radius: 4px;
        }

        .selected>.node-text::before,
        .selected>.node-text:hover::before {
            background-color: var(--selected-bg);
        }

        .ancestor>.node-text::before {
            background-color: var(--ancestor-bg);
        }

        .node-text:hover::before {
            background-color: var(--hover-bg);
        }

        .node {
            position: absolute;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            display: grid;
            grid-template-columns: 1em 1fr;
            align-items: start;
        }

        body.dragging-main .node {
            cursor: var(--main-resizer-cursor);
        }

        body.dragging-secondary .node {
            cursor: var(--secondary-resizer-cursor);
        }

        .caret {
            grid-column: 1;
            display: inline-block;
            width: 32px;
            height: 26px;
            position: relative;
            left: -16px;
            user-select: none;
        }

        .node-text {
            background-repeat: no-repeat;
            background-position-x: 3px;
            background-position-y: 2px;
            background-size: 18px 18px;
            grid-column: 2;
            display: block;
            padding: 2px 0 2px 26px;
            margin-right: 1rem;
            border-radius: 4px;
        }

        .caret::after {
            display: inline-block;
            position: relative;
            left: 16px;
            transform-origin: 50% 50%;
            transition: transform 160ms cubic-bezier(.2, .9, .3, 1), color 120ms;
        }

        .caret[data-expanded="true"]::after {
            content: "❯";
            transform: rotate(90deg);
        }

        .caret[data-expanded="false"]::after {
            content: "❯";
            transform: rotate(0deg);
            color: var(--caret-dim-color);
        }

        .caret.toggled[data-expanded="true"]::after {
            content: "❯";
            transform: rotate(90deg);
            animation: rotateOpen 120ms ease-out;
        }

        .caret.toggled[data-expanded="false"]::after {
            content: "❯";
            transform: rotate(0deg);
            color: var(--caret-dim-color);
            animation: rotateClose 120ms ease-out;
        }

        @keyframes rotateOpen {
            from {
                transform: rotate(0deg);
                color: var(--caret-dim-color);
            }

            to {
                transform: rotate(90deg);
                color: inherit;
            }
        }

        @keyframes rotateClose {
            from {
                transform: rotate(90deg);
                color: inherit;
            }

            to {
                transform: rotate(0deg);
                color: var(--caret-dim-color);
            }
        }

        #theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--resizer-color);
            color: var(--text-color);
            border: 2px solid var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            line-height: 1;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        #theme-toggle:hover {
            transform: scale(1.1);
        }

        #toggle-icon {
            position: relative;
            top: 0;
            transition: top 0.3s ease;
        }

        #theme-toggle:active #toggle-icon {
            top: 25px;
        }

        #layout-toggle {
            position: fixed;
            top: 20px;
            right: 60px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--resizer-color);
            color: var(--text-color);
            border: 2px solid var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            line-height: 1;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            overflow: hidden;
        }

        #layout-toggle:hover {
            transform: scale(1.1);
        }

        #layout-icon {
            position: relative;
            top: 0;
        }

        /* vertical is default */
        [data-layout="horizontal"] #layout-icon {
            transform: rotate(90deg);
        }

        [data-transition="true"] #layout-icon {
            transition: transform 0.3s ease;
        }

        /* find panel controls */
        #find-pane .find-controls {
            display: flex;
            gap: 1rem;
            padding: 0.5rem;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        #find-pane .find-col {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            min-width: 160px;
        }

        #find-pane .find-col label {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
            font-size: 0.9rem;
        }

        /* Make the radio column visually grouped and slightly indented */
        #find-pane .find-col.radios label {
            padding-left: 0.1rem;
        }

        /* Compact inputs */
        #find-pane input[type="checkbox"],
        #find-pane input[type="radio"] {
            width: 16px;
            height: 16px;
            margin: 0;
        }
    </style>
</head>

<body>
    <!--
      * Layout *
      The main body is split in two (outline-find-container and body-pane) by by the main-resizer.
      The outline-find-container is split in two (outline-pane and find-pane) by the secondary-resizer.
      So in total, there are three panes and two resizers. The rest are just floating buttons which are not part of the layout.
    -->
    <div id="outline-find-container">
        <div id="outline-pane" tabindex="0"></div>
        <div id="secondary-resizer"></div>
        <div id="find-pane">
            <input id="find-input" type="text" placeholder="&lt;find pattern here&gt;" aria-label="Find pattern">

            <div class="find-controls" role="region" aria-label="Find options">
                <div class="find-col checkboxes" aria-hidden="false">
                    <label for="opt-whole">
                        <input id="opt-whole" type="checkbox" name="find-option" />
                        Whole Word
                    </label>
                    <label for="opt-ignorecase">
                        <input id="opt-ignorecase" type="checkbox" name="find-option" />
                        Ignore Case
                    </label>
                    <label for="opt-regexp">
                        <input id="opt-regexp" type="checkbox" name="find-option" />
                        Regexp
                    </label>
                    <label for="opt-mark">
                        <input id="opt-mark" type="checkbox" name="find-option" />
                        Mark Finds
                    </label>
                </div>

                <div class="find-col radios" role="radiogroup" aria-label="Search scope">
                    <label>
                        <input type="radio" name="find-scope" value="entire" checked />
                        Entire Outline
                    </label>
                    <label>
                        <input type="radio" name="find-scope" value="suboutline" />
                        Suboutline Only
                    </label>
                    <label>
                        <input type="radio" name="find-scope" value="node" />
                        Node Only
                    </label>
                </div>
            </div>
        </div>
    </div>
    <div id="main-resizer"></div>
    <div id="body-pane" tabindex="0" contenteditable="plaintext-only"></div>
    <button id="theme-toggle" aria-label="Toggle dark/light mode"><span id="toggle-icon">🌓</span></button>
    <button id="layout-toggle" aria-label="Toggle layout orientation"><span id="layout-icon">📐</span></button>
    <script>
        const tree = {
            "gnx": 0,
            "children": [
                {
                    "gnx": 1
                },
                {
                    "gnx": 2,
                    "children": [
                        {
                            "gnx": 3,
                            "children": [
                                {
                                    "gnx": 4,
                                    "children": [
                                        {
                                            "gnx": 5
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "gnx": 3
                        },
                        {
                            "gnx": 6
                        },
                        {
                            "gnx": 7
                        }
                    ]
                },
                {
                    "gnx": 8,
                    "children": [
                        {
                            "gnx": 9
                        },
                        {
                            "gnx": 10
                        },
                        {
                            "gnx": 11
                        }
                    ]
                }
            ]
        };
        const data = {
            "1": {
                "headString": "first node no body",
                "bodyString": ""
            },
            "2": {
                "headString": "second node",
                "bodyString": "Some body content\nmultiple lines\n\nend of first body"
            },
            "3": {
                "headString": "First child clone",
                "bodyString": "Some child content"
            },
            "4": {
                "headString": "Child of clone",
                "bodyString": "Body of the child of a clone!"
            },
            "5": {
                "headString": "Also has child!",
                "bodyString": "Yep, child of clone also has child!\n"
            },
            "6": {
                "headString": "trailing newlines",
                "bodyString": "inside other at same level\n\n"
            },
            "7": {
                "headString": "last same level",
                "bodyString": "Some body text"
            },
            "8": {
                "headString": "third top node no body",
                "bodyString": ""
            },
            "9": {
                "headString": "third top node child 1",
                "bodyString": "Some text in child 1\nblabla\n"
            },
            "10": {
                "headString": "third top node child 2",
                "bodyString": "Bla blabla bla,\nbla blablabla bla."
            },
            "11": {
                "headString": "third top node child 3",
                "bodyString": "Last node of the tree's natural tree order.\n"
            }
        };

        // Note: Also use buildClones and buildParentRefs
        // to add icon member to data entries as needed:
        // hasBody: 1, isMarked: 2, isClone: 4, isDirty: 8

        let visitedNodes = {}; // Keys are gnx, values are node references
        // Build clones when repeated in the tree
        function buildClones(node) {
            const gnx = node && node.gnx;
            // Initialize data entry safely if it exists
            if (gnx != null && data[gnx]) {
                if (!('icon' in data[gnx])) data[gnx].icon = 0;
            }

            if (gnx != null && Object.prototype.hasOwnProperty.call(visitedNodes, gnx)) {
                // If we've already seen this node, fill its children with JSON stringify/parse for deep copy.
                node.children = JSON.parse(JSON.stringify(visitedNodes[gnx].children || []));
                if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 4; // set clone bit
                // Do not recurse into children, they are already built
            } else {
                if (gnx != null && data[gnx] && data[gnx].bodyString) {
                    data[gnx].icon = (data[gnx].icon || 0) | 1; // set hasBody bit
                }
                visitedNodes[gnx] = node;
                if (node.children) {
                    for (const child of node.children) {
                        buildClones(child);
                    }
                }
            }
        };

        // Add parent references to all nodes recursively
        function buildParentRefs(node, parent = null) {
            node.parent = parent;
            if (node.children) {
                for (const child of node.children) {
                    buildParentRefs(child, node); // recurse with current node as parent
                }
            }
        }

        buildClones(tree);
        buildParentRefs(tree);

        const expanded = new Set(); // No need to add the root because 'isExpanded' will return true for it
        let selectedNode = null; // Track the currently selected node
        let currentTheme = 'light'; // Default theme
        let currentLayout = 'vertical'; // Default layout
        let isDragging = false;
        let mainRatio = 0.25; // Default proportion between outline-find-container and body-pane widths (defaults to 1/4)
        let secondaryIsDragging = false;
        let secondaryRatio = 0.75; // Default proportion between the outline-pane and the find-pane (defaults to 3/4)
        const minWidth = 0;
        const minHeight = 20;

        const ROW_HEIGHT = 26;
        const LEFT_OFFSET = 16; // Padding from left edge
        const OUTLINE_FIND_CONTAINER = document.getElementById("outline-find-container");
        const OUTLINE_PANE = document.getElementById("outline-pane");
        const BODY_PANE = document.getElementById("body-pane");
        const VERTICAL_RESIZER = document.getElementById('main-resizer');
        const FIND_PANE = document.getElementById("find-pane");
        const HORIZONTAL_RESIZER = document.getElementById('secondary-resizer');
        const THEME_TOGGLE = document.getElementById('theme-toggle');
        const THEME_ICON = document.getElementById('toggle-icon');
        const LAYOUT_TOGGLE = document.getElementById('layout-toggle');
        const LAYOUT_ICON = document.getElementById('layout-icon');
        const HTML_ELEMENT = document.documentElement;

        // Select first node in the hidden root initially
        if (tree.children && tree.children.length > 0) {
            selectedNode = tree.children[0];
        }
        let flatRows = flattenTree(tree); // Start up, so not hoisted. Safe to start with 'tree'.

        // -------------------------------------- Navigation helpers
        function children(node) {
            // Given a node, return a shallow copy of its children array or an empty array.
            return node && node.children ? node.children.slice() : [];
        }

        function childIndex(node) {
            // Given a node, return its index among its siblings (0 for first, 1 for second, etc).
            const parent = node.parent;
            if (parent) {
                const siblings = children(parent);
                return siblings.indexOf(node);
            }
            return 0; // Should not happen for valid nodes because the top nodes are in the #outline-pane div
        };

        function parents(node) {
            // Given a node, return an array of its ancestor nodes, closest first.
            const ancestors = [];
            let current = node;
            while (current) {
                const parent = current.parent;
                if (parent) {
                    ancestors.push(parent);
                }
                current = parent;
            }
            return ancestors;
        };

        function isAncestorOf(possibleAncestor, descendant) {
            // Return true if possibleAncestor is an ancestor of descendant.
            let current = descendant.parent;
            while (current) {
                if (current === possibleAncestor) {
                    return true;
                }
                current = current.parent;
            }
            return false;
        }

        function hasChildren(node) {
            // Given a node, return true if it has children.
            return node.children && node.children.length > 0;
        }

        function isExpanded(node) {
            // Given a node, return true if it is expanded.
            if (!node.parent) return true; // The root node is always considered expanded
            return expanded.has(node);
        }

        function isVisible(node) {
            // Return True if node is visible in the outline.
            if (!node.parent) return false; // Should not happen for valid nodes because the top nodes are in the #outline-pane div
            const ancestors = parents(node);
            for (const ancestor of ancestors) {
                if (!isExpanded(ancestor)) {
                    return false;
                }
            }
            return true;
        }

        function hasBack(node) {
            // Given a node, return true if it has a previous sibling.
            const parent = node.parent;
            if (parent) {
                const siblings = children(parent);
                const index = siblings.indexOf(node);
                return index > 0;
            }
            return false;
        }

        function hasNext(node) {
            // Given a node, return true if it has a next sibling.
            const parent = node.parent;
            if (parent) {
                const siblings = children(parent);
                const index = siblings.indexOf(node);
                return index < siblings.length - 1;
            }
            return false;
        }

        function hasParent(node) {
            // Given a node, return true if it has a parent. Except if that parent is the hidden root node.
            return !!node.parent && !!node.parent.parent;
        }

        function hasThreadBack(node) {
            // Much cheaper than computing the actual value.
            return hasBack(node) || hasParent(node);
        }

        function moveToBack(node) {
            // Given a node, return its previous sibling. If first, or no parent, return null.
            const parent = node.parent;
            if (parent) {
                const siblings = children(parent);
                const index = siblings.indexOf(node);
                return index > 0 ? siblings[index - 1] : null;
            }
            return null;
        }

        function moveToFirstChild(node) {
            // Given a node, return its first child if any. Else return null.
            return hasChildren(node) ? node.children[0] : null;
        }

        function moveToLastChild(node) {
            // Given a node, return its last child if any. Else return null.
            return hasChildren(node) ? node.children[node.children.length - 1] : null;
        }

        function moveToLastNode(node) {
            // Given a node, return the last node of its tree or itself if no children.
            while (hasChildren(node)) {
                node = moveToLastChild(node);
            }
            return node;
        }

        function moveToNext(node) {
            // Given a node, return its next sibling. If already last, return null.
            const parent = node.parent;
            if (parent) {
                const siblings = children(parent);
                const index = siblings.indexOf(node);
                return index < siblings.length - 1 ? siblings[index + 1] : null;
            }
            return null;
        }

        function moveToNodeAfterTree(node) {
            // Given a node, return the node after the position's tree.
            while (node) {
                if (hasNext(node)) {
                    node = moveToNext(node);
                    break;
                }
                node = moveToParent(node);
            }
            return node;
        }

        function moveToParent(node) {
            // Given a node, return its parent or null if no parent.
            const parent = node.parent;
            if (parent) {
                return parent;
            }
            return null;
        }

        function moveToThreadBack(node) {
            // Given a node, return the previous node in the outline.
            if (hasBack(node)) {
                node = moveToBack(node);
                node = moveToLastNode(node);
            } else {
                node = moveToParent(node);
            }
            return node;
        }

        function moveToThreadNext(node) {
            // Given a node, return the next node in the outline.
            if (hasChildren(node)) {
                node = moveToFirstChild(node);
            } else if (hasNext(node)) {
                node = moveToNext(node);
            } else {
                node = moveToParent(node);
                while (node) {
                    if (node && hasNext(node)) {
                        node = moveToNext(node);
                        break;
                    }
                    node = moveToParent(node);
                }
            }
            return node;
        };

        function moveToVisBack(node) {
            // Given a node, return the previous visible node in the outline.
            while (node) {
                // Short-circuit if possible.
                const back = moveToBack(node);
                if (back && hasChildren(back) && isExpanded(back))
                    node = moveToThreadBack(node);
                else if (back) {
                    node = moveToBack(node);
                } else {
                    node = moveToParent(node);  // Same as p.moveToThreadBack()
                }
                if (node && isVisible(node)) {
                    return node;
                }
            }
            return node;
        }

        function moveToVisNext(node) {
            // Given a node, return the next visible node in the outline.
            while (node) {
                if (hasChildren(node)) {
                    if (isExpanded(node)) {
                        node = moveToFirstChild(node);
                    } else {
                        node = moveToNodeAfterTree(node);
                    }
                } else if (hasNext(node)) {
                    node = moveToNext(node);
                } else {
                    node = moveToThreadNext(node);
                }
                if (node && isVisible(node)) {
                    return node;
                }
            }
        };

        // -------------------------------------- Navigation actions
        function expandNodeAndGoToFirstChild() {
            // If the presently selected node has children, expand it if needed and go to the first child.
            let node = selectedNode;
            if (hasChildren(node)) {
                if (!isExpanded(node)) {
                    expanded.add(node);
                    node.toggled = true; // Mark as toggled
                }
                node = moveToFirstChild(node);
                selectAndOrToggleAndRedraw(node);
            }
        }

        function contractNodeOrGoToParent() {
            // If the presently selected node is expanded, collapse it. Otherwise go to the parent.
            let node = selectedNode;
            if (hasChildren(node) && isExpanded(node)) {
                selectAndOrToggleAndRedraw(null, node);
            } else if (hasParent(node)) {
                const parent = moveToParent(node);
                if (isVisible(parent)) {
                    // Contract all children first
                    for (const child of children(parent)) {
                        if (isExpanded(child)) {
                            expanded.delete(child);
                            child.toggled = true; // Mark as toggled
                        }
                    }
                    selectAndOrToggleAndRedraw(parent);
                }
            }
        }

        function selectVisBack() {
            // Select the visible node preceding the presently selected node.
            let node = selectedNode;
            if (moveToVisBack(node)) {
                node = moveToVisBack(node);
                selectAndOrToggleAndRedraw(node);
            }
        }

        function selectVisNext() {
            // Select the visible node following the presently selected node.
            let node = selectedNode;
            if (moveToVisNext(node)) {
                node = moveToVisNext(node);
                selectAndOrToggleAndRedraw(node);
            }
        }

        function gotoFirstSiblingOrParent() {
            // Select the first sibling of the presently selected node, or its parent if already first.
            let node = selectedNode;
            if (hasBack(node)) {
                while (hasBack(node)) {
                    node = moveToBack(node);
                }
            } else if (hasParent(node)) {
                // No need to check visibility, parent always is.
                node = moveToParent(node);
            }
            selectAndOrToggleAndRedraw(node);
        };

        function gotoLastSiblingOrVisNext() {
            // Select the last sibling of the presently selected node, or the next visible node if already last.
            let node = selectedNode;
            if (hasNext(node)) {
                while (hasNext(node)) {
                    node = moveToNext(node);
                }
            } else if (moveToVisNext(node)) {
                node = moveToVisNext(node);
            }
            if (node) selectAndOrToggleAndRedraw(node);
        };


        function gotoFirstVisibleNode() {
            // Select the first visible node in the outline. (first child of hidden root node)
            const firstNode = moveToFirstChild(tree);
            if (firstNode) {
                // No need to check visibility, first node always is.
                selectAndOrToggleAndRedraw(firstNode);
            }
        };

        function gotoLastVisibleNode() {
            // Select the last visible node in the outline.
            let node = selectedNode;
            while (node) {
                const next = moveToVisNext(node);
                if (next && isVisible(next)) {
                    node = next;
                } else {
                    break;
                }
            }
            if (node) selectAndOrToggleAndRedraw(node);
        };

        function collapseAll() {
            // Collapse all nodes in outline and select the proper top-level node
            expanded.clear();

            let node = selectedNode;
            // hasParent already excludes the hidden root node
            while (node && hasParent(node)) {
                node = moveToParent(node);
            }
            if (node) selectAndOrToggleAndRedraw(node);
        };

        function toggleSelected() {
            if (selectedNode && selectedNode.children && selectedNode.children.length > 0) {
                selectAndOrToggleAndRedraw(null, selectedNode);
            }
        }

        // -------------------------------------- Rendering helpers
        function flattenTree(node, depth = 0, isRoot = true) {
            let rows = [];

            // Only add non-root nodes to the rows
            if (!isRoot) {
                rows.push({
                    label: data[node.gnx].headString,
                    depth,
                    toggled: node.toggled || false, // Will make it render with toggled class
                    hasChildren: !!node.children && node.children.length > 0,
                    isExpanded: isExpanded(node),
                    node
                });
            }
            if (node.toggled) {
                node.toggled = false; // Reset because it should not persist
            }

            if (isExpanded(node) && node.children) {
                for (const child of node.children) {
                    // Root node's children appear at depth 0
                    const childDepth = isRoot ? 0 : depth + 1;
                    rows.push(...flattenTree(child, childDepth, false));
                }
            }

            return rows;
        }

        function selectAndOrToggleAndRedraw(newSelectedNode = null, nodeToToggle = null) {
            // Handle toggling if requested
            if (nodeToToggle) {
                if (isExpanded(nodeToToggle)) {
                    expanded.delete(nodeToToggle);
                } else {
                    expanded.add(nodeToToggle);
                }
                nodeToToggle.toggled = true; // Mark as toggled
            }

            const isNew = newSelectedNode && newSelectedNode !== selectedNode;

            // Handle selection if requested
            if (isNew) {
                selectedNode = newSelectedNode;
            }

            // Only rebuild and redraw once
            flatRows = flattenTree(tree); // Todo: When hoist is implemented, if hoisted, dont start with 'tree'. // Start up, so not hoisted. Safe to start with 'tree'.
            renderTree();

            // Update body pane if selection changed (selectedNode cannot be null here because of isNew check)
            if (isNew) {
                if (newSelectedNode && data[newSelectedNode.gnx]) {
                    BODY_PANE.textContent = data[newSelectedNode.gnx].bodyString || "";
                } else {
                    BODY_PANE.textContent = "";
                }
                scrollSelectedNodeIntoView();
            }
        }

        function scrollSelectedNodeIntoView() {
            if (!selectedNode) return;

            const selectedIndex = flatRows.findIndex(row => row.node === selectedNode);
            if (selectedIndex === -1) return; // Not found (shouldn't happen)
            const nodePosition = selectedIndex * ROW_HEIGHT;

            const scrollTop = OUTLINE_PANE.scrollTop;
            const viewportHeight = OUTLINE_PANE.clientHeight;

            if (nodePosition < scrollTop) {
                OUTLINE_PANE.scrollTop = nodePosition;
            } else if (nodePosition + ROW_HEIGHT > scrollTop + viewportHeight) {
                OUTLINE_PANE.scrollTop = nodePosition - viewportHeight + ROW_HEIGHT;
            }
        }

        function throttle(func, limit) {
            let lastCall = 0;
            let timeout;

            return function (...args) {
                const now = Date.now();
                if (timeout) {
                    clearTimeout(timeout);
                }
                if (now - lastCall >= limit) {
                    lastCall = now;
                    func.apply(this, args);
                } else {
                    timeout = setTimeout(() => {
                        lastCall = Date.now();
                        func.apply(this, args);
                    }, limit - (now - lastCall));
                }
            };
        }

        function renderTree() {
            // Render visible rows only
            const scrollTop = OUTLINE_PANE.scrollTop;
            const viewportHeight = OUTLINE_PANE.clientHeight;
            const viewportWidth = OUTLINE_PANE.clientWidth;

            const startIndex = Math.floor(scrollTop / ROW_HEIGHT);
            const visibleCount = Math.ceil(viewportHeight / ROW_HEIGHT) + 1;
            const endIndex = Math.min(flatRows.length, startIndex + visibleCount);

            OUTLINE_PANE.innerHTML = "";
            const spacer = document.createElement("div"); // Spacer simulates full height
            spacer.style.height = flatRows.length * ROW_HEIGHT + "px";
            spacer.style.position = "relative";
            OUTLINE_PANE.appendChild(spacer);

            for (let i = startIndex; i < endIndex; i++) {
                const row = flatRows[i];
                const div = document.createElement("div");
                div.className = "node";
                if (row.label) {
                    div.title = row.label;
                }

                if (row.node === selectedNode) {
                    div.classList.add("selected");
                } else if (selectedNode && isAncestorOf(row.node, selectedNode)) {
                    div.classList.add("ancestor");
                }

                div.style.top = (i * ROW_HEIGHT) + "px";
                div.style.height = ROW_HEIGHT + "px";

                const leftPosition = (row.depth * 20) + LEFT_OFFSET;
                div.style.left = leftPosition + "px";
                div.style.width = (viewportWidth - leftPosition) + "px";

                const caret = document.createElement("span");
                caret.className = row.toggled ? "caret toggled" : "caret";

                row.toggled = false; // Reset toggled state after rendering

                if (row.hasChildren) {
                    caret.setAttribute("data-expanded", row.isExpanded ? "true" : "false");
                }
                div.appendChild(caret);

                const labelSpan = document.createElement("span");
                labelSpan.className = "node-text";

                // If dark mode, invert the icons' 4 bit to swap dirty borders inverted
                if (currentTheme === 'dark') {
                    let invertedIcon = data[row.node.gnx].icon ^ 8; // Toggle the 4 bit
                    labelSpan.classList.add("icon" + invertedIcon);
                } else {
                    labelSpan.classList.add("icon" + (data[row.node.gnx].icon || 0));
                }

                labelSpan.textContent = row.label;

                div.appendChild(labelSpan);
                spacer.appendChild(div);
            }
        }

        function safeLocalStorageGet(key) {
            try {
                return localStorage.getItem(key);
            } catch (e) {
                return null;
            }
        }

        function safeLocalStorageSet(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                // ignore
            }
        }

        function saveMainRatio(proportion) {
            safeLocalStorageSet('mainRatio', proportion);
        }

        const throttledSaveMainRatio = throttle(saveMainRatio, 500);

        function getSavedMainRatio() {
            const saved = safeLocalStorageGet('mainRatio');
            return saved != null ? parseFloat(saved) : null;
        }

        function updateProportion() {
            if (currentLayout === 'vertical') {
                mainRatio = OUTLINE_FIND_CONTAINER.offsetWidth / window.innerWidth;
            } else {
                mainRatio = OUTLINE_FIND_CONTAINER.offsetHeight / window.innerHeight;
            }
            throttledSaveMainRatio(mainRatio);
        }

        function updateOutlineContainerSize() {
            if (currentLayout === 'vertical') {
                let newWidth = window.innerWidth * mainRatio;
                // Respect minimum width
                if (newWidth < minWidth) {
                    newWidth = minWidth;
                }
                OUTLINE_FIND_CONTAINER.style.width = `${newWidth}px`;
                OUTLINE_FIND_CONTAINER.style.height = `100%`;
            } else {
                let newHeight = window.innerHeight * mainRatio;
                // Respect minimum height
                if (newHeight < minWidth) {
                    newHeight = minWidth;
                }
                OUTLINE_FIND_CONTAINER.style.height = `${newHeight}px`;
                OUTLINE_FIND_CONTAINER.style.width = `100%`;
            }
            renderTree();
        }

        const handleDrag = throttle(function (e) {
            if (currentLayout === 'vertical') {
                let clientX = e.clientX;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                }
                const newWidth = clientX;
                if (newWidth >= minWidth) {
                    OUTLINE_FIND_CONTAINER.style.width = newWidth + 'px';
                } else {
                    OUTLINE_FIND_CONTAINER.style.width = minWidth + 'px';
                }
            } else {
                let clientY = e.clientY;
                if (e.touches) {
                    clientY = e.touches[0].clientY;
                }
                const newHeight = clientY;
                if (newHeight >= minWidth) {
                    OUTLINE_FIND_CONTAINER.style.height = newHeight + 'px';
                } else {
                    OUTLINE_FIND_CONTAINER.style.height = minWidth + 'px';
                }
            }
            renderTree();
        }, 33);

        function startDrag(e) {
            isDragging = true;
            document.body.classList.add('dragging-main');
            e.preventDefault();
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', handleDrag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                document.body.classList.remove('dragging-main');
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', handleDrag);
                document.removeEventListener('touchend', stopDrag);
                updateProportion();
                renderTree();
            }
        }

        function saveSecondaryRatio(proportion) {
            safeLocalStorageSet('secondaryRatio', proportion);
        }

        const throttledSaveSecondaryRatio = throttle(saveSecondaryRatio, 500);

        function getSavedSecondaryRatio() {
            const saved = safeLocalStorageGet('secondaryRatio');
            return saved != null ? parseFloat(saved) : null;
        }

        function updateSecondaryProportion() {
            if (currentLayout === 'vertical') {
                secondaryRatio = OUTLINE_PANE.offsetHeight / OUTLINE_FIND_CONTAINER.offsetHeight;
            } else {
                secondaryRatio = OUTLINE_PANE.offsetWidth / OUTLINE_FIND_CONTAINER.offsetWidth;
            }
            throttledSaveSecondaryRatio(secondaryRatio);
        }

        function updateOutlinePaneSize() {
            if (currentLayout === 'vertical') {
                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;
                let newHeight = containerHeight * secondaryRatio;

                // Respect minimum heights
                if (newHeight < minHeight) {
                    newHeight = minHeight;
                } else if (newHeight > containerHeight - minHeight) {
                    newHeight = containerHeight - minHeight;
                }

                // Set flex properties to control the distribution
                OUTLINE_PANE.style.flex = `0 0 ${newHeight}px`;
                FIND_PANE.style.flex = `1 1 auto`; // Let it take the remaining space
            } else {
                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;
                let newWidth = containerWidth * secondaryRatio;

                // Respect minimum widths
                if (newWidth < minHeight) {
                    newWidth = minHeight;
                } else if (newWidth > containerWidth - minHeight) {
                    newWidth = containerWidth - minHeight;
                }

                // Set flex properties to control the distribution
                OUTLINE_PANE.style.flex = `0 0 ${newWidth}px`;
                FIND_PANE.style.flex = `1 1 auto`; // Let it take the remaining space
            }
        }

        const handleSecondaryDrag = throttle(function (e) {
            if (currentLayout === 'vertical') {

                let clientY = e.clientY;
                if (e.touches) {
                    clientY = e.touches[0].clientY;
                }

                // Get the top position of the outline-find-container
                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();
                const relativeY = clientY - containerRect.top;
                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;

                // Ensure we respect minimum heights
                if (relativeY >= minHeight && relativeY <= containerHeight - minHeight) {
                    // Set flex properties to control the distribution
                    OUTLINE_PANE.style.flex = `0 0 ${relativeY}px`;
                    FIND_PANE.style.flex = `1 1 auto`; // Let it take the remaining space
                }
            } else {
                let clientX = e.clientX;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                }

                // Get the left position of the outline-find-container
                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();
                const relativeX = clientX - containerRect.left;
                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;

                // Ensure we respect minimum widths
                if (relativeX >= minHeight && relativeX <= containerWidth - minHeight) {
                    // Set flex properties to control the distribution
                    OUTLINE_PANE.style.flex = `0 0 ${relativeX}px`;
                    FIND_PANE.style.flex = `1 1 auto`; // Let it take the remaining space
                }
            }
            renderTree();
        }, 33);

        function startSecondaryDrag(e) {
            secondaryIsDragging = true;
            document.body.classList.add('dragging-secondary');
            e.preventDefault();
            document.addEventListener('mousemove', handleSecondaryDrag);
            document.addEventListener('mouseup', stopSecondaryDrag);
            document.addEventListener('touchmove', handleSecondaryDrag, { passive: false });
            document.addEventListener('touchend', stopSecondaryDrag);
        }

        function stopSecondaryDrag() {
            if (secondaryIsDragging) {
                secondaryIsDragging = false;
                document.body.classList.remove('dragging-secondary');
                document.removeEventListener('mousemove', handleSecondaryDrag);
                document.removeEventListener('mouseup', stopSecondaryDrag);
                document.removeEventListener('touchmove', handleSecondaryDrag);
                document.removeEventListener('touchend', stopSecondaryDrag);
                updateSecondaryProportion();
                renderTree();
            }
        }

        function updatePanelSizes() {
            updateOutlineContainerSize();
            updateOutlinePaneSize();
        }

        const getCurrentTheme = () => {
            const savedTheme = safeLocalStorageGet('theme');
            if (savedTheme) {
                return savedTheme;
            }
            // Use OS preference as fallback
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        };

        const getCurrentLayout = () => {
            return localStorage.getItem('layout') || 'vertical';
        };

        const applyTheme = (theme) => {
            currentTheme = theme;
            HTML_ELEMENT.setAttribute('data-theme', theme);
            safeLocalStorageSet('theme', theme);
            THEME_TOGGLE.title = theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme';
            THEME_ICON.innerHTML = theme === 'dark' ? '🌙' : '☀️';
        };

        const applyLayout = (layout) => {
            currentLayout = layout;
            localStorage.setItem('layout', layout);
            LAYOUT_TOGGLE.title = layout === 'vertical' ? 'Switch to horizontal layout' : 'Switch to vertical layout';
            if (layout === 'horizontal') {
                HTML_ELEMENT.setAttribute('data-layout', 'horizontal');
            } else {
                HTML_ELEMENT.setAttribute('data-layout', 'vertical');
            }
            // Proportions will have changed so we must update sizes
            updatePanelSizes();
            renderTree();
        };

        // Setup and organize all event handlers
        function setupEventHandlers() {
            setupOutlinePaneHandlers();
            setupBodyPaneHandlers();
            setupResizerHandlers();
            setupWindowHandlers();
            setupToggleHandlers();
        }

        function setupOutlinePaneHandlers() {
            // Prevent text selection on double-click
            OUTLINE_PANE.addEventListener("mousedown", handleOutlinePaneMouseDown);
            OUTLINE_PANE.addEventListener('click', handleOutlinePaneClick);
            OUTLINE_PANE.addEventListener('dblclick', handleOutlinePaneDblClick);
            OUTLINE_PANE.addEventListener('keydown', handleOutlinePaneKeyDown);
            OUTLINE_PANE.addEventListener("scroll", throttle(renderTree, 33));
        }

        function setupBodyPaneHandlers() {
            BODY_PANE.addEventListener('keydown', handleBodyPaneKeyDown);

            // Block all text changes
            BODY_PANE.addEventListener("beforeinput", preventDefault);
            BODY_PANE.addEventListener("paste", preventDefault);
        }

        function setupResizerHandlers() {
            VERTICAL_RESIZER.addEventListener('mousedown', startDrag);
            VERTICAL_RESIZER.addEventListener('touchstart', startDrag);
            HORIZONTAL_RESIZER.addEventListener('mousedown', startSecondaryDrag);
            HORIZONTAL_RESIZER.addEventListener('touchstart', startSecondaryDrag);
        }

        function setupWindowHandlers() {
            window.addEventListener('resize', throttle(handleWindowResize, 67));
            window.addEventListener('keydown', handleGlobalKeyDown);
        }

        function setupToggleHandlers() {
            THEME_TOGGLE.addEventListener('click', handleThemeToggleClick);
            LAYOUT_TOGGLE.addEventListener('click', handleLayoutToggleClick);
        }

        // Event handler implementations
        function handleOutlinePaneMouseDown(e) {
            if (e.detail === 2) e.preventDefault();
        }

        function handleOutlinePaneClick(event) {
            const nodeEl = event.target.closest('.node');
            if (!nodeEl) return;

            const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);
            if (rowIndex < 0 || rowIndex >= flatRows.length) return;

            const row = flatRows[rowIndex];

            // Handle different click targets
            if (event.target.classList.contains('caret') && row.hasChildren) {
                event.stopPropagation();
                // Both toggle and select in one operation
                selectAndOrToggleAndRedraw(
                    row.node !== selectedNode ? row.node : null,
                    row.node
                );
            } else {
                // Rest of the node (including icon and text)
                event.stopPropagation();
                if (row.node !== selectedNode) {
                    selectAndOrToggleAndRedraw(row.node); // Just selection
                }
            }
        }

        function handleOutlinePaneDblClick(event) {
            if (event.target.classList.contains('node-text')) {
                event.preventDefault();
                event.stopPropagation();

                const nodeEl = event.target.closest('.node');
                if (!nodeEl) return;

                const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);
                if (rowIndex >= 0 && rowIndex < flatRows.length) {
                    const row = flatRows[rowIndex];
                    if (row.hasChildren) {
                        // Handle both selection and toggle in one update
                        selectAndOrToggleAndRedraw(
                            row.node !== selectedNode ? row.node : null,
                            row.node
                        );
                    }
                }
            }
        }

        // Outline pane key mapping for better organization
        const outlinePaneKeyMap = {
            'Enter': () => BODY_PANE.focus(),
            'Tab': () => BODY_PANE.focus(),
            ' ': () => toggleSelected(),
            'ArrowUp': () => selectVisBack(),
            'ArrowDown': () => selectVisNext(),
            'ArrowLeft': () => contractNodeOrGoToParent(),
            'ArrowRight': () => expandNodeAndGoToFirstChild(),
            'PageUp': () => gotoFirstSiblingOrParent(),
            'PageDown': () => gotoLastSiblingOrVisNext(),
            'Home': () => gotoFirstVisibleNode(),
            'End': () => gotoLastVisibleNode()
        };

        function handleOutlinePaneKeyDown(e) {
            // Special case for Alt key combinations
            if (e.key === '-' && e.altKey && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                collapseAll();
                return;
            }

            const handler = outlinePaneKeyMap[e.key];
            if (handler && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault();
                handler();
            }
        }

        // Body pane key mapping
        const bodyPaneKeyMap = {
            'Tab': (e) => { e.preventDefault(); OUTLINE_PANE.focus(); },
            'ArrowUp': (e) => { if (e.altKey) { e.preventDefault(); OUTLINE_PANE.focus(); selectVisBack(); } },
            'ArrowDown': (e) => { if (e.altKey) { e.preventDefault(); OUTLINE_PANE.focus(); selectVisNext(); } },
            'ArrowLeft': (e) => { if (e.altKey) { e.preventDefault(); OUTLINE_PANE.focus(); contractNodeOrGoToParent(); } },
            'ArrowRight': (e) => { if (e.altKey) { e.preventDefault(); OUTLINE_PANE.focus(); expandNodeAndGoToFirstChild(); } }
        };

        function handleBodyPaneKeyDown(e) {
            const handler = bodyPaneKeyMap[e.key];
            if (handler) {
                // arrows are allowed to move cursor in body pane if no alt key:
                // so do not preventDefault in that case. Only do so if alt key is pressed.
                handler(e);
            }
        }

        // Global key handlers (work anywhere)
        function handleGlobalKeyDown(e) {
            if (e.key.toLowerCase() === 'f' && e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault();
                FIND_PANE.focus();
            } else if (e.key.toLowerCase() === 'm' && e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault();
                if (selectedNode && selectedNode.gnx) {
                    data[selectedNode.gnx].icon ^= 2; // Toggle mark bit (selectedNode will never be the hidden root node)
                    renderTree(); // Re-render to update icons
                }
            }
        }

        function handleWindowResize() {
            updatePanelSizes();
            renderTree();
        }

        function handleDOMContentLoaded() {
            applyLayout(getCurrentLayout());
            applyTheme(getCurrentTheme());
            initializeLayout();
        }

        function handleThemeToggleClick() {
            // Only animate once button pressed, so page-load wont animate color changes.
            HTML_ELEMENT.setAttribute('data-transition', 'true');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
            renderTree(); // Re-render to update icon colors
        }

        function handleLayoutToggleClick() {
            HTML_ELEMENT.setAttribute('data-transition', 'true');
            const newLayout = currentLayout === 'vertical' ? 'horizontal' : 'vertical';
            applyLayout(newLayout);
        }

        // Utility functions
        function preventDefault(e) {
            e.preventDefault();
        }

        // Modified initialization function to call the setup
        function initializeLayout() {
            const savedOutlineBodyRatio = getSavedMainRatio();
            const savedOutlineFindRatio = getSavedSecondaryRatio();

            if (savedOutlineBodyRatio != null) {
                mainRatio = savedOutlineBodyRatio;
            }
            if (savedOutlineFindRatio != null) {
                secondaryRatio = savedOutlineFindRatio;
            }

            updatePanelSizes();
            setupEventHandlers();
            renderTree();
        }

        window.addEventListener('DOMContentLoaded', handleDOMContentLoaded);

    </script>
</body>

</html>