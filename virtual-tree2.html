<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Virtualised Tree (Vanilla JS)</title>
    <style>
        body {
            margin: 0;
            display: flex;
            height: 100vh;
        }

        body.dragging {
            cursor: ew-resize !important;
        }

        #outline-pane {
            width: 250px;
            white-space: nowrap;
            background: #ffffec;
            padding: 1rem 0 0 0;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: sans-serif;
        }

        #resizer {
            width: 5px;
            cursor: ew-resize;
            background: #cae1ff;
        }

        #body-pane {
            flex: 1;
            padding: 1rem 0 0 1rem;
            background: #fff6f5;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
        }

        #outline-pane:focus,
        #body-pane:focus,
        #outline-pane:focus-visible,
        #body-pane:focus-visible {
            outline: 3px solid blue;
            outline-offset: -3px;
        }


        /* Selected + ancestor styles still just target the label */
        .selected>.node-text {
            background: #cae1ff;
        }


        /* .position {
            grid-column: 1 / -1;
            margin: 0;
            
        } */

        .position {
            position: absolute;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;

            display: grid;
            grid-template-columns: 1em 1fr;
            align-items: start;
            /* row-gap: 2px; */
            /* space between the row and its children */
            /* padding: 2px 0; */
        }



        /* Caret stays a small target in the first column */
        .caret {
            grid-column: 1;
            display: inline-block;
            width: 1em;
            cursor: pointer;
            user-select: none;
        }

        /* Caret glyphs */
        .caret::after {
            display: inline-block;
            transform-origin: 50% 50%;
            transform: rotate(0deg);
        }

        .caret[data-expanded="true"]::after {
            content: "❯";
            transform: rotate(90deg);
        }

        .caret[data-expanded="false"]::after {
            content: "❯";
            color: #888;
        }
    </style>
</head>

<body>
    <div id="outline-pane" tabindex="0"></div>
    <div id="resizer"></div>
    <div id="body-pane" tabindex="0"></div>
    <script>
        const tree = {
            "gnx": 0,
            "children": [
                {
                    "gnx": 1
                },
                {
                    "gnx": 2,
                    "children": [
                        {
                            "gnx": 3
                        },
                        {
                            "gnx": 3
                        },
                        {
                            "gnx": 4
                        },
                        {
                            "gnx": 5
                        }
                    ]
                }
            ]
        };
        const data = {
            "0": {
                "headString": "hiddenRootNode",
                "bodyString": "",
                "icon": 0
            },
            "1": {
                "headString": "first node",
                "bodyString": "",
                "icon": 0
            },
            "2": {
                "headString": "second node",
                "bodyString": "Some body content\nmultiple lines\n\nend of first body",
                "icon": 1
            },
            "3": {
                "headString": "First child clones",
                "bodyString": "Some child content",
                "icon": 5
            },
            "4": {
                "headString": "trailing newlines",
                "bodyString": "inside other at same level\n\n",
                "icon": 1
            },
            "5": {
                "headString": "last same level",
                "bodyString": "Some body text",
                "icon": 1
            }
        };
        // Add parent references to all nodes recursively
        function buildParentRefs(node, parent = null) {
            node.parent = parent;
            if (node.children) {
                for (const child of node.children) {
                    buildParentRefs(child, node); // recurse with current node as parent
                }
            }
        }

        // Call it on the root
        buildParentRefs(tree);

        // Track expanded nodes
        const expanded = new Set([tree]); // Root expanded initially

        // Flatten tree into visible rows
        function flattenTree(node, expandedSet, depth = 0, isRoot = true) {
            let rows = [];

            // Only add non-root nodes to the rows
            if (!isRoot) {
                rows.push({
                    label: data[node.gnx].headString,
                    depth,
                    hasChildren: !!node.children && node.children.length > 0,
                    isExpanded: expandedSet.has(node),
                    node
                });
            }

            // If expanded and has children, process them
            if (expandedSet.has(node) && node.children) {
                for (const child of node.children) {
                    // Root node's children appear at depth 0
                    const childDepth = isRoot ? 0 : depth + 1;
                    rows.push(...flattenTree(child, expandedSet, childDepth, false));
                }
            }

            return rows;
        }

        // Constants
        const ROW_HEIGHT = 24;
        const LEFT_OFFSET = 16; // Padding from left edge
        const VIEWPORT = document.getElementById("outline-pane");

        // State
        let flatRows = flattenTree(tree, expanded);

        // Render visible rows only
        function renderTree() {
            const scrollTop = VIEWPORT.scrollTop;
            const viewportHeight = VIEWPORT.clientHeight;

            const startIndex = Math.floor(scrollTop / ROW_HEIGHT);
            const visibleCount = Math.ceil(viewportHeight / ROW_HEIGHT) + 1;
            const endIndex = Math.min(flatRows.length, startIndex + visibleCount);

            // Spacer div to simulate full height
            VIEWPORT.innerHTML = "";
            const spacer = document.createElement("div");
            spacer.style.height = flatRows.length * ROW_HEIGHT + "px";
            spacer.style.position = "relative";
            VIEWPORT.appendChild(spacer);

            for (let i = startIndex; i < endIndex; i++) {
                const row = flatRows[i];
                const div = document.createElement("div");
                div.className = "position";
                div.style.top = (i * ROW_HEIGHT) + "px";
                div.style.left = (row.depth * 20) + LEFT_OFFSET + "px";
                div.style.height = ROW_HEIGHT + "px";

                // Create a caret span element
                const caret = document.createElement("span");
                caret.className = "caret";
                if (row.hasChildren) {
                    caret.setAttribute("data-expanded", row.isExpanded ? "true" : "false");
                    caret.onclick = (e) => {
                        e.stopPropagation();
                        if (expanded.has(row.node)) {
                            expanded.delete(row.node);
                        } else {
                            expanded.add(row.node);
                        }
                        flatRows = flattenTree(tree, expanded);
                        renderTree();
                    };
                }
                div.appendChild(caret);

                // Add the label text
                const labelSpan = document.createElement("span");
                labelSpan.className = "node-text";
                labelSpan.textContent = row.label;
                div.appendChild(labelSpan);

                spacer.appendChild(div);
            }
        }

        // Scroll handler
        VIEWPORT.addEventListener("scroll", renderTree);

        // Initial render
        renderTree();
    </script>
</body>

</html>