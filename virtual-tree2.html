<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Virtualised Tree</title>
    <style>
        :root {
            /* Light theme (default) */
            --background-color: #ffffec;
            --body-pane-color: #fff6f5;
            --resizer-color: #cae1ff;
            --selected-bg: #cae1ff;
            --ancestor-bg: #eef5ff;
            --focus-outline: #0000ff;
            --text-color: #000000;
            --caret-dim-color: #888;
        }

        [data-theme="dark"] {
            /* Dark theme */
            --background-color: #1e1e2e;
            --body-pane-color: #2a2536;
            --resizer-color: #454a6e;
            --selected-bg: #454a6e;
            --ancestor-bg: #2d3250;
            --focus-outline: #7aa2f7;
            --text-color: #cdd6f4;
            --caret-dim-color: #999;
        }

        body {
            margin: 0;
            display: flex;
            height: 100vh;
            background: var(--background-color);
            color: var(--text-color);
        }

        body.dragging {
            cursor: ew-resize !important;
        }

        #outline-pane {
            width: 250px;
            white-space: nowrap;
            padding: 1rem 0 0 0;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: sans-serif;
        }

        #vertical-resizer {
            position: relative;
            width: 5px;
            cursor: ew-resize;
            background: var(--resizer-color);
        }

        #vertical-resizer::before,
        #vertical-resizer::after {
            /* Invisible extension width extended with before/after below */
            content: "";
            position: absolute;
            top: 0;
            height: 100%;
            width: 5px;
            cursor: ew-resize;
        }

        #vertical-resizer::before {
            left: -5px;
        }

        #vertical-resizer::after {
            right: -5px;
        }

        #body-pane {
            flex: 1;
            padding: 1rem 0 0 1rem;
            background: var(--body-pane-color);
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
        }

        #outline-pane:focus,
        #body-pane:focus,
        #outline-pane:focus-visible,
        #body-pane:focus-visible {
            /* 
              Note: Outline will appear under the items positioned absolutely.
              see pseudo-elements with "z-index: -1" that appear below this outline.
             */
            outline: 3px solid var(--focus-outline);
            outline-offset: -3px;
        }

        .selected>.node-text {
            position: relative;
        }

        .selected>.node-text::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--selected-bg);
            z-index: -1;
            border-radius: 4px;
        }

        .ancestor>.node-text {
            position: relative;
        }

        .ancestor>.node-text::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--ancestor-bg);
            z-index: -1;
            border-radius: 4px;
        }

        .node {
            position: absolute;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            display: grid;
            grid-template-columns: 1em 1fr;
            align-items: start;
            /* row-gap: 2px; */
            /* padding: 2px 0; */
        }

        /* Caret stays a small target in the first column */
        .caret {
            grid-column: 1;
            display: inline-block;
            width: 1em;
            cursor: pointer;
            user-select: none;
        }

        .node-text {
            grid-column: 2;
            display: block;
            cursor: pointer;
            padding: 2px 4px;
            margin-right: 1rem;
            border-radius: 4px;
        }

        /* Caret glyphs */
        .caret::after {
            display: inline-block;
            transform-origin: 50% 50%;
            transition: transform 160ms cubic-bezier(.2, .9, .3, 1), color 120ms;
        }

        .caret[data-expanded="true"]::after {
            content: "‚ùØ";
            transform: rotate(90deg);
        }

        .caret[data-expanded="false"]::after {
            content: "‚ùØ";
            transform: rotate(0deg);
            color: var(--caret-dim-color);
        }

        .caret.toggled[data-expanded="true"]::after {
            content: "‚ùØ";
            transform: rotate(90deg);
            animation: rotateOpen 120ms ease-out;
        }

        .caret.toggled[data-expanded="false"]::after {
            content: "‚ùØ";
            transform: rotate(0deg);
            color: var(--caret-dim-color);
            animation: rotateClose 120ms ease-out;
        }

        @keyframes rotateOpen {
            from {
                transform: rotate(0deg);
                color: var(--caret-dim-color);
            }

            to {
                transform: rotate(90deg);
                color: inherit;
            }
        }

        @keyframes rotateClose {
            from {
                transform: rotate(90deg);
                color: inherit;
            }

            to {
                transform: rotate(0deg);
                color: var(--caret-dim-color);
            }
        }

        #theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--resizer-color);
            color: var(--text-color);
            border: 2px solid var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            line-height: 1;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: transform 0.2s ease;
        }

        #theme-toggle:hover {
            transform: scale(1.1);
        }
    </style>
</head>

<body>
    <div id="outline-pane" tabindex="0"></div>
    <div id="vertical-resizer"></div>
    <div id="body-pane" tabindex="0"></div>
    <button id="theme-toggle" aria-label="Toggle dark/light mode">üåì</button>
    <script>
        const tree = {
            "gnx": 0,
            "children": [
                {
                    "gnx": 1
                },
                {
                    "gnx": 2,
                    "children": [
                        {
                            "gnx": 3
                        },
                        {
                            "gnx": 3
                        },
                        {
                            "gnx": 4
                        },
                        {
                            "gnx": 5
                        }
                    ]
                }
            ]
        };
        const data = {
            "0": {
                "headString": "hiddenRootNode",
                "bodyString": "",
                "icon": 0
            },
            "1": {
                "headString": "first node",
                "bodyString": "",
                "icon": 0
            },
            "2": {
                "headString": "second node",
                "bodyString": "Some body content\nmultiple lines\n\nend of first body",
                "icon": 1
            },
            "3": {
                "headString": "First child clones",
                "bodyString": "Some child content",
                "icon": 5
            },
            "4": {
                "headString": "trailing newlines",
                "bodyString": "inside other at same level\n\n",
                "icon": 1
            },
            "5": {
                "headString": "last same level",
                "bodyString": "Some body text",
                "icon": 1
            }
        };
        // Add parent references to all nodes recursively
        function buildParentRefs(node, parent = null) {
            node.parent = parent;
            if (node.children) {
                for (const child of node.children) {
                    buildParentRefs(child, node); // recurse with current node as parent
                }
            }
        }

        // Call it on the root
        buildParentRefs(tree);

        const expanded = new Set([tree]); // Root expanded initially
        let selectedNode = null; // Track the currently selected node
        let isDragging = false;
        let outlineProportion;
        const minWidth = 0;

        // Constants
        const ROW_HEIGHT = 26;
        const LEFT_OFFSET = 16; // Padding from left edge
        const OUTLINE_PANE = document.getElementById("outline-pane");
        const BODY_PANE = document.getElementById("body-pane");
        const VERTICAL_RESIZER = document.getElementById('vertical-resizer');
        const THEME_TOGGLE = document.getElementById('theme-toggle');
        const HTML_ELEMENT = document.documentElement;

        // Select first node in the hidden root initially
        if (tree.children && tree.children.length > 0) {
            selectedNode = tree.children[0];
        }
        let flatRows = flattenTree(tree, expanded);

        // Flatten tree into visible rows
        function flattenTree(node, expandedSet, depth = 0, isRoot = true) {
            let rows = [];

            // Only add non-root nodes to the rows
            if (!isRoot) {
                rows.push({
                    label: data[node.gnx].headString,
                    depth,
                    toggled: node.toggled || false, // Will make it render with toggled class
                    hasChildren: !!node.children && node.children.length > 0,
                    isExpanded: expandedSet.has(node),
                    node
                });
            }
            if (node.toggled) {
                node.toggled = false; // Reset because it should not persist
            }

            // If expanded and has children, process them
            if (expandedSet.has(node) && node.children) {
                for (const child of node.children) {
                    // Root node's children appear at depth 0
                    const childDepth = isRoot ? 0 : depth + 1;
                    rows.push(...flattenTree(child, expandedSet, childDepth, false));
                }
            }

            return rows;
        }

        // Selects and/or toggles a node
        function updateTree(newSelectedNode = null, nodeToToggle = null) {
            // Handle toggling if requested
            if (nodeToToggle) {
                if (expanded.has(nodeToToggle)) {
                    expanded.delete(nodeToToggle);
                } else {
                    expanded.add(nodeToToggle);
                }
                nodeToToggle.toggled = true; // Mark as toggled
            }

            // Handle selection if requested
            if (newSelectedNode) {
                selectedNode = newSelectedNode;
            }

            // Only rebuild and redraw once
            flatRows = flattenTree(tree, expanded);
            renderTree();

            // Update body pane if selection changed
            if (newSelectedNode) {
                if (newSelectedNode && data[newSelectedNode.gnx]) {
                    BODY_PANE.textContent = data[newSelectedNode.gnx].bodyString || "";
                } else {
                    BODY_PANE.textContent = "";
                }
            }
        }

        function isAncestor(possibleAncestor, descendant) {
            // Check if possibleAncestor is actually an ancestor of descendant
            // by walking up the parent chain
            let current = descendant.parent;
            while (current) {
                if (current === possibleAncestor) {
                    return true;
                }
                current = current.parent;
            }
            return false;
        }

        // Render visible rows only
        function renderTree() {
            const scrollTop = OUTLINE_PANE.scrollTop;
            const viewportHeight = OUTLINE_PANE.clientHeight;
            const viewportWidth = OUTLINE_PANE.clientWidth;

            const startIndex = Math.floor(scrollTop / ROW_HEIGHT);
            const visibleCount = Math.ceil(viewportHeight / ROW_HEIGHT) + 1;
            const endIndex = Math.min(flatRows.length, startIndex + visibleCount);

            OUTLINE_PANE.innerHTML = "";
            const spacer = document.createElement("div"); // Spacer simulates full height
            spacer.style.height = flatRows.length * ROW_HEIGHT + "px";
            spacer.style.position = "relative";
            OUTLINE_PANE.appendChild(spacer);

            for (let i = startIndex; i < endIndex; i++) {
                const row = flatRows[i];
                const div = document.createElement("div");
                div.className = "node";
                if (row.node === selectedNode) {
                    div.classList.add("selected");
                } else if (selectedNode && isAncestor(row.node, selectedNode)) {
                    div.classList.add("ancestor");
                }

                div.style.top = (i * ROW_HEIGHT) + "px";
                div.style.height = ROW_HEIGHT + "px";

                const leftPosition = (row.depth * 20) + LEFT_OFFSET;
                div.style.left = leftPosition + "px";
                div.style.width = (viewportWidth - leftPosition) + "px";

                const caret = document.createElement("span");
                caret.className = row.toggled ? "caret toggled" : "caret";

                row.toggled = false; // Reset toggled state after rendering

                if (row.hasChildren) {
                    caret.setAttribute("data-expanded", row.isExpanded ? "true" : "false");
                }
                div.appendChild(caret);

                const labelSpan = document.createElement("span");
                labelSpan.className = "node-text";
                labelSpan.textContent = row.label;

                div.appendChild(labelSpan);
                spacer.appendChild(div);
            }
        }

        // Save outline proportion to localStorage
        function saveOutlineProportion(proportion) {
            localStorage.setItem('outlineProportion', proportion);
        }

        const throttledSaveOutlineProportion = throttle(saveOutlineProportion, 500);

        function getSavedOutlineProportion() {
            const saved = localStorage.getItem('outlineProportion');
            return saved ? parseFloat(saved) : 0.25; // Default to 25% if not saved
        }

        function updateProportion() {
            outlineProportion = OUTLINE_PANE.offsetWidth / window.innerWidth;
            throttledSaveOutlineProportion(outlineProportion);
        }

        function throttle(func, limit) {
            let lastCall = 0;
            let timeout;

            return function (...args) {
                const now = Date.now();
                if (timeout) {
                    clearTimeout(timeout);
                }
                if (now - lastCall >= limit) {
                    lastCall = now;
                    func.apply(this, args);
                } else {
                    timeout = setTimeout(() => {
                        lastCall = Date.now();
                        func.apply(this, args);
                    }, limit - (now - lastCall));
                }
            };
        }

        function updateOutlineWidth() {
            let newWidth = window.innerWidth * outlineProportion;
            // Respect minimum width
            if (newWidth < minWidth) {
                newWidth = minWidth;
            }
            OUTLINE_PANE.style.width = `${newWidth}px`;
            renderTree();
        }

        const handleDrag = throttle(function (e) {
            let clientX = e.clientX;
            if (e.touches) {
                clientX = e.touches[0].clientX;
            }

            const newWidth = clientX;
            if (newWidth >= minWidth) {
                OUTLINE_PANE.style.width = newWidth + 'px';
            } else {
                OUTLINE_PANE.style.width = minWidth + 'px';
            }
            renderTree();
        }, 67);

        function startDrag(e) {
            isDragging = true;
            document.body.classList.add('dragging');
            e.preventDefault();
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', handleDrag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                document.body.classList.remove('dragging');
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', handleDrag);
                document.removeEventListener('touchend', stopDrag);
                updateProportion();
                // renderTree();
            }
        }

        // Initialize resizer
        VERTICAL_RESIZER.addEventListener('mousedown', startDrag);
        VERTICAL_RESIZER.addEventListener('touchstart', startDrag);
        window.addEventListener('resize', throttle(updateOutlineWidth, 67));

        // Prevent text selection on double-click
        OUTLINE_PANE.addEventListener("mousedown", e => {
            if (e.detail === 2) e.preventDefault();
        });

        OUTLINE_PANE.addEventListener('click', (event) => {
            const nodeEl = event.target.closest('.node');
            if (!nodeEl) return;

            const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);
            if (rowIndex < 0 || rowIndex >= flatRows.length) return;

            const row = flatRows[rowIndex];

            // Handle different click targets
            if (event.target.classList.contains('node-text')) {
                event.stopPropagation();
                if (row.node !== selectedNode) {
                    updateTree(row.node); // Just selection
                }
            } else if (event.target.classList.contains('caret') && row.hasChildren) {
                event.stopPropagation();
                // Both toggle and select in one operation
                updateTree(
                    row.node !== selectedNode ? row.node : null,
                    row.node
                );
            }
        });

        OUTLINE_PANE.addEventListener('dblclick', (event) => {
            if (event.target.classList.contains('node-text')) {
                event.preventDefault();
                event.stopPropagation();

                const nodeEl = event.target.closest('.node');
                if (!nodeEl) return;

                const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);
                if (rowIndex >= 0 && rowIndex < flatRows.length) {
                    const row = flatRows[rowIndex];
                    if (row.hasChildren) {
                        // Handle both selection and toggle in one update
                        updateTree(
                            row.node !== selectedNode ? row.node : null,
                            row.node
                        );
                    }
                }
            }
        });

        // Scroll handler
        OUTLINE_PANE.addEventListener("scroll", throttle(renderTree, 33));

        const getCurrentTheme = () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            // Use OS preference as fallback
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        };

        const applyTheme = (theme) => {
            HTML_ELEMENT.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);

            THEME_TOGGLE.innerHTML = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        };

        applyTheme(getCurrentTheme());

        THEME_TOGGLE.addEventListener('click', () => {
            const currentTheme = HTML_ELEMENT.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        });

        function getSavedOutlineProportion() {
            const saved = localStorage.getItem('outlineProportion');
            return saved ? parseFloat(saved) : null; // Return null instead of default value
        }

        function initializeLayout() {

            const savedProportion = getSavedOutlineProportion();

            if (savedProportion !== null) {
                outlineProportion = savedProportion;
                updateOutlineWidth();
            } else {
                outlineProportion = OUTLINE_PANE.offsetWidth / window.innerWidth;
            }
            // Initial render
            renderTree();
        }

        window.addEventListener('DOMContentLoaded', () => {
            initializeLayout();
            applyTheme(getCurrentTheme());
        });
    </script>
</body>

</html>